// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("./Util.bs.js");
var Child_process = require("child_process");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Parser$AgdaMode = require("./Parser.bs.js");

var Readable = /* module */Block.localModule([], []);

var Writable = /* module */Block.localModule([], []);

var StreamType = /* module */Block.localModule([
    "Readable",
    "Writable"
  ], [
    Readable,
    Writable
  ]);

var Writable$1 = /* module */Block.localModule([], []);

var Readable$1 = /* module */Block.localModule([], []);

var Stream = /* module */Block.localModule([
    "Writable",
    "Readable"
  ], [
    Writable$1,
    Readable$1
  ]);

var ChildProcess = /* module */Block.localModule([], []);

var OS = /* module */Block.localModule([], []);

var AutoSearchExn = Caml_exceptions.create("Connection-AgdaMode.AutoSearchExn");

var ValidationExn = Caml_exceptions.create("Connection-AgdaMode.ValidationExn");

var ConnectionExn = Caml_exceptions.create("Connection-AgdaMode.ConnectionExn");

function toAutoSearchError(match) {
  if (Caml_exceptions.caml_is_extension(match) && match[0] === AutoSearchExn) {
    return match[1];
  }
  
}

function convertError(convertError$1, f, error) {
  var match = Curry._1(convertError$1, error);
  if (match !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(match));
  } else {
    throw Util$AgdaMode.UnhandledPromise;
  }
}

function handleAutoSearchError(f, error) {
  var match = toAutoSearchError(error);
  if (match !== undefined) {
    return Curry._1(f, match);
  } else {
    throw Util$AgdaMode.UnhandledPromise;
  }
}

function toValidationError(match) {
  if (Caml_exceptions.caml_is_extension(match) && match[0] === ValidationExn) {
    return match[1];
  }
  
}

function handleValidationError(f, error) {
  var match = toValidationError(error);
  if (match !== undefined) {
    return Curry._1(f, match);
  } else {
    throw Util$AgdaMode.UnhandledPromise;
  }
}

function toConnectionError(match) {
  if (Caml_exceptions.caml_is_extension(match) && match[0] === ConnectionExn) {
    return match[1];
  }
  
}

function handleConnectionError(f, error) {
  var match = toConnectionError(error);
  if (match !== undefined) {
    return Curry._1(f, match);
  } else {
    throw Util$AgdaMode.UnhandledPromise;
  }
}

function autoSearch(path) {
  return new Promise((function (resolve, reject) {
                var os = Os.type();
                var exit = 0;
                switch (os) {
                  case "Darwin" : 
                  case "Linux" : 
                      exit = 1;
                      break;
                  case "Windows_NT" : 
                      return reject([
                                  AutoSearchExn,
                                  /* NotSupported */Block.variant("NotSupported", 0, ["Windows_NT"])
                                ]);
                  default:
                    return reject([
                                AutoSearchExn,
                                /* NotSupported */Block.variant("NotSupported", 0, [os])
                              ]);
                }
                if (exit === 1) {
                  var hangTimeout = setTimeout((function (param) {
                          return reject([
                                      ValidationExn,
                                      /* ProcessHanging */Block.variant("ProcessHanging", 1, [path])
                                    ]);
                        }), 1000);
                  Child_process.exec("which " + path, (function (error, stdout, stderr) {
                          clearTimeout(hangTimeout);
                          if (!(error == null)) {
                            reject([
                                  AutoSearchExn,
                                  /* NotFound */Block.variant("NotFound", 1, [Rebase.Option[/* getOr */16]("", error.message)])
                                ]);
                          }
                          var stderr$prime = stderr.toString();
                          if (!Rebase.$$String[/* isEmpty */5](stderr$prime)) {
                            reject([
                                  AutoSearchExn,
                                  /* NotFound */Block.variant("NotFound", 1, [stderr$prime])
                                ]);
                          }
                          var stdout$prime = stdout.toString();
                          if (Rebase.$$String[/* isEmpty */5](stdout$prime)) {
                            return reject([
                                        AutoSearchExn,
                                        /* NotFound */Block.variant("NotFound", 1, [""])
                                      ]);
                          } else {
                            return resolve(Parser$AgdaMode.filepath(stdout$prime));
                          }
                        }));
                  return /* () */0;
                }
                
              }));
}

function validateAndMake(path) {
  var parsedPath = Parser$AgdaMode.filepath(path);
  var parseError = function (error) {
    if (error == null) {
      return undefined;
    } else {
      var message = Rebase.Option[/* getOr */16]("", error.message);
      if ((/No such file or directory/).test(message) || (/command not found/).test(message)) {
        return /* NotFound */Block.variant("NotFound", 2, [
                  path,
                  error
                ]);
      } else {
        return /* ShellError */Block.variant("ShellError", 3, [
                  path,
                  error
                ]);
      }
    }
  };
  var parseStdout = function (stdout) {
    var message = stdout.toString();
    var match = message.match((/Agda version (.*)/));
    if (match !== null) {
      var match$1 = Rebase.$$Array[/* get */17](match, 1);
      if (match$1 !== undefined) {
        var match$2 = (/--interaction-json/).test(message);
        return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                      "path",
                      "version",
                      "protocol"
                    ], [
                      parsedPath,
                      match$1,
                      match$2 ? /* EmacsAndJSON */1 : /* EmacsOnly */0
                    ])]);
      } else {
        return /* Error */Block.variant("Error", 1, [/* IsNotAgda */Block.variant("IsNotAgda", 5, [
                      path,
                      message
                    ])]);
      }
    } else {
      return /* Error */Block.variant("Error", 1, [/* IsNotAgda */Block.variant("IsNotAgda", 5, [
                    path,
                    message
                  ])]);
    }
  };
  return new Promise((function (resolve, reject) {
                if (Rebase.$$String[/* isEmpty */5](path)) {
                  reject([
                        ValidationExn,
                        /* PathMalformed */Block.variant("PathMalformed", 0, [
                            path,
                            "the path must not be empty"
                          ])
                      ]);
                }
                var hangTimeout = setTimeout((function (param) {
                        return reject([
                                    ValidationExn,
                                    /* ProcessHanging */Block.variant("ProcessHanging", 1, [path])
                                  ]);
                      }), 1000);
                Child_process.exec(parsedPath, (function (error, stdout, stderr) {
                        clearTimeout(hangTimeout);
                        var match = parseError(error);
                        if (match !== undefined) {
                          reject([
                                ValidationExn,
                                match
                              ]);
                        }
                        var stderr$prime = stderr.toString();
                        if (!Rebase.$$String[/* isEmpty */5](stderr$prime)) {
                          reject([
                                ValidationExn,
                                /* ProcessError */Block.variant("ProcessError", 4, [
                                    path,
                                    stderr$prime
                                  ])
                              ]);
                        }
                        var match$1 = parseStdout(stdout);
                        if (match$1.tag) {
                          return reject([
                                      ValidationExn,
                                      match$1[0]
                                    ]);
                        } else {
                          return resolve(match$1[0]);
                        }
                      }));
                return /* () */0;
              }));
}

function useJSON(metadata) {
  if (atom.config.get("agda-mode.enableJSONProtocol")) {
    return metadata[/* protocol */2] === /* EmacsAndJSON */1;
  } else {
    return false;
  }
}

function connect(metadata) {
  return new Promise((function (resolve, reject) {
                var match = useJSON(metadata);
                var args = match ? /* array */["--interaction-json"] : /* array */["--interaction"];
                var $$process = Child_process.spawn(metadata[/* path */0], args, {
                      shell: true
                    });
                $$process.on("error", (function (exn) {
                          return reject([
                                      ConnectionExn,
                                      /* ShellError */Block.variant("ShellError", 0, [exn])
                                    ]);
                        })).on("close", (function (code, signal) {
                        return reject([
                                    ConnectionExn,
                                    /* Close */Block.variant("Close", 1, [
                                        code,
                                        signal
                                      ])
                                  ]);
                      }));
                $$process.stdout.once("data", (function (param) {
                        return resolve(/* record */Block.record([
                                      "metadata",
                                      "sockets"
                                    ], [
                                      metadata,
                                      Block.record([
                                          "stdout",
                                          "stdin",
                                          "queue"
                                        ], [
                                          $$process.stdout,
                                          $$process.stdin,
                                          []
                                        ])
                                    ]));
                      }));
                return /* () */0;
              }));
}

function disconnect(self) {
  self[/* sockets */1][/* stdin */1].end();
  return /* () */0;
}

function wire(self) {
  var response = function (data) {
    console.log(data);
    var match = Rebase.$$Array[/* get */17](self[/* sockets */1][/* queue */2], 0);
    if (match !== undefined) {
      Curry._1(match[/* resolve */2], data);
      self[/* sockets */1][/* queue */2].pop();
      return /* () */0;
    } else {
      console.log("WTF!!");
      return /* () */0;
    }
  };
  var buffer = /* record */Block.record(["contents"], [""]);
  var onData = function (chunk) {
    var string = chunk.toString();
    var endOfResponse = Rebase.$$String[/* endsWith */4]("Agda2> ", string);
    if (endOfResponse) {
      var withoutSuffix = string.substring(0, Rebase.$$String[/* length */1](string) - 7 | 0);
      var data = buffer[0] + withoutSuffix;
      if (!Rebase.$$String[/* isEmpty */5](data)) {
        response(data);
      }
      buffer[0] = "";
      return /* () */0;
    } else {
      buffer[0] = buffer[0] + string;
      return /* () */0;
    }
  };
  self[/* sockets */1][/* stdout */0].on("data", onData);
  return Promise.resolve(self);
}

function send(request, self) {
  var reqPromise = Util$AgdaMode.TelePromise[/* make */0](/* () */0);
  self[/* sockets */1][/* queue */2].push(reqPromise);
  self[/* sockets */1][/* stdin */1].write(Buffer.from(request));
  return Curry._1(reqPromise[/* wire */0], /* () */0);
}

exports.StreamType = StreamType;
exports.Stream = Stream;
exports.ChildProcess = ChildProcess;
exports.OS = OS;
exports.AutoSearchExn = AutoSearchExn;
exports.ValidationExn = ValidationExn;
exports.ConnectionExn = ConnectionExn;
exports.toAutoSearchError = toAutoSearchError;
exports.convertError = convertError;
exports.handleAutoSearchError = handleAutoSearchError;
exports.toValidationError = toValidationError;
exports.handleValidationError = handleValidationError;
exports.toConnectionError = toConnectionError;
exports.handleConnectionError = handleConnectionError;
exports.autoSearch = autoSearch;
exports.validateAndMake = validateAndMake;
exports.useJSON = useJSON;
exports.connect = connect;
exports.disconnect = disconnect;
exports.wire = wire;
exports.send = send;
/* os Not a pure module */
