// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("../../Util/Util.bs.js");
var Emacs__Parser$AgdaMode = require("./Emacs__Parser.bs.js");
var Emacs__Component$AgdaMode = require("./Emacs__Component.bs.js");

function toString(self) {
  return "Metas " + (self.title + ("\n" + (Util$AgdaMode.Pretty.array($$Array.map(Emacs__Component$AgdaMode.Output.toString, self.interactionMetas)) + ("\n" + (Util$AgdaMode.Pretty.array($$Array.map(Emacs__Component$AgdaMode.Output.toString, self.hiddenMetas)) + ("\n" + (Util$AgdaMode.Pretty.array($$Array.map(Emacs__Component$AgdaMode.WarningError.toString, self.warnings)) + ("\n" + Util$AgdaMode.Pretty.array($$Array.map(Emacs__Component$AgdaMode.WarningError.toString, self.errors))))))))));
}

function parse(title, body) {
  var partiteAllGoalsWarnings = function (title, body) {
    var lines = body.split("\n");
    var hasMetas = Rebase.$$Option.isSome(Caml_option.null_to_opt(title.match(/Goals/)));
    var hasWarnings = Rebase.$$Option.isSome(Caml_option.null_to_opt(title.match(/Warnings/)));
    var hasErrors = Rebase.$$Option.isSome(Caml_option.null_to_opt(title.match(/Errors/)));
    var markMetas = function (param) {
      if (hasMetas && param[1] === 0) {
        return "metas";
      }
      
    };
    var markWarnings = function (param) {
      if (hasWarnings) {
        if (hasMetas) {
          return Rebase.$$Option.map((function (param) {
                        return "warnings";
                      }), Caml_option.null_to_opt(param[0].slice(5, 13).match(/Warnings/)));
        } else if (param[1] === 0) {
          return "warnings";
        } else {
          return ;
        }
      }
      
    };
    var markErrors = function (param) {
      if (hasErrors) {
        if (hasMetas || hasWarnings) {
          return Rebase.$$Option.map((function (param) {
                        return "errors";
                      }), Caml_option.null_to_opt(param[0].slice(5, 11).match(/Errors/)));
        } else if (param[1] === 0) {
          return "errors";
        } else {
          return ;
        }
      }
      
    };
    return Util$AgdaMode.Dict.partite((function (line) {
                  return Rebase.$$Option.or_(Rebase.$$Option.or_(markMetas(line), markWarnings(line)), markErrors(line));
                }), lines);
  };
  var dictionary = Emacs__Parser$AgdaMode.partiteWarningsOrErrors("errors")(Emacs__Parser$AgdaMode.partiteWarningsOrErrors("warnings")(Emacs__Parser$AgdaMode.partiteMetas(partiteAllGoalsWarnings(title, body))));
  var interactionMetas = Rebase.$$Option.mapOr((function (metas) {
          return Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), Rebase.$$Array.map(Emacs__Component$AgdaMode.Output.parseOutputWithoutRange, metas));
        }), [], Js_dict.get(dictionary, "interactionMetas"));
  var hiddenMetas = Rebase.$$Option.mapOr((function (metas) {
          return Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), Rebase.$$Array.map(Emacs__Component$AgdaMode.Output.parseOutputWithRange, metas));
        }), [], Js_dict.get(dictionary, "hiddenMetas"));
  var warnings = Rebase.$$Option.mapOr((function (entries) {
          return Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), Rebase.$$Array.map(Emacs__Component$AgdaMode.WarningError.parseWarning, entries));
        }), [], Js_dict.get(dictionary, "warnings"));
  var errors = Rebase.$$Option.mapOr((function (entries) {
          return Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), Rebase.$$Array.map(Emacs__Component$AgdaMode.WarningError.parseError, entries));
        }), [], Js_dict.get(dictionary, "errors"));
  return {
          title: title,
          interactionMetas: interactionMetas,
          hiddenMetas: hiddenMetas,
          warnings: warnings,
          errors: errors
        };
}

function Emacs__AllGoalsWarnings(Props) {
  var value = Props.value;
  return React.createElement(React.Fragment, undefined, React.createElement("ul", undefined, $$Array.map((function (value) {
                        return React.createElement(Emacs__Component$AgdaMode.Output.make, {
                                    value: value
                                  });
                      }), value.interactionMetas)), React.createElement("ul", undefined, $$Array.map((function (value) {
                        return React.createElement(Emacs__Component$AgdaMode.Output.make, {
                                    value: value
                                  });
                      }), value.hiddenMetas)), React.createElement("ul", undefined, $$Array.map((function (value) {
                        return React.createElement(Emacs__Component$AgdaMode.WarningError.make, {
                                    value: value
                                  });
                      }), value.warnings)), React.createElement("ul", undefined, $$Array.map((function (value) {
                        return React.createElement(Emacs__Component$AgdaMode.WarningError.make, {
                                    value: value
                                  });
                      }), value.errors)));
}

var make = Emacs__AllGoalsWarnings;

exports.toString = toString;
exports.parse = parse;
exports.make = make;
/* react Not a pure module */
