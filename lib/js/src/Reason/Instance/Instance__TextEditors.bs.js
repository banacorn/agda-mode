// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Goal$AgdaMode = require("../Goal.bs.js");
var Async$AgdaMode = require("../Util/Async.bs.js");
var Editors$AgdaMode = require("../Editors.bs.js");

function getPointedGoal(instance) {
  var pointed = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */4], instance[/* editors */1]);
  if (pointed !== undefined) {
    return Async$AgdaMode.resolve(pointed);
  } else {
    return Async$AgdaMode.reject(/* OutOfGoal */2);
  }
}

function getPointedGoalAt(cursor, instance) {
  var pointed = Editors$AgdaMode.pointingAt(Caml_option.some(cursor), instance[/* goals */4], instance[/* editors */1]);
  if (pointed !== undefined) {
    return Async$AgdaMode.resolve(pointed);
  } else {
    return Async$AgdaMode.reject(/* OutOfGoal */2);
  }
}

function handleOutOfGoal(callback) {
  return Async$AgdaMode.thenError((function (error) {
                if (typeof error === "number" && error >= 2) {
                  return Curry._1(callback, /* () */0);
                } else {
                  return Async$AgdaMode.reject(error);
                }
              }));
}

function getGoalIndex(goal) {
  var match = goal[/* index */1];
  if (match !== undefined) {
    return Async$AgdaMode.resolve(/* tuple */[
                goal,
                match
              ]);
  } else {
    return Async$AgdaMode.reject(/* GoalNotIndexed */1);
  }
}

function recoverCursor(callback, instance) {
  var cursor = instance[/* editors */1][/* source */1].getCursorBufferPosition();
  var result = Curry._1(callback, /* () */0);
  handleOutOfGoal((function (param) {
            instance[/* editors */1][/* source */1].setCursorBufferPosition(cursor);
            return Async$AgdaMode.resolve(/* () */0);
          }))(Async$AgdaMode.thenOk((function (goal) {
                var fresh = Goal$AgdaMode.isEmpty(goal);
                if (fresh) {
                  var delta = new Atom.Point(0, 3);
                  var newPosition = goal[/* range */2].start.translate(delta);
                  setTimeout((function (param) {
                          instance[/* editors */1][/* source */1].setCursorBufferPosition(newPosition);
                          return /* () */0;
                        }), 0);
                  return Async$AgdaMode.resolve(/* () */0);
                } else {
                  instance[/* editors */1][/* source */1].setCursorBufferPosition(cursor);
                  return Async$AgdaMode.resolve(/* () */0);
                }
              }))(getPointedGoalAt(cursor, instance)));
  return result;
}

function getSelectedTextNode(instance) {
  var getLargerSyntaxNode = function (param) {
    instance[/* editors */1][/* source */1].selectLargerSyntaxNode();
    return instance[/* editors */1][/* source */1].getSelectedText();
  };
  var getPointedWord = function (param) {
    instance[/* editors */1][/* source */1].selectWordsContainingCursors();
    return instance[/* editors */1][/* source */1].getSelectedText();
  };
  var selectedText = instance[/* editors */1][/* source */1].getSelectedText();
  if (Rebase.$$String[/* isEmpty */5](selectedText)) {
    var largerNode = getLargerSyntaxNode(/* () */0);
    if (Rebase.$$String[/* isEmpty */5](largerNode)) {
      return getPointedWord(/* () */0);
    } else {
      var pointedText = getPointedWord(/* () */0);
      if (pointedText === "_") {
        return getLargerSyntaxNode(/* () */0);
      } else {
        return pointedText;
      }
    }
  } else {
    return selectedText;
  }
}

exports.getPointedGoal = getPointedGoal;
exports.getPointedGoalAt = getPointedGoalAt;
exports.handleOutOfGoal = handleOutOfGoal;
exports.getGoalIndex = getGoalIndex;
exports.recoverCursor = recoverCursor;
exports.getSelectedTextNode = getSelectedTextNode;
/* atom Not a pure module */
