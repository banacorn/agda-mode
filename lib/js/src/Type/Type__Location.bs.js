// Generated by BUCKLESCRIPT VERSION 5.0.1, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Util$AgdaMode = require("../Util.bs.js");
var Parser$AgdaMode = require("../Parser.bs.js");

function decode(param) {
  return Json_decode.andThen((function (tup, param) {
                return /* record */Block.record([
                          "pos",
                          "line",
                          "col"
                        ], [
                          Rebase.$$Array[/* get */17](tup, 2),
                          Rebase.$$Option[/* getOr */16](0, Rebase.$$Array[/* get */17](tup, 0)),
                          Rebase.$$Option[/* getOr */16](0, Rebase.$$Array[/* get */17](tup, 1))
                        ]);
              }), (function (param) {
                return Json_decode.array(Json_decode.$$int, param);
              }), param);
}

var Position = /* module */Block.localModule(["decode"], [decode]);

function fuse(a, b) {
  var start = Caml_obj.caml_greaterthan(a[/* start */0][/* pos */0], b[/* start */0][/* pos */0]) ? b[/* start */0] : a[/* start */0];
  var end_ = Caml_obj.caml_greaterthan(a[/* end_ */1][/* pos */0], b[/* end_ */1][/* pos */0]) ? a[/* end_ */1] : b[/* end_ */1];
  return /* record */Block.record([
            "start",
            "end_"
          ], [
            start,
            end_
          ]);
}

function toString(self) {
  if (self[/* start */0][/* line */1] === self[/* end_ */1][/* line */1]) {
    return String(self[/* start */0][/* line */1]) + ("," + (String(self[/* start */0][/* col */2]) + ("-" + String(self[/* end_ */1][/* col */2]))));
  } else {
    return String(self[/* start */0][/* line */1]) + ("," + (String(self[/* start */0][/* col */2]) + ("-" + (String(self[/* end_ */1][/* line */1]) + ("," + String(self[/* end_ */1][/* col */2]))))));
  }
}

function toAtomRange(self) {
  var start = new Atom.Point(self[/* start */0][/* line */1] - 1 | 0, self[/* start */0][/* col */2] - 1 | 0);
  var end_ = new Atom.Point(self[/* end_ */1][/* line */1] - 1 | 0, self[/* end_ */1][/* col */2] - 1 | 0);
  return new Atom.Range(start, end_);
}

function decode$1(json) {
  return /* record */Block.record([
            "start",
            "end_"
          ], [
            Json_decode.field("start", decode, json),
            Json_decode.field("end", decode, json)
          ]);
}

var Interval = /* module */Block.localModule([
    "fuse",
    "toString",
    "toAtomRange",
    "decode"
  ], [
    fuse,
    toString,
    toAtomRange,
    decode$1
  ]);

var partial_arg = (/^(\S+)\:(?:(\d+)\,(\d+)\-(\d+)\,(\d+)|(\d+)\,(\d+)\-(\d+))$/);

function parse(param) {
  return Parser$AgdaMode.captures((function (captured) {
                var srcFile = Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 1));
                var sameRow = Rebase.$$Option[/* isSome */13](Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 6)));
                if (sameRow) {
                  return Rebase.$$Option[/* flatMap */5]((function (row) {
                                return Rebase.$$Option[/* flatMap */5]((function (colStart) {
                                              return Rebase.$$Option[/* flatMap */5]((function (colEnd) {
                                                            return /* Range */Block.simpleVariant("Range", [
                                                                      srcFile,
                                                                      /* array */[/* record */Block.record([
                                                                            "start",
                                                                            "end_"
                                                                          ], [
                                                                            Block.record([
                                                                                "pos",
                                                                                "line",
                                                                                "col"
                                                                              ], [
                                                                                undefined,
                                                                                row,
                                                                                colStart
                                                                              ]),
                                                                            Block.record([
                                                                                "pos",
                                                                                "line",
                                                                                "col"
                                                                              ], [
                                                                                undefined,
                                                                                row,
                                                                                colEnd
                                                                              ])
                                                                          ])]
                                                                    ]);
                                                          }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 8))));
                                            }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 7))));
                              }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 6))));
                } else {
                  return Rebase.$$Option[/* flatMap */5]((function (rowStart) {
                                return Rebase.$$Option[/* flatMap */5]((function (colStart) {
                                              return Rebase.$$Option[/* flatMap */5]((function (rowEnd) {
                                                            return Rebase.$$Option[/* flatMap */5]((function (colEnd) {
                                                                          return /* Range */Block.simpleVariant("Range", [
                                                                                    srcFile,
                                                                                    /* array */[/* record */Block.record([
                                                                                          "start",
                                                                                          "end_"
                                                                                        ], [
                                                                                          Block.record([
                                                                                              "pos",
                                                                                              "line",
                                                                                              "col"
                                                                                            ], [
                                                                                              undefined,
                                                                                              rowStart,
                                                                                              colStart
                                                                                            ]),
                                                                                          Block.record([
                                                                                              "pos",
                                                                                              "line",
                                                                                              "col"
                                                                                            ], [
                                                                                              undefined,
                                                                                              rowEnd,
                                                                                              colEnd
                                                                                            ])
                                                                                        ])]
                                                                                  ]);
                                                                        }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 5))));
                                                          }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 4))));
                                            }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 3))));
                              }), Rebase.$$Option[/* flatMap */5](Parser$AgdaMode.$$int, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, 2))));
                }
              }), partial_arg, param);
}

function fuse$1(a, b) {
  var mergeTouching = function (l, e, s, r) {
    return Rebase.List[/* concat */11](Rebase.List[/* concat */11](l, /* :: */Block.simpleVariant("::", [
                      /* record */Block.record([
                          "start",
                          "end_"
                        ], [
                          e[/* start */0],
                          s[/* end_ */1]
                        ]),
                      /* [] */0
                    ])), r);
  };
  var fuseSome = function (s1, r1, s2, r2) {
    var r1$prime = Util$AgdaMode.List_[/* dropWhile */4]((function (x) {
            return Caml_obj.caml_lessequal(x[/* end_ */1][/* pos */0], s2[/* end_ */1][/* pos */0]);
          }), r1);
    return helpFuse(r1$prime, /* :: */Block.simpleVariant("::", [
                  fuse(s1, s2),
                  r2
                ]));
  };
  var outputLeftPrefix = function (s1, r1, s2, is2) {
    var match = Util$AgdaMode.List_[/* span */3]((function (s) {
            return Caml_obj.caml_lessthan(s[/* end_ */1][/* pos */0], s2[/* start */0][/* pos */0]);
          }), r1);
    return Rebase.List[/* concat */11](Rebase.List[/* concat */11](/* :: */Block.simpleVariant("::", [
                      s1,
                      /* [] */0
                    ]), match[0]), helpFuse(match[1], is2));
  };
  var helpFuse = function (a, b) {
    var match = Rebase.List[/* reverse */20](a);
    var match$1 = Rebase.List[/* reverse */20](b);
    if (a) {
      if (match) {
        if (b) {
          if (match$1) {
            var e2 = match$1[0];
            var r2 = b[1];
            var s2 = b[0];
            var e1 = match[0];
            var r1 = a[1];
            var s1 = a[0];
            if (Caml_obj.caml_lessthan(e1[/* end_ */1][/* pos */0], s2[/* start */0][/* pos */0])) {
              return Rebase.List[/* concat */11](a, b);
            } else if (Caml_obj.caml_lessthan(e2[/* end_ */1][/* pos */0], s1[/* start */0][/* pos */0])) {
              return Rebase.List[/* concat */11](b, a);
            } else if (e1[/* end_ */1][/* pos */0] === s2[/* start */0][/* pos */0]) {
              return mergeTouching(match[1], e1, s2, r2);
            } else if (e2[/* end_ */1][/* pos */0] === s1[/* start */0][/* pos */0]) {
              return mergeTouching(match$1[1], e2, s1, r1);
            } else if (Caml_obj.caml_lessthan(s1[/* end_ */1][/* pos */0], s2[/* start */0][/* pos */0])) {
              return outputLeftPrefix(s1, r1, s2, b);
            } else if (Caml_obj.caml_lessthan(s2[/* end_ */1][/* pos */0], s1[/* start */0][/* pos */0])) {
              return outputLeftPrefix(s2, r2, s1, a);
            } else if (Caml_obj.caml_lessthan(s1[/* end_ */1][/* pos */0], s2[/* end_ */1][/* pos */0])) {
              return fuseSome(s1, r1, s2, r2);
            } else {
              return fuseSome(s2, r2, s1, r1);
            }
          } else {
            return Pervasives.failwith("something wrong with Range::fuse");
          }
        } else if (b) {
          return Pervasives.failwith("something wrong with Range::fuse");
        } else {
          return b;
        }
      } else if (b) {
        return Pervasives.failwith("something wrong with Range::fuse");
      } else {
        return b;
      }
    } else {
      return a;
    }
  };
  if (a) {
    if (b) {
      return /* Range */Block.simpleVariant("Range", [
                a[0],
                Rebase.$$Array[/* fromList */13](helpFuse(Rebase.List[/* fromArray */12](a[1]), Rebase.List[/* fromArray */12](b[1])))
              ]);
    } else {
      return a;
    }
  } else {
    return b;
  }
}

function toString$1(self) {
  if (self) {
    var match = self[0];
    if (match !== undefined) {
      var xs = self[1];
      var filepath = match;
      if (xs.length !== 0) {
        var match$1 = Rebase.$$Array[/* get */17](xs, 0);
        var match$2 = Rebase.$$Array[/* get */17](xs, Rebase.$$Array[/* length */16](xs) - 1 | 0);
        return filepath + (":" + (
                  match$1 !== undefined && match$2 !== undefined ? toString(/* record */Block.record([
                            "start",
                            "end_"
                          ], [
                            match$1[/* start */0],
                            match$2[/* end_ */1]
                          ])) : ""
                ));
      } else {
        return filepath;
      }
    } else {
      var xs$1 = self[1];
      var match$3 = Rebase.$$Array[/* get */17](xs$1, 0);
      var match$4 = Rebase.$$Array[/* get */17](xs$1, Rebase.$$Array[/* length */16](xs$1) - 1 | 0);
      if (match$3 !== undefined && match$4 !== undefined) {
        return toString(/* record */Block.record([
                      "start",
                      "end_"
                    ], [
                      match$3[/* start */0],
                      match$4[/* end_ */1]
                    ]));
      } else {
        return "";
      }
    }
  } else {
    return "";
  }
}

function toAtomRanges(self) {
  if (self) {
    return Rebase.$$Array[/* map */0](toAtomRange, self[1]);
  } else {
    return /* array */[];
  }
}

function decode$2(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "NoRange" : 
                      return /* NoRange */0;
                  case "Range" : 
                      return /* Range */Block.simpleVariant("Range", [
                                Json_decode.field("source", (function (param) {
                                        return Json_decode.optional(Json_decode.string, param);
                                      }), json),
                                Json_decode.field("intervals", (function (param) {
                                        return Json_decode.array(decode$1, param);
                                      }), json)
                              ]);
                  default:
                    return Pervasives.failwith("unknown kind of Range");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

var $$Range = /* module */Block.localModule([
    "parse",
    "fuse",
    "toString",
    "toAtomRanges",
    "decode"
  ], [
    parse,
    fuse$1,
    toString$1,
    toAtomRanges,
    decode$2
  ]);

exports.Position = Position;
exports.Interval = Interval;
exports.$$Range = $$Range;
/* partial_arg Not a pure module */
