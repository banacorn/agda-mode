// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Parser$AgdaMode = require("./Parser.bs.js");

function parse(filepath) {
  if (/\.lagda.rst$/i.test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateRST */2;
  } else if (/\.lagda.md$/i.test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateMarkdown */3;
  } else if (/\.lagda.tex$|\.lagda$/i.test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateTeX */1;
  } else if (/\.lagda.org$/i.test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateOrg */4;
  } else {
    return /* Agda */0;
  }
}

var FileType = {
  parse: parse
};

function isHole(token) {
  var match = token.kind;
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

var Token = {
  isHole: isHole
};

function make(raw) {
  return [{
            content: raw,
            range: /* tuple */[
              0,
              raw.length
            ],
            kind: /* AgdaRaw */0
          }];
}

function lex(regex, source, target, tokens) {
  var f = function (token) {
    if (token.kind !== source) {
      return [token];
    }
    var cursor = {
      contents: token.range[0]
    };
    return Belt_Array.map(Belt_Array.keepMap(token.content.split(regex), (function (x) {
                      return x;
                    })), (function (content) {
                  var kind = regex.test(content) ? target : source;
                  var cursorOld = cursor.contents;
                  cursor.contents = cursor.contents + content.length | 0;
                  return {
                          content: content,
                          range: /* tuple */[
                            cursorOld,
                            cursor.contents
                          ],
                          kind: kind
                        };
                }));
  };
  return Belt_Array.concatMany(Belt_Array.map(tokens, f));
}

function map(f, self) {
  var delta = {
    contents: 0
  };
  return Belt_Array.map(self, (function (token) {
                var match = Curry._1(f, token);
                var content = match.content;
                var match$1 = token.range;
                var lengthDiff = content.length - token.content.length | 0;
                var result_range = /* tuple */[
                  match$1[0] + delta.contents | 0,
                  (match$1[1] + delta.contents | 0) + lengthDiff | 0
                ];
                var result_kind = match.kind;
                var result = {
                  content: content,
                  range: result_range,
                  kind: result_kind
                };
                delta.contents = delta.contents + lengthDiff | 0;
                return result;
              }));
}

function mapOnly(kind, f, self) {
  return map((function (token) {
                if (token.kind === kind) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = /\\begin\{code\}.*/;

var texEnd = /\\end\{code\}.*/;

var markdown = /\`\`\`(agda)?/;

var rstBegin = /^\:\:/;

var rstEnd = /^[^\s]/;

var orgBegin = /\#\+begin\_src agda2/i;

var orgEnd = /\#\+end\_src/i;

var comment = /(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/;

var goalBracket = /(\{\!(?:(?!\!\})(?:.|\s))*\!\})/;

var goalQuestionMarkRaw = /([\s\(\{\_\;\.\"@]|^)(\?)([\s\)\}\_\;\.\"@]|$)/gm;

var goalQuestionMark = /(\?)/;

var goalBracketContent = /\{\!((?:(?!\!\})(?:.|\s))*)\!\}/;

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  rstBegin: rstBegin,
  rstEnd: rstEnd,
  orgBegin: orgBegin,
  orgEnd: orgEnd,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function toTokens(raw) {
  var cursor = {
    contents: 0
  };
  return Belt_Option.mapWithDefault(Caml_option.null_to_opt(raw.match(/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g)), [], (function (lines) {
                return Belt_Array.map(Belt_Array.keep(lines, (function (x) {
                                  return x !== "";
                                })), (function (line) {
                              var cursorOld = cursor.contents;
                              cursor.contents = cursor.contents + line.length | 0;
                              return {
                                      content: raw.substring(cursorOld, cursor.contents),
                                      range: /* tuple */[
                                        cursorOld,
                                        cursor.contents
                                      ],
                                      kind: /* Literate */1
                                    };
                            }));
              }));
}

function markWithRules(begin_, end_, raw) {
  var previous = {
    contents: false
  };
  var current = {
    contents: false
  };
  return Belt_Array.map(toTokens(raw), (function (token) {
                var content = token.content;
                previous.contents = current.contents;
                if (begin_.test(content) && !current.contents) {
                  current.contents = true;
                } else if (end_.test(content) && current.contents) {
                  current.contents = false;
                }
                var insideAgda = previous.contents && current.contents;
                var kind = insideAgda ? /* AgdaRaw */0 : /* Literate */1;
                return {
                        content: content,
                        range: token.range,
                        kind: kind
                      };
              }));
}

function markMarkdown(param) {
  return markWithRules(markdown, markdown, param);
}

function markTex(param) {
  return markWithRules(texBegin, texEnd, param);
}

function markRST(param) {
  return markWithRules(rstBegin, rstEnd, param);
}

function markOrg(param) {
  return markWithRules(orgBegin, orgEnd, param);
}

var Literate = {
  toTokens: toTokens,
  markWithRules: markWithRules,
  markMarkdown: markMarkdown,
  markTex: markTex,
  markRST: markRST,
  markOrg: markOrg
};

function toString(param) {
  var originalRange = param.originalRange;
  var modifiedRange = param.modifiedRange;
  return "Hole [" + (String(param.index) + ("] (" + (String(originalRange[0]) + (", " + (String(originalRange[1]) + (") => (" + (String(modifiedRange[0]) + (", " + (String(modifiedRange[1]) + (") \"" + (param.content + "\"")))))))))));
}

var Diff = {
  toString: toString
};

function parse$1(indices, filepath, raw) {
  var i = {
    contents: 0
  };
  var fileType = parse(filepath);
  var preprocessed;
  switch (fileType) {
    case /* Agda */0 :
        preprocessed = make(raw);
        break;
    case /* LiterateTeX */1 :
        preprocessed = markWithRules(texBegin, texEnd, raw);
        break;
    case /* LiterateRST */2 :
        preprocessed = markWithRules(rstBegin, rstEnd, raw);
        break;
    case /* LiterateMarkdown */3 :
        preprocessed = markWithRules(markdown, markdown, raw);
        break;
    case /* LiterateOrg */4 :
        preprocessed = markWithRules(orgBegin, orgEnd, raw);
        break;
    
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return {
            content: "{!   !}",
            range: token.range,
            kind: /* GoalBracket */3
          };
  };
  var adjustGoalBracket = function (token) {
    var idx = Belt_Array.get(indices, i.contents);
    var goalIndex = idx !== undefined ? String(idx) : "*";
    var requiredSpaces = goalIndex.length;
    var content = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_option.null_to_opt(goalBracketContent.exec(token.content)), (function (result) {
                return Belt_Option.flatMap(Belt_Option.map(Belt_Array.get(result, 1), (function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                })), (function (x) {
                              return x;
                            }));
              })), "");
    var actualSpaces = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_option.null_to_opt(content.match(/\s*$/)), (function (matches) {
                return Belt_Option.map(Belt_Array.get(matches, 0), (function (prim) {
                              return prim.length;
                            }));
              })), 0);
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token.content.replace(/\{!.*!\}/, "{!" + (content + (padding + "!}")));
    } else {
      newContent = token.content;
    }
    i.contents = i.contents + 1 | 0;
    return {
            content: newContent,
            range: /* tuple */[
              1,
              2
            ],
            kind: /* GoalBracket */3
          };
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Belt_Array.keep(original, isHole);
  var modifiedHoles = Belt_Array.keep(modified, isHole);
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(originalHoles, (function (idx, token) {
                    var match = Belt_Array.get(modifiedHoles, idx);
                    var match$1 = Belt_Array.get(indices, idx);
                    if (match === undefined) {
                      return ;
                    }
                    if (match$1 === undefined) {
                      return ;
                    }
                    var match$2 = match.range;
                    var start = match$2[0];
                    return {
                            index: match$1,
                            modifiedRange: match.range,
                            originalRange: /* tuple */[
                              start,
                              start + token.content.length | 0
                            ],
                            content: match.content
                          };
                  })), (function (x) {
                return x;
              }));
}

exports.FileType = FileType;
exports.Token = Token;
exports.Lexer = Lexer;
exports.Regex = Regex;
exports.Literate = Literate;
exports.Diff = Diff;
exports.parse = parse$1;
/* Parser-AgdaMode Not a pure module */
