// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("../../Util.bs.js");
var Type__Location$AgdaMode = require("../../Type/Type__Location.bs.js");
var Emacs__Component$AgdaMode = require("./Emacs__Component.bs.js");

function unindent(lines) {
  var newLineIndices = Rebase.$$Array[/* map */0]((function (param) {
          return param[2];
        }), Rebase.$$Array[/* filter */10]((function (param) {
              var line = param[0];
              var nextLine = param[1];
              var sort = (/^Sort \S*/);
              var delimeter = (/^\u2014{4}/g);
              var completeJudgement = (/^(?:(?:[^\(\{\s]+\s+\:)|Have\:|Goal\:)\s* \S*/);
              var reallyLongTermIdentifier = (/^\S+$/);
              var restOfTheJudgement = (/^\s*\:\s* \S*/);
              if (sort.test(line) || delimeter.test(line) || reallyLongTermIdentifier.test(line) && Rebase.$$Option[/* exists */9]((function (line) {
                        return restOfTheJudgement.test(line);
                      }), nextLine)) {
                return true;
              } else {
                return completeJudgement.test(line);
              }
            }), Rebase.$$Array[/* mapi */27]((function (line, index) {
                  return /* tuple */[
                          line,
                          Rebase.$$Array[/* get */17](lines, index + 1 | 0),
                          index
                        ];
                }), lines)));
  return Rebase.$$Array[/* map */0]((function (param) {
                return Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* slice */25](param[0], param[1], lines)));
              }), Rebase.$$Array[/* mapi */27]((function (index, i) {
                    var match = Rebase.$$Array[/* get */17](newLineIndices, i + 1 | 0);
                    if (match !== undefined) {
                      return /* tuple */[
                              index,
                              match
                            ];
                    } else {
                      return /* tuple */[
                              index,
                              Rebase.$$Array[/* length */16](lines) + 1 | 0
                            ];
                    }
                  }), newLineIndices));
}

var partial_arg = Util$AgdaMode.Dict[/* split */1];

function partiteMetas(param) {
  return partial_arg("metas", (function (rawMetas) {
                var metas = unindent(rawMetas);
                var indexOfHiddenMetas = Rebase.$$Option[/* map */0]((function (prim) {
                        return prim[0];
                      }), Rebase.$$Array[/* findIndex */29]((function (s) {
                            return Rebase.$$Option[/* isSome */13](Curry._1(Emacs__Component$AgdaMode.Output[/* parseOutputWithRange */1], s));
                          }), metas));
                return Util$AgdaMode.Dict[/* partite */0]((function (param) {
                              var i = param[1];
                              if (indexOfHiddenMetas !== undefined) {
                                if (i === indexOfHiddenMetas) {
                                  return "hiddenMetas";
                                } else if (i === 0) {
                                  return "interactionMetas";
                                } else {
                                  return undefined;
                                }
                              } else if (i === 0) {
                                return "interactionMetas";
                              } else {
                                return undefined;
                              }
                            }), metas);
              }), param);
}

function partiteWarningsOrErrors(key) {
  var partial_arg = Util$AgdaMode.Dict[/* update */2];
  return (function (param) {
      return partial_arg(key, (function (raw) {
                    var partial_arg = (/^\u2014{4}/);
                    var hasDelimeter = Rebase.$$Option[/* isSome */13](Rebase.$$Option[/* flatMap */5]((function (param) {
                                return Caml_option.null_to_opt(param.match(partial_arg));
                              }), Rebase.$$Array[/* get */17](raw, 0)));
                    var lines = hasDelimeter ? raw.slice(1) : raw;
                    var markWarningStart = function (line) {
                      return Rebase.$$Option[/* isSome */13](Curry._1(Type__Location$AgdaMode.$$Range[/* parse */0], line));
                    };
                    var glueBack = function (xs) {
                      var partial_arg = (/at$/);
                      return Rebase.$$Option[/* isSome */13](Rebase.$$Option[/* flatMap */5]((function (param) {
                                        return Caml_option.null_to_opt(param.match(partial_arg));
                                      }), Rebase.$$Array[/* get */17](xs, Rebase.$$Array[/* length */16](xs) - 1 | 0)));
                    };
                    return Rebase.$$Array[/* map */0]((function (xs) {
                                  return Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](xs));
                                }), Util$AgdaMode.Array_[/* mergeWithNext */1](glueBack)(Util$AgdaMode.Array_[/* partite */0](markWarningStart, lines)));
                  }), param);
    });
}

function preprocess(string) {
  var result = string.replace((/\\\\/g), "/");
  if (result.substring(0, 13) === "cannot read: ") {
    return /* Error */Block.variant("Error", 1, [result.slice(12)]);
  } else if (Rebase.$$String[/* startsWith */3]("((last", result)) {
    var index = result.indexOf("(agda");
    return /* Ok */Block.variant("Ok", 0, [result.substring(index, Rebase.$$String[/* length */1](string) - 1 | 0)]);
  } else {
    return /* Ok */Block.variant("Ok", 0, [result]);
  }
}

function toString(param) {
  if (param.tag) {
    return "[" + (Rebase.$$Array[/* map */0](toString, param[0]).join(", ") + "]");
  } else {
    return "\"" + (param[0] + "\"");
  }
}

function flatten(param) {
  if (param.tag) {
    return Rebase.$$Array[/* flatMap */5](flatten, param[0]);
  } else {
    return /* array */[param[0]];
  }
}

function postprocess(string) {
  var stack = /* array */[/* record */Block.record(["contents"], [Block.variant("L", 1, [/* array */[]])])];
  var word = "";
  var escaped = false;
  var in_str = false;
  var pushToTheTop = function (elem) {
    var index = Rebase.$$Array[/* length */16](stack) - 1 | 0;
    var match = Rebase.$$Array[/* get */17](stack, index);
    if (match !== undefined) {
      var expr = match;
      var match$1 = expr[0];
      if (match$1.tag) {
        match$1[0].push(elem);
        return /* () */0;
      } else {
        expr[0] = /* L */Block.variant("L", 1, [/* array */[
              expr[0],
              elem
            ]]);
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
  var totalLength = Rebase.$$String[/* length */1](string);
  for(var i = 0 ,i_finish = totalLength - 1 | 0; i <= i_finish; ++i){
    var $$char = string.charAt(i);
    if (escaped) {
      if ($$char === "n") {
        word = word + "\\";
      }
      word = word + $$char;
      escaped = false;
    } else if (!($$char === "'" && !in_str)) {
      if ($$char === "(" && !in_str) {
        stack.push(/* record */Block.record(["contents"], [Block.variant("L", 1, [/* array */[]])]));
      } else if ($$char === ")" && !in_str) {
        if (word !== "") {
          pushToTheTop(/* A */Block.variant("A", 0, [word]));
          word = "";
        }
        var match = stack.pop();
        if (match !== undefined) {
          pushToTheTop(match[0]);
        }
        
      } else if ($$char === " " && !in_str) {
        if (word !== "") {
          pushToTheTop(/* A */Block.variant("A", 0, [word]));
          word = "";
        }
        
      } else if ($$char === "\"") {
        in_str = !in_str;
      } else if ($$char === "\\" && in_str) {
        escaped = true;
      } else {
        word = word + $$char;
      }
    }
    
  }
  var match$1 = Rebase.$$Array[/* get */17](stack, 0);
  if (match$1 !== undefined) {
    var match$2 = match$1[0];
    if (match$2.tag) {
      var match$3 = Rebase.$$Array[/* get */17](match$2[0], 0);
      if (match$3 !== undefined) {
        return /* Ok */Block.variant("Ok", 0, [match$3]);
      } else {
        return /* Error */Block.variant("Error", 1, [string]);
      }
    } else {
      return /* Error */Block.variant("Error", 1, [string]);
    }
  } else {
    return /* Error */Block.variant("Error", 1, [string]);
  }
}

function parse(string) {
  return Rebase.Result[/* flatMap */6](postprocess, preprocess(string));
}

function parseFile(content) {
  return Rebase.$$Array[/* map */0]((function (line) {
                return parse(line.trim());
              }), Rebase.$$Array[/* filterMap */23]((function (x) {
                    return x;
                  }), Rebase.$$Array[/* map */0]((function (result) {
                        if (result !== undefined) {
                          var chunk = result;
                          if (chunk === "") {
                            return undefined;
                          } else {
                            return chunk;
                          }
                        }
                        
                      }), content.split((/\r\n|\n/)))));
}

var SExpression = /* module */Block.localModule([
    "preprocess",
    "toString",
    "flatten",
    "postprocess",
    "parse",
    "parseFile"
  ], [
    preprocess,
    toString,
    flatten,
    postprocess,
    parse,
    parseFile
  ]);

exports.unindent = unindent;
exports.partiteMetas = partiteMetas;
exports.partiteWarningsOrErrors = partiteWarningsOrErrors;
exports.SExpression = SExpression;
/* Util-AgdaMode Not a pure module */
