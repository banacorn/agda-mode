// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function parse(param) {
  if (param.tag) {
    var xs = param[0];
    var exit = 0;
    switch (xs.length) {
      case 4 : 
          var match = xs[0];
          if (match.tag) {
            exit = 1;
          } else {
            var match$1 = xs[1];
            if (match$1.tag) {
              exit = 1;
            } else {
              var types = xs[2];
              return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                            "start",
                            "end_",
                            "types",
                            "source"
                          ], [
                            Caml_format.caml_int_of_string(match[0]),
                            Caml_format.caml_int_of_string(match$1[0]),
                            Emacs__Parser$AgdaMode.SExpression[/* flatten */2](types),
                            undefined
                          ])]);
            }
          }
          break;
      case 5 : 
          exit = 1;
          break;
      case 6 : 
          var match$2 = xs[0];
          if (match$2.tag) {
            exit = 1;
          } else {
            var match$3 = xs[1];
            if (match$3.tag) {
              exit = 1;
            } else {
              var types$1 = xs[2];
              var match$4 = xs[5];
              if (match$4.tag) {
                var match$5 = match$4[0];
                if (match$5.length !== 3) {
                  exit = 1;
                } else {
                  var match$6 = match$5[0];
                  if (match$6.tag) {
                    exit = 1;
                  } else {
                    var match$7 = match$5[2];
                    if (match$7.tag) {
                      exit = 1;
                    } else {
                      return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                                    "start",
                                    "end_",
                                    "types",
                                    "source"
                                  ], [
                                    Caml_format.caml_int_of_string(match$2[0]),
                                    Caml_format.caml_int_of_string(match$3[0]),
                                    Emacs__Parser$AgdaMode.SExpression[/* flatten */2](types$1),
                                    /* tuple */[
                                      match$6[0],
                                      Caml_format.caml_int_of_string(match$7[0])
                                    ]
                                  ])]);
                    }
                  }
                }
              } else {
                exit = 1;
              }
            }
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* L */Block.variant("L", 1, [xs]))]);
    }
    
  } else {
    return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* A */Block.variant("A", 0, [param[0]]))]);
  }
}

var Annotation = /* module */Block.localModule(["parse"], [parse]);

var Token = 0;

exports.Token = Token;
exports.Annotation = Annotation;
/* Emacs__Parser-AgdaMode Not a pure module */
