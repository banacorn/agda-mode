// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Hole$AgdaMode = require("./Hole.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var MiniEditor$AgdaMode = require("./View/MiniEditor.bs.js");

var QueryCancelled = Caml_exceptions.create("Editors-AgdaMode.QueryCancelled");

function make(editor) {
  return /* record */Block.record([
            "focused",
            "source",
            "query",
            "connection"
          ], [
            0,
            editor,
            MiniEditor$AgdaMode.Model[/* make */0](/* () */0),
            MiniEditor$AgdaMode.Model[/* make */0](/* () */0)
          ]);
}

function get(editors) {
  var match = editors[/* focused */0];
  switch (match) {
    case 0 : 
        return editors[/* source */1];
    case 1 : 
        var match$1 = editors[/* query */2][/* ref */2];
        if (match$1 !== undefined) {
          return Caml_option.valFromOption(match$1);
        } else {
          return editors[/* source */1];
        }
    case 2 : 
        var match$2 = editors[/* connection */3][/* ref */2];
        if (match$2 !== undefined) {
          return Caml_option.valFromOption(match$2);
        } else {
          return editors[/* source */1];
        }
    
  }
}

function on(sort, editors) {
  switch (sort) {
    case 0 : 
        if (editors[/* focused */0] !== /* Source */0) {
          atom.views.getView(editors[/* source */1]).focus();
          return /* () */0;
        } else {
          return 0;
        }
    case 1 : 
        if (editors[/* focused */0] !== /* Query */1) {
          var match = editors[/* query */2][/* ref */2];
          if (match !== undefined) {
            atom.views.getView(Caml_option.valFromOption(match)).focus();
            return /* () */0;
          } else {
            return /* () */0;
          }
        } else {
          return 0;
        }
    case 2 : 
        if (editors[/* focused */0] !== /* Connection */2) {
          var match$1 = editors[/* connection */3][/* ref */2];
          if (match$1 !== undefined) {
            atom.views.getView(Caml_option.valFromOption(match$1)).focus();
            return /* () */0;
          } else {
            return /* () */0;
          }
        } else {
          return 0;
        }
    
  }
}

var Focus = /* module */Block.localModule([
    "get",
    "on"
  ], [
    get,
    on
  ]);

function inquire(editors) {
  return Curry._1(editors[/* query */2][/* telePromise */3][/* wire */0], /* () */0);
}

function answer(editors) {
  return editors[/* query */2][/* telePromise */3][/* resolve */1];
}

function reject(editors) {
  return editors[/* query */2][/* telePromise */3][/* reject */2];
}

var Query = /* module */Block.localModule([
    "inquire",
    "answer",
    "reject"
  ], [
    inquire,
    answer,
    reject
  ]);

function inquire$1(editors) {
  return Curry._1(editors[/* connection */3][/* telePromise */3][/* wire */0], /* () */0);
}

function answer$1(editors) {
  return editors[/* connection */3][/* telePromise */3][/* resolve */1];
}

function reject$1(editors) {
  return editors[/* connection */3][/* telePromise */3][/* reject */2];
}

var Connection = /* module */Block.localModule([
    "inquire",
    "answer",
    "reject"
  ], [
    inquire$1,
    answer$1,
    reject$1
  ]);

function destroy(index, self) {
  Rebase.$$Array[/* forEach */8](Hole$AgdaMode.destroy, Rebase.$$Array[/* filter */10]((function (x) {
              return Caml_obj.caml_equal(x[/* index */1], index);
            }), self));
  return Rebase.$$Array[/* filter */10]((function (x) {
                return Caml_obj.caml_notequal(x[/* index */1], index);
              }), self);
}

function destroyAll(self) {
  Rebase.$$Array[/* forEach */8](Hole$AgdaMode.destroy, self);
  return /* [] */0;
}

function find(index, self) {
  var result = Rebase.$$Array[/* filter */10]((function (x) {
          return Caml_obj.caml_equal(x[/* index */1], index);
        }), self);
  return Rebase.$$Array[/* get */17](result, 0);
}

function pointingAt(cursor, self) {
  var result = Rebase.$$Array[/* filter */10]((function (x) {
          return x[/* range */2].containsPoint(cursor, false);
        }), self);
  return Rebase.$$Array[/* get */17](result, 0);
}

var Goals = /* module */Block.localModule([
    "destroy",
    "destroyAll",
    "find",
    "pointingAt"
  ], [
    destroy,
    destroyAll,
    find,
    pointingAt
  ]);

var jsGoalsDestroy = destroy;

var jsGoalsDestroyAll = destroyAll;

var jsGoalsFind = find;

var jsGoalsPointingAt = pointingAt;

exports.QueryCancelled = QueryCancelled;
exports.make = make;
exports.Focus = Focus;
exports.Query = Query;
exports.Connection = Connection;
exports.Goals = Goals;
exports.jsGoalsDestroy = jsGoalsDestroy;
exports.jsGoalsDestroyAll = jsGoalsDestroyAll;
exports.jsGoalsFind = jsGoalsFind;
exports.jsGoalsPointingAt = jsGoalsPointingAt;
/* Hole-AgdaMode Not a pure module */
