// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Request$AgdaMode = require("./Request.bs.js");
var Response$AgdaMode = require("./Response.bs.js");

function make(cmd) {
  return {
          request: cmd,
          response: {
            rawText: [],
            sexpression: [],
            response: [],
            error: []
          }
        };
}

function serialize(i, self) {
  var fold = function (text, title) {
    return "<details><summary> " + (String(title) + (" </summary>\n<p>\n\n" + (String(text) + "\n\n</p>\n</details>\n")));
  };
  var quote = function (xs, title) {
    var xs$1 = fold(Caml_splice_call.spliceObjApply("\n", "concat", [Belt_Array.map(xs, (function (x) {
                      return "```\n" + (String(x) + "\n```\n");
                    }))]), title);
    return Caml_splice_call.spliceObjApply("\n", "concat", [Belt_Array.map(xs$1.split(/\n/), (function (__x) {
                        return Belt_Option.mapWithDefault(__x, "", (function (x) {
                                      return "    " + x;
                                    }));
                      }))]);
  };
  var request = Request$AgdaMode.toString(self.request);
  var rawText = quote(self.response.rawText, "raw text");
  var sexpression = quote(Belt_Array.map(self.response.sexpression, Parser$AgdaMode.SExpression.toString), "s-expression");
  var response = quote(Belt_Array.map(self.response.response, Response$AgdaMode.toString), "response");
  var error = quote(Belt_Array.map(self.response.error, Parser$AgdaMode.$$Error.toString), "error");
  return "" + (String(i) + (". **" + (String(request) + ("**\n" + (String(rawText) + ("\n" + (String(sexpression) + ("\n" + (String(response) + ("\n" + (String(error) + "\n")))))))))));
}

var Entry = {
  make: make,
  serialize: serialize
};

function createEntry(cmd, log) {
  var entry = make(cmd);
  log.push(entry);
  return /* () */0;
}

function updateLatestEntry(f, log) {
  var n = log.length;
  var lastEntry = Belt_Array.get(log, n - 1 | 0);
  return Belt_Option.forEach(lastEntry, f);
}

function logRawText(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry.response.rawText.push(text);
                    return /* () */0;
                  }), param);
    });
}

function logSExpression(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry.response.sexpression.push(text);
                    return /* () */0;
                  }), param);
    });
}

function logResponse(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry.response.response.push(text);
                    return /* () */0;
                  }), param);
    });
}

function logError(text) {
  return (function (param) {
      return updateLatestEntry((function (log) {
                    log.response.error.push(text);
                    return /* () */0;
                  }), param);
    });
}

function serialize$1(x) {
  return Caml_splice_call.spliceObjApply("\n", "concat", [Belt_Array.mapWithIndex(x, serialize)]);
}

exports.Entry = Entry;
exports.createEntry = createEntry;
exports.updateLatestEntry = updateLatestEntry;
exports.logRawText = logRawText;
exports.logSExpression = logSExpression;
exports.logResponse = logResponse;
exports.logError = logError;
exports.serialize = serialize$1;
/* Parser-AgdaMode Not a pure module */
