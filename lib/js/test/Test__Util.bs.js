// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Async$AgdaMode = require("../src/Util/Async.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Event$AgdaMode = require("../src/Util/Event.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var AgdaMode$AgdaMode = require("../src/AgdaMode.bs.js");
var Instance$AgdaMode = require("../src/Instance.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Webapi__Dom__Element = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__Element.js");
var Webapi__Dom__HtmlElement = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__HtmlElement.js");

var Exn = Caml_exceptions.create("Test__Util-AgdaMode.Exn");

function getGoldenFilepaths(dirname) {
  var readdir = Util.promisify((function (prim, prim$1) {
          Fs.readdir(prim, prim$1);
          return /* () */0;
        }));
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return readdir(dirname).then((function (paths) {
                return Promise.resolve(Rebase.$$Array[/* map */0](toBasename, Rebase.$$Array[/* filter */10](isInFile, paths)));
              }));
}

function getGoldenFilepathsSync(dirname) {
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return Rebase.$$Array[/* map */0](toBasename, Rebase.$$Array[/* filter */10](isInFile, Fs.readdirSync(dirname)));
}

var FileMissing = Caml_exceptions.create("Test__Util-AgdaMode.Golden.FileMissing");

function map(f, param) {
  return /* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
            param[0],
            Curry._1(f, param[1]),
            param[2]
          ]);
}

function readFile(filepath) {
  var readFile$1 = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          return /* () */0;
        }));
  return Promise.all(/* array */[
                readFile$1(filepath + ".in"),
                readFile$1(filepath + ".out")
              ]).then((function (param) {
                if (param.length !== 2) {
                  return Promise.reject([
                              FileMissing,
                              filepath
                            ]);
                } else {
                  var input = param[0];
                  var output = param[1];
                  return Promise.resolve(/* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
                                filepath,
                                input.toString(),
                                output.toString()
                              ]));
                }
              }));
}

function compare(param) {
  var expected = param[2];
  var actual = param[1];
  var erred = /* record */Caml_chrome_debugger.record(["contents"], [false]);
  var count = /* record */Caml_chrome_debugger.record(["contents"], [0]);
  Rebase.$$Array[/* forEach */8]((function (diff) {
          var match = Rebase.$$String[/* length */1](diff.value) > 100;
          var change = match ? Rebase.$$String[/* sub */9](0, 100, diff.value) + " ..." : diff.value;
          var expected$prime = Rebase.$$String[/* sub */9](Caml_primitive.caml_int_max(0, count[0] - 50 | 0), (50 + Rebase.$$String[/* length */1](diff.value) | 0) + 50 | 0, expected);
          var actual$prime = Rebase.$$String[/* sub */9](Caml_primitive.caml_int_max(0, count[0] - 50 | 0), (50 + Rebase.$$String[/* length */1](diff.value) | 0) + 50 | 0, actual);
          var message = "\n\nexpected => " + (expected$prime + ("\n\nactual   => " + (actual$prime + "\n\nchange => ")));
          if (diff.added) {
            Assert$BsMocha.fail(message + (" added " + (change + ("\n at position " + String(count[0])))));
          }
          if (diff.removed) {
            return Assert$BsMocha.fail(message + (" removed " + (change + ("\n\n at position " + String(count[0])))));
          } else {
            return 0;
          }
        }), Rebase.$$Array[/* filter */10]((function (diff) {
              if (diff.added || diff.removed) {
                if (!erred[0]) {
                  erred[0] = true;
                }
                return true;
              } else {
                if (!erred[0]) {
                  count[0] = count[0] + Rebase.$$String[/* length */1](diff.value) | 0;
                }
                return false;
              }
            }), Diff.diffWordsWithSpace(expected, actual)));
  return Promise.resolve(/* () */0);
}

var Golden = /* module */Caml_chrome_debugger.localModule([
    "getGoldenFilepaths",
    "getGoldenFilepathsSync",
    "FileMissing",
    "map",
    "readFile",
    "compare"
  ], [
    getGoldenFilepaths,
    getGoldenFilepathsSync,
    FileMissing,
    map,
    readFile,
    compare
  ]);

var partial_arg = Rebase.$$String[/* joinWith */11];

var serialize = Curry._2(Rebase.Fn[/* >> */6], Curry._2(Rebase.Fn[/* >> */6], Rebase.List[/* fromArray */12], (function (param) {
            return partial_arg("\n", param);
          })), (function (x) {
        return x + "\n";
      }));

function serializeWith(f) {
  var partial_arg = Rebase.$$Array[/* map */0];
  var partial_arg$1 = Rebase.$$String[/* joinWith */11];
  return Curry._2(Rebase.Fn[/* >> */6], Curry._2(Rebase.Fn[/* >> */6], Curry._2(Rebase.Fn[/* >> */6], (function (param) {
                        return partial_arg(f, param);
                      }), Rebase.List[/* fromArray */12]), (function (param) {
                    return partial_arg$1("\n", param);
                  })), (function (x) {
                return x + "\n";
              }));
}

function breakInput(breakpoints, input) {
  var breakpoints$prime = Rebase.$$Array[/* concat */11](breakpoints, /* array */[0]);
  return Rebase.$$Array[/* map */0]((function (param) {
                return Rebase.$$String[/* sub */9](param[0], param[1], input);
              }), Rebase.$$Array[/* mapi */27]((function (x, i) {
                    var match = Rebase.$$Array[/* get */17](breakpoints$prime, i + 1 | 0);
                    if (match !== undefined) {
                      return /* tuple */[
                              x,
                              match - x | 0
                            ];
                    } else {
                      return /* tuple */[
                              x,
                              Rebase.$$String[/* length */1](input) - x | 0
                            ];
                    }
                  }), breakpoints$prime));
}

var partial_arg$1 = Rebase.$$Array[/* filterMap */23];

var childHtmlElements = Curry._2(Rebase.Fn[/* >> */6], Curry._2(Rebase.Fn[/* >> */6], (function (prim) {
            return prim.childNodes;
          }), (function (prim) {
            return Array.prototype.slice.call(prim);
          })), (function (param) {
        return partial_arg$1(Webapi__Dom__HtmlElement.ofNode, param);
      }));

function getPanelContainersAtBottom(param) {
  return Rebase.$$Array[/* filter */10]((function (elem) {
                return elem.className === "agda-mode-panel-container";
              }), Rebase.$$Array[/* flatMap */5](childHtmlElements, Rebase.$$Array[/* map */0]((function (prim) {
                        return atom.views.getView(prim);
                      }), atom.workspace.getBottomPanels())));
}

function getPanelContainersAtPanes(param) {
  return Rebase.$$Array[/* filter */10]((function (elem) {
                return elem.className === "agda-mode-panel-container";
              }), Rebase.$$Array[/* map */0]((function (prim) {
                    return atom.views.getView(prim);
                  }), atom.workspace.getPaneItems()));
}

function getPanelContainers(param) {
  return getPanelContainersAtPanes(/* () */0).concat(getPanelContainersAtBottom(/* () */0));
}

var PanelNotFound = Caml_exceptions.create("Test__Util-AgdaMode.View.PanelNotFound");

function getPanel(instance) {
  var isTarget = function (element) {
    return element.id === "agda-mode:" + Instance$AgdaMode.getID(instance);
  };
  var partial_arg = Rebase.$$Array[/* filter */10];
  var panels = Rebase.$$Array[/* flatMap */5](Curry._2(Rebase.Fn[/* >> */6], childHtmlElements, (function (param) {
              return partial_arg(isTarget, param);
            })), getPanelContainers(/* () */0));
  var match = Rebase.$$Array[/* get */17](panels, 0);
  if (match !== undefined) {
    return Promise.resolve(Caml_option.valFromOption(match));
  } else {
    return Promise.reject(PanelNotFound);
  }
}

var ElementNotFound = Caml_exceptions.create("Test__Util-AgdaMode.View.ElementNotFound");

function querySelector(selector, elem) {
  return Rebase.$$Option[/* mapOr */18]((function (prim) {
                return Promise.resolve(prim);
              }), Promise.reject([
                  ElementNotFound,
                  "cannot find `" + (selector + "`")
                ]), Rebase.$$Option[/* flatMap */5](Webapi__Dom__Element.asHtmlElement, Caml_option.nullable_to_opt(elem.querySelector(selector))));
}

var View = /* module */Caml_chrome_debugger.localModule([
    "childHtmlElements",
    "getPanelContainersAtBottom",
    "getPanelContainersAtPanes",
    "getPanelContainers",
    "PanelNotFound",
    "getPanel",
    "ElementNotFound",
    "querySelector"
  ], [
    childHtmlElements,
    getPanelContainersAtBottom,
    getPanelContainersAtPanes,
    getPanelContainers,
    PanelNotFound,
    getPanel,
    ElementNotFound,
    querySelector
  ]);

var base = Path.join(__dirname, "../../../");

function file(path) {
  return Path.join(base, path);
}

function asset(path) {
  return Path.join(Path.join(base, "test/asset"), path);
}

var Path$1 = /* module */Caml_chrome_debugger.localModule([
    "base",
    "file",
    "asset"
  ], [
    base,
    file,
    asset
  ]);

function open_(uri) {
  return atom.workspace.open(uri);
}

var openAsset = Curry._2(Rebase.Fn[/* >> */6], asset, open_);

function close(uri) {
  var pane = atom.workspace.paneForURI(uri);
  if (pane !== undefined) {
    var p = Caml_option.valFromOption(pane);
    var item = p.itemForURI(uri);
    if (item !== undefined) {
      return p.destroyItem(Caml_option.valFromOption(item), true);
    } else {
      return Promise.resolve(false);
    }
  } else {
    return Promise.resolve(false);
  }
}

var $$File = /* module */Caml_chrome_debugger.localModule([
    "open_",
    "openAsset",
    "close"
  ], [
    open_,
    openAsset,
    close
  ]);

function activeNames(param) {
  return Rebase.$$Array[/* map */0]((function (prim) {
                return prim.name;
              }), atom.packages.getActivePackages());
}

function loadedNames(param) {
  return Rebase.$$Array[/* map */0]((function (prim) {
                return prim.name;
              }), atom.packages.getLoadedPackages());
}

function activate(param) {
  atom.packages.activatePackage("agda-mode");
  return AgdaMode$AgdaMode.activate(/* () */0);
}

function deactivate(param) {
  return atom.packages.deactivatePackage("agda-mode", false);
}

function after_each(param) {
  var destroyAllTextEditors = function (param) {
    return Promise.all(Rebase.$$Array[/* flatMap */5]((function (pane) {
                        return Rebase.$$Array[/* map */0]((function (item) {
                                      return pane.destroyItem(item, true);
                                    }), pane.getItems());
                      }), atom.workspace.getPanes())).then((function (param) {
                  return Promise.resolve(/* () */0);
                }));
  };
  var clearAllFiles = function (param) {
    return Curry._1(openAsset, "Temp.agda").then((function (editor) {
                  editor.setText("");
                  return editor.save();
                }));
  };
  return destroyAllTextEditors(/* () */0).then(clearAllFiles);
}

var Package = /* module */Caml_chrome_debugger.localModule([
    "activeNames",
    "loadedNames",
    "activate",
    "deactivate",
    "after_each"
  ], [
    activeNames,
    loadedNames,
    activate,
    deactivate,
    after_each
  ]);

function getInstance(editor) {
  return Rebase.$$Option[/* getOr */16](Promise.reject([
                  Exn,
                  "instance doesn't exist"
                ]), Rebase.$$Option[/* map */0]((function (instance) {
                    return Promise.resolve(instance);
                  }), AgdaMode$AgdaMode.Instances[/* get */1](editor)));
}

var DispatchFailure = Caml_exceptions.create("Test__Util-AgdaMode.DispatchFailure");

function dispatch($$event, instance) {
  var onDispatch = Event$AgdaMode.once(instance[/* onDispatch */10]);
  var match = atom.commands.dispatch(atom.views.getView(instance[/* editors */1][/* source */1]), $$event);
  if (match !== undefined) {
    return Caml_option.valFromOption(match).then((function (param) {
                    return onDispatch;
                  })).then((function (param) {
                  return Promise.resolve(instance);
                }));
  } else {
    return Promise.reject([
                DispatchFailure,
                $$event
              ]);
  }
}

function openAndLoad(path) {
  return Curry._1(openAsset, path).then(getInstance).then((function (param) {
                return dispatch("agda-mode:load", param);
              }));
}

function close$1(instance) {
  var onDestroy = Async$AgdaMode.toPromise(Event$AgdaMode.once(instance[/* view */2][/* onDestroy */8]));
  atom.workspace.hide(instance[/* editors */1][/* source */1]);
  return onDestroy;
}

function dispatch$1(key, instance) {
  var element = atom.views.getView(instance[/* editors */1][/* source */1]);
  var onDispatch = Event$AgdaMode.once(instance[/* onDispatch */10]);
  atom.keymaps.handleKeyboardEvent(atom.keymaps.constructor.buildKeydownEvent(key, {
            ctrl: false,
            alt: false,
            shift: false,
            cmd: false,
            which: 0,
            target: element
          }));
  return Async$AgdaMode.toPromise(onDispatch).then((function (param) {
                return Promise.resolve(instance);
              }));
}

function insert(key, instance) {
  console.log("[ IM ][ listen ]");
  var onChange = Async$AgdaMode.toPromise(Event$AgdaMode.once(instance[/* view */2][/* onInputMethodChange */13]));
  console.log("[ IM ][ before insertion ]", instance[/* editors */1][/* source */1].getText());
  instance[/* editors */1][/* source */1].insertText(key);
  return instance[/* editors */1][/* source */1].save().then((function (param) {
                console.log("[ IM ][ after insertion ]", instance[/* editors */1][/* source */1].getText());
                return onChange;
              }));
}

var Keyboard = /* module */Caml_chrome_debugger.localModule([
    "dispatch",
    "insert"
  ], [
    dispatch$1,
    insert
  ]);

function equal(message, expected, actual) {
  return Assert$BsMocha.equal(message, actual, expected);
}

var Assert = /* module */Caml_chrome_debugger.localModule(["equal"], [equal]);

exports.Exn = Exn;
exports.Golden = Golden;
exports.serialize = serialize;
exports.serializeWith = serializeWith;
exports.breakInput = breakInput;
exports.View = View;
exports.Path = Path$1;
exports.$$File = $$File;
exports.Package = Package;
exports.getInstance = getInstance;
exports.DispatchFailure = DispatchFailure;
exports.dispatch = dispatch;
exports.openAndLoad = openAndLoad;
exports.close = close$1;
exports.Keyboard = Keyboard;
exports.Assert = Assert;
/* serialize Not a pure module */
