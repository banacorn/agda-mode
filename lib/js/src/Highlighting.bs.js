// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Util$AgdaMode = require("./Util/Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");

function toString(self) {
  var match = self.source;
  var tmp;
  if (match !== undefined) {
    var match$1 = match;
    tmp = match$1[0] + (" " + String(match$1[1]));
  } else {
    tmp = "";
  }
  return "Annotation " + (String(self.start) + (" " + (String(self.end_) + (" " + (Util$AgdaMode.Pretty.list(Belt_List.fromArray(self.types)) + tmp)))));
}

function parse(param) {
  if (param.tag) {
    var xs = param[0];
    var len = xs.length;
    if (len >= 7) {
      return ;
    } else {
      switch (len) {
        case 3 :
            var match = xs[0];
            if (match.tag) {
              return ;
            } else {
              var match$1 = xs[1];
              if (match$1.tag) {
                return ;
              } else {
                var end_$prime = match$1[0];
                var types = xs[2];
                return Belt_Option.flatMap(Parser$AgdaMode.$$int(match[0]), (function (start) {
                              return Belt_Option.map(Parser$AgdaMode.$$int(end_$prime), (function (end_) {
                                            return {
                                                    start: start,
                                                    end_: end_,
                                                    types: Parser$AgdaMode.SExpression.flatten(types),
                                                    source: undefined
                                                  };
                                          }));
                            }));
              }
            }
        case 4 :
            var match$2 = xs[0];
            if (match$2.tag) {
              return ;
            } else {
              var match$3 = xs[1];
              if (match$3.tag) {
                return ;
              } else {
                var end_$prime$1 = match$3[0];
                var types$1 = xs[2];
                return Belt_Option.flatMap(Parser$AgdaMode.$$int(match$2[0]), (function (start) {
                              return Belt_Option.map(Parser$AgdaMode.$$int(end_$prime$1), (function (end_) {
                                            return {
                                                    start: start,
                                                    end_: end_,
                                                    types: Parser$AgdaMode.SExpression.flatten(types$1),
                                                    source: undefined
                                                  };
                                          }));
                            }));
              }
            }
        case 0 :
        case 1 :
        case 2 :
        case 5 :
            return ;
        case 6 :
            var match$4 = xs[0];
            if (match$4.tag) {
              return ;
            } else {
              var match$5 = xs[1];
              if (match$5.tag) {
                return ;
              } else {
                var end_$prime$2 = match$5[0];
                var types$2 = xs[2];
                var match$6 = xs[5];
                if (match$6.tag) {
                  var match$7 = match$6[0];
                  if (match$7.length !== 3) {
                    return ;
                  } else {
                    var match$8 = match$7[0];
                    if (match$8.tag) {
                      return ;
                    } else {
                      var filepath = match$8[0];
                      var match$9 = match$7[2];
                      if (match$9.tag) {
                        return ;
                      } else {
                        var index$prime = match$9[0];
                        return Belt_Option.flatMap(Parser$AgdaMode.$$int(match$4[0]), (function (start) {
                                      return Belt_Option.flatMap(Parser$AgdaMode.$$int(end_$prime$2), (function (end_) {
                                                    return Belt_Option.map(Parser$AgdaMode.$$int(index$prime), (function (index) {
                                                                  return {
                                                                          start: start,
                                                                          end_: end_,
                                                                          types: Parser$AgdaMode.SExpression.flatten(types$2),
                                                                          source: /* tuple */[
                                                                            filepath,
                                                                            index
                                                                          ]
                                                                        };
                                                                }));
                                                  }));
                                    }));
                      }
                    }
                  }
                } else {
                  return ;
                }
              }
            }
        
      }
    }
  }
  
}

function parseDirectHighlightings(tokens) {
  return Belt_Array.keepMap(Belt_Array.map(tokens.slice(2), parse), (function (x) {
                return x;
              }));
}

function parseIndirectHighlightings(tokens) {
  return Belt_Array.keepMap(Belt_Array.map(tokens.slice(1), parse), (function (x) {
                return x;
              }));
}

function shouldHighlight(annotation) {
  if (annotation.types.includes("unsolvedmeta") || annotation.types.includes("unsolvedconstraint") || annotation.types.includes("terminationproblem")) {
    return true;
  } else {
    return annotation.types.includes("coverageproblem");
  }
}

var Annotation = {
  toString: toString,
  parse: parse,
  parseDirectHighlightings: parseDirectHighlightings,
  parseIndirectHighlightings: parseIndirectHighlightings,
  shouldHighlight: shouldHighlight
};

var Token = /* alias */0;

exports.Token = Token;
exports.Annotation = Annotation;
/* Util-AgdaMode Not a pure module */
