// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("./Util.bs.js");
var Child_process = require("child_process");
var Async$AgdaMode = require("./Util/Async.bs.js");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Metadata$AgdaMode = require("./Metadata.bs.js");
var Response$AgdaMode = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toString(param) {
  switch (param.tag | 0) {
    case 0 : 
        var match = param[0];
        if (typeof match === "number") {
          return /* tuple */[
                  "Process not responding",
                  "Please restart the process"
                ];
        } else if (match.tag) {
          return /* tuple */[
                  "Auto search failed",
                  match[0]
                ];
        } else {
          return /* tuple */[
                  "Auto search failed",
                  "currently auto path searching is not supported on " + (String(match[0]) + "")
                ];
        }
    case 1 : 
        var match$1 = param[1];
        if (typeof match$1 === "number") {
          return /* tuple */[
                  "Process hanging",
                  "The program has not been responding for more than 1 sec"
                ];
        } else {
          switch (match$1.tag | 0) {
            case 0 : 
                return /* tuple */[
                        "Path malformed",
                        match$1[0]
                      ];
            case 1 : 
                return /* tuple */[
                        "Agda not found",
                        Util$AgdaMode.JsError[/* toString */0](match$1[0])
                      ];
            case 2 : 
                return /* tuple */[
                        "Error from the shell",
                        Util$AgdaMode.JsError[/* toString */0](match$1[0])
                      ];
            case 3 : 
                return /* tuple */[
                        "Error from the stderr",
                        match$1[0]
                      ];
            case 4 : 
                return /* tuple */[
                        "This is not agda",
                        match$1[0]
                      ];
            
          }
        }
    case 2 : 
        var match$2 = param[0];
        if (typeof match$2 === "number") {
          return /* tuple */[
                  "Disconnected",
                  "Connection disconnected by ourselves"
                ];
        } else if (match$2.tag) {
          return /* tuple */[
                  "Socket closed by Agda",
                  "code: " + (String(match$2[0]) + ("\nsignal: " + (String(match$2[1]) + "\nIt\'s probably because Agda\'s not happy about the arguments you fed her\n")))
                ];
        } else {
          return /* tuple */[
                  "Socket error",
                  Util$AgdaMode.JsError[/* toString */0](match$2[0])
                ];
        }
    
  }
}

var $$Error = /* module */Caml_chrome_debugger.localModule(["toString"], [toString]);

function disconnect(error, self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  self[/* process */1].kill("SIGTERM");
  Rebase.$$Array[/* forEach */8]((function (ev) {
          return Event$AgdaMode.emitError(error, ev);
        }), self[/* queue */2]);
  self[/* queue */2] = /* array */[];
  Event$AgdaMode.removeAllListeners(self[/* errorEmitter */3]);
  self[/* connected */4] = false;
  return /* () */0;
}

function autoSearch(path) {
  return Async$AgdaMode.mapError((function (e) {
                  return /* AutoSearchError */Caml_chrome_debugger.variant("AutoSearchError", 0, [e]);
                }))(Async$AgdaMode.make((function (resolve, reject) {
                    var os = Os.type();
                    var exit = 0;
                    switch (os) {
                      case "Darwin" : 
                      case "Linux" : 
                          exit = 1;
                          break;
                      case "Windows_NT" : 
                          return Curry._1(reject, /* NotSupported */Caml_chrome_debugger.variant("NotSupported", 0, ["Windows_NT"]));
                      default:
                        return Curry._1(reject, /* NotSupported */Caml_chrome_debugger.variant("NotSupported", 0, [os]));
                    }
                    if (exit === 1) {
                      var hangTimeout = setTimeout((function (param) {
                              return Curry._1(reject, /* ProcessHanging */0);
                            }), 1000);
                      Child_process.exec("which " + path, (function (error, stdout, stderr) {
                              clearTimeout(hangTimeout);
                              if (!(error == null)) {
                                Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [Rebase.$$Option[/* getOr */16]("", error.message)]));
                              }
                              var stderr$prime = stderr.toString();
                              if (!Rebase.$$String[/* isEmpty */5](stderr$prime)) {
                                Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [stderr$prime]));
                              }
                              var stdout$prime = stdout.toString();
                              if (Rebase.$$String[/* isEmpty */5](stdout$prime)) {
                                return Curry._1(reject, /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [""]));
                              } else {
                                return Curry._1(resolve, Parser$AgdaMode.filepath(stdout$prime));
                              }
                            }));
                      return /* () */0;
                    }
                    
                  })));
}

function parseAgdaOutput(parser, stringAgdaSpatOut) {
  var match = Rebase.$$String[/* startsWith */3]("Agda2>", stringAgdaSpatOut);
  var trimmedFront = match ? stringAgdaSpatOut.substring(6, Rebase.$$String[/* length */1](stringAgdaSpatOut)) : stringAgdaSpatOut;
  var chunkEnded = false;
  var trimmedBoth;
  if (Rebase.$$String[/* endsWith */4]("Agda2>", trimmedFront)) {
    chunkEnded = true;
    trimmedBoth = trimmedFront.substring(0, Rebase.$$String[/* length */1](trimmedFront) - 6 | 0);
  } else if (Rebase.$$String[/* endsWith */4]("Agda2> ", trimmedFront)) {
    chunkEnded = true;
    trimmedBoth = trimmedFront.substring(0, Rebase.$$String[/* length */1](trimmedFront) - 7 | 0);
  } else {
    trimmedBoth = trimmedFront;
  }
  var partial_arg = parser[0];
  var partial_arg$1 = Parser$AgdaMode.Incr[/* feed */2];
  Rebase.$$Array[/* forEach */8]((function (param) {
          return partial_arg$1(partial_arg, param);
        }), Curry._1(Parser$AgdaMode.splitAndTrim, trimmedBoth));
  if (chunkEnded) {
    return Parser$AgdaMode.Incr[/* finish */3](parser[0]);
  } else {
    return 0;
  }
}

function validateAndMake(pathAndParams) {
  var match = Parser$AgdaMode.commandLine(pathAndParams);
  var args = match[1];
  var path = match[0];
  var parseError = function (error) {
    if (error == null) {
      return undefined;
    } else {
      var message = Rebase.$$Option[/* getOr */16]("", error.message);
      if ((/No such file or directory/).test(message) || (/command not found/).test(message)) {
        return /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [error]);
      } else {
        return /* ShellError */Caml_chrome_debugger.variant("ShellError", 2, [error]);
      }
    }
  };
  var parseVersion = function (stdout) {
    var message = stdout.toString();
    var match = message.match((/Agda version (.*)/));
    if (match !== null) {
      var match$1 = Rebase.$$Array[/* get */17](match, 1);
      if (match$1 !== undefined) {
        var match$2 = (/--interaction-json/).test(message);
        return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* record */Caml_chrome_debugger.record([
                      "path",
                      "args",
                      "version",
                      "protocol",
                      "entries"
                    ], [
                      path,
                      args,
                      match$1,
                      match$2 ? /* EmacsAndJSON */1 : /* EmacsOnly */0,
                      []
                    ])]);
      } else {
        return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* IsNotAgda */Caml_chrome_debugger.variant("IsNotAgda", 4, [message])]);
      }
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* IsNotAgda */Caml_chrome_debugger.variant("IsNotAgda", 4, [message])]);
    }
  };
  return Async$AgdaMode.mapError((function (e) {
                  return /* ValidationError */Caml_chrome_debugger.variant("ValidationError", 1, [
                            pathAndParams,
                            e
                          ]);
                }))(Async$AgdaMode.make((function (resolve, reject) {
                    if (Rebase.$$String[/* isEmpty */5](path)) {
                      Curry._1(reject, /* PathMalformed */Caml_chrome_debugger.variant("PathMalformed", 0, ["the path must not be empty"]));
                    }
                    var hangTimeout = setTimeout((function (param) {
                            return Curry._1(reject, /* ProcessHanging */0);
                          }), 1000);
                    Child_process.exec(path, (function (error, stdout, stderr) {
                            clearTimeout(hangTimeout);
                            var match = parseError(error);
                            if (match !== undefined) {
                              Curry._1(reject, match);
                            }
                            var stderr$prime = stderr.toString();
                            if (!Rebase.$$String[/* isEmpty */5](stderr$prime)) {
                              Curry._1(reject, /* ProcessError */Caml_chrome_debugger.variant("ProcessError", 3, [stderr$prime]));
                            }
                            var match$1 = parseVersion(stdout);
                            if (match$1.tag) {
                              return Curry._1(reject, match$1[0]);
                            } else {
                              return Curry._1(resolve, match$1[0]);
                            }
                          }));
                    return /* () */0;
                  })));
}

function connect(metadata) {
  return Async$AgdaMode.mapError((function (e) {
                  return /* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [e]);
                }))(Async$AgdaMode.make((function (resolve, reject) {
                    var args = Rebase.$$Array[/* concat */11](metadata[/* args */1], /* array */["--interaction"]);
                    var $$process = Child_process.spawn(metadata[/* path */0], args, {
                          shell: true
                        });
                    var connection = /* record */Caml_chrome_debugger.record([
                        "metadata",
                        "process",
                        "queue",
                        "errorEmitter",
                        "connected",
                        "resetLogOnLoad"
                      ], [
                        metadata,
                        $$process,
                        [],
                        Event$AgdaMode.make(/* () */0),
                        true,
                        true
                      ]);
                    $$process.on("error", (function (exn) {
                              disconnect(/* ShellError */Caml_chrome_debugger.variant("ShellError", 0, [exn]), connection);
                              return Curry._1(reject, /* ShellError */Caml_chrome_debugger.variant("ShellError", 0, [exn]));
                            })).on("close", (function (code, signal) {
                            disconnect(/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 1, [
                                    code,
                                    signal
                                  ]), connection);
                            return Curry._1(reject, /* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 1, [
                                          code,
                                          signal
                                        ]));
                          }));
                    $$process.stdout.once("data", (function (param) {
                            return Curry._1(resolve, connection);
                          }));
                    return /* () */0;
                  })));
}

function wire(self) {
  var partial_arg = Rebase.Result[/* map */0];
  var logSExpression = Curry._1(Parser$AgdaMode.Incr[/* Event */0][/* map */1], (function (param) {
          return partial_arg((function (expr) {
                        Metadata$AgdaMode.logSExpression(expr)(self[/* metadata */0]);
                        return expr;
                      }), param);
        }));
  var partial_arg$1 = Rebase.Result[/* flatMap */6];
  var toResponse = Curry._1(Parser$AgdaMode.Incr[/* Event */0][/* map */1], (function (param) {
          return partial_arg$1(Response$AgdaMode.parse, param);
        }));
  var partial_arg$2 = Rebase.Result[/* map */0];
  var logResponse = Curry._1(Parser$AgdaMode.Incr[/* Event */0][/* map */1], (function (param) {
          return partial_arg$2((function (expr) {
                        Metadata$AgdaMode.logResponse(expr)(self[/* metadata */0]);
                        return expr;
                      }), param);
        }));
  var parser = Parser$AgdaMode.SExpression[/* makeIncr */5]((function (x) {
          var res = Curry._1(logResponse, Curry._1(toResponse, Curry._1(logSExpression, x)));
          var match = Rebase.$$Array[/* get */17](self[/* queue */2], 0);
          if (match !== undefined) {
            Event$AgdaMode.emitOk(res, match);
            if (res) {
              return /* () */0;
            } else {
              return Rebase.$$Option[/* forEach */8](Event$AgdaMode.destroy, Caml_option.undefined_to_opt(self[/* queue */2].pop()));
            }
          } else if (res) {
            var match$1 = res[0];
            if (match$1.tag) {
              return /* () */0;
            } else {
              return Event$AgdaMode.emitOk(match$1[0], self[/* errorEmitter */3]);
            }
          } else {
            return /* () */0;
          }
        }));
  var onData = function (chunk) {
    var rawText = chunk.toString();
    Metadata$AgdaMode.logRawText(rawText)(self[/* metadata */0]);
    return parseAgdaOutput(parser, rawText);
  };
  self[/* process */1].stdout.on("data", onData);
  return self;
}

function send(request, self) {
  var reqEvent = Event$AgdaMode.make(/* () */0);
  self[/* queue */2].push(reqEvent);
  self[/* process */1].stdin.write(Buffer.from(request + "\n"));
  return reqEvent;
}

function resetLog(self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  return /* () */0;
}

exports.$$Error = $$Error;
exports.disconnect = disconnect;
exports.autoSearch = autoSearch;
exports.parseAgdaOutput = parseAgdaOutput;
exports.validateAndMake = validateAndMake;
exports.connect = connect;
exports.wire = wire;
exports.send = send;
exports.resetLog = resetLog;
/* os Not a pure module */
