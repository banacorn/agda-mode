// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Translator$AgdaMode = require("./Translator.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function init(string) {
  return string.substring(0, Rebase.$$String[/* length */1](string) - 1 | 0);
}

function isEmpty(self) {
  if (self[/* symbol */0] === undefined) {
    return Rebase.$$String[/* isEmpty */5](self[/* tail */1]);
  } else {
    return false;
  }
}

function toSequence(self) {
  var match = self[/* symbol */0];
  if (match !== undefined) {
    return match[1] + self[/* tail */1];
  } else {
    return self[/* tail */1];
  }
}

function toSurface(self) {
  var match = self[/* symbol */0];
  if (match !== undefined) {
    return match[0] + self[/* tail */1];
  } else {
    return self[/* tail */1];
  }
}

function toString(self) {
  return "\"" + (toSurface(self) + ("\"[" + (toSequence(self) + "]")));
}

function next(self, reality) {
  var surface = toSurface(self);
  var sequence = toSequence(self);
  if (reality === surface) {
    if (Translator$AgdaMode.translate(sequence)[/* further */1] && reality !== "\\") {
      return /* Noop */0;
    } else {
      return /* Complete */1;
    }
  } else if (init(reality) === surface) {
    var insertedChar = reality.substr(-1);
    var sequence$prime = sequence + insertedChar;
    var translation = Translator$AgdaMode.translate(sequence$prime);
    var match = translation[/* symbol */0];
    if (match !== undefined) {
      var symbol = match;
      if (insertedChar === symbol && insertedChar === "\\") {
        return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [0]);
      } else {
        return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 2, [/* record */Caml_chrome_debugger.record([
                      "symbol",
                      "tail"
                    ], [
                      /* tuple */[
                        symbol,
                        sequence$prime
                      ],
                      ""
                    ])]);
      }
    } else if (translation[/* further */1]) {
      return /* Insert */Caml_chrome_debugger.variant("Insert", 0, [/* record */Caml_chrome_debugger.record([
                    "symbol",
                    "tail"
                  ], [
                    self[/* symbol */0],
                    self[/* tail */1] + insertedChar
                  ])]);
    } else {
      return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [1]);
    }
  } else if (reality === init(surface) || reality === init(sequence)) {
    if (Rebase.$$String[/* isEmpty */5](reality)) {
      if (Rebase.$$Option[/* isSome */13](self[/* symbol */0])) {
        return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 2, [/* record */Caml_chrome_debugger.record([
                      "symbol",
                      "tail"
                    ], [
                      undefined,
                      init(sequence)
                    ])]);
      } else {
        return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [2]);
      }
    } else {
      return /* Backspace */Caml_chrome_debugger.variant("Backspace", 1, [/* record */Caml_chrome_debugger.record([
                    "symbol",
                    "tail"
                  ], [
                    self[/* symbol */0],
                    init(self[/* tail */1])
                  ])]);
    }
  } else {
    return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [3]);
  }
}

var initial = /* record */Caml_chrome_debugger.record([
    "symbol",
    "tail"
  ], [
    undefined,
    ""
  ]);

exports.init = init;
exports.initial = initial;
exports.isEmpty = isEmpty;
exports.toSequence = toSequence;
exports.toSurface = toSurface;
exports.toString = toString;
exports.next = next;
/* Translator-AgdaMode Not a pure module */
