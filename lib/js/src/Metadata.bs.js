// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Util$AgdaMode = require("./Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Command$AgdaMode = require("./Command.bs.js");
var Response$AgdaMode = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toString(param) {
  if (param) {
    return "Emacs / JSON";
  } else {
    return "Emacs";
  }
}

var Protocol = {
  toString: toString
};

function serialize(self, i) {
  var fold = function (title, text) {
    return "<details><summary> " + (String(title) + (" </summary>\n<p>\n\n" + (String(text) + "\n\n</p>\n</details>\n")));
  };
  var quote = function (title, xs) {
    var xs$1 = fold(title, Rebase.$$String.joinWith("\n", Rebase.List.fromArray(Rebase.$$Array.map((function (x) {
                        return "```\n" + (String(x) + "\n```\n");
                      }), xs))));
    var partial_arg = Rebase.$$Option.mapOr;
    return Rebase.$$String.joinWith("\n", Rebase.List.fromArray(Rebase.$$Array.map((function (param) {
                          return partial_arg((function (x) {
                                        return "    " + x;
                                      }), "", param);
                        }), xs$1.split((/\n/)))));
  };
  var request = Command$AgdaMode.Remote.toString(self[/* request */0]);
  var rawText = quote("raw text", self[/* response */1][/* rawText */0]);
  var sexpression = quote("s-expression", Rebase.$$Array.map(Parser$AgdaMode.SExpression.toString, self[/* response */1][/* sexpression */1]));
  var response = quote("response", Rebase.$$Array.map(Response$AgdaMode.toString, self[/* response */1][/* response */2]));
  var error = quote("error", Rebase.$$Array.map(Parser$AgdaMode.$$Error.toString, self[/* response */1][/* error */3]));
  return "" + (String(i) + (". **" + (String(request) + ("**\n" + (String(rawText) + ("\n" + (String(sexpression) + ("\n" + (String(response) + ("\n" + (String(error) + "\n")))))))))));
}

var Entry = {
  serialize: serialize
};

var empty = /* array */[];

function createEntry(cmd, log) {
  var entry_001 = /* response : record */Caml_chrome_debugger.record([
      "rawText",
      "sexpression",
      "response",
      "error"
    ], [
      [],
      [],
      [],
      []
    ]);
  var entry = /* record */Caml_chrome_debugger.record([
      "request",
      "response"
    ], [
      cmd,
      entry_001
    ]);
  log.push(entry);
  return /* () */0;
}

function updateLatestEntry(f, log) {
  var n = Rebase.$$Array.length(log);
  var lastEntry = Rebase.$$Array.get(log, n - 1 | 0);
  return Rebase.$$Option.forEach(f, lastEntry);
}

function logRawText(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry[/* response */1][/* rawText */0].push(text);
                    return /* () */0;
                  }), param);
    });
}

function logSExpression(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry[/* response */1][/* sexpression */1].push(text);
                    return /* () */0;
                  }), param);
    });
}

function logResponse(text) {
  return (function (param) {
      return updateLatestEntry((function (entry) {
                    entry[/* response */1][/* response */2].push(text);
                    return /* () */0;
                  }), param);
    });
}

function logError(text) {
  return (function (param) {
      return updateLatestEntry((function (log) {
                    log[/* response */1][/* error */3].push(text);
                    return /* () */0;
                  }), param);
    });
}

var partial_arg = Rebase.$$Array.mapi;

var partial_arg$1 = Rebase.$$String.joinWith;

var serialize$1 = Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, (function (param) {
            return partial_arg(serialize, param);
          }), Rebase.List.fromArray), (function (param) {
        return partial_arg$1("\n", param);
      }));

var Log = {
  Entry: Entry,
  empty: empty,
  createEntry: createEntry,
  updateLatestEntry: updateLatestEntry,
  logRawText: logRawText,
  logSExpression: logSExpression,
  logResponse: logResponse,
  logError: logError,
  serialize: serialize$1
};

function createLogEntry(cmd, metadata) {
  return createEntry(cmd, metadata[/* entries */4]);
}

function updateLatestEntry$1(f, self) {
  return updateLatestEntry(f, self[/* entries */4]);
}

function logRawText$1(text, self) {
  return logRawText(text)(self[/* entries */4]);
}

function logSExpression$1(text, self) {
  return logSExpression(text)(self[/* entries */4]);
}

function logResponse$1(text, self) {
  return logResponse(text)(self[/* entries */4]);
}

function logError$1(text, self) {
  return logError(text)(self[/* entries */4]);
}

function serialize$2(self) {
  var path = "* path: " + self[/* path */0];
  var args = "* args: " + Util$AgdaMode.Pretty.array(self[/* args */1]);
  var version = "* version: " + self[/* version */2];
  var protocol = "* protocol: " + (
    self[/* protocol */3] ? "Emacs / JSON" : "Emacs"
  );
  var os = "* platform: " + Os.type();
  var entries = Curry._1(serialize$1, self[/* entries */4]);
  return "## Parse Log\n" + (String(path) + ("\n" + (String(args) + ("\n" + (String(version) + ("\n" + (String(protocol) + ("\n" + (String(os) + ("\n" + (String(entries) + "\n  ")))))))))));
}

function dump(self) {
  var text = serialize$2(self);
  var itemOptions = {
    initialLine: 0,
    initialColumn: 0,
    split: "left",
    activatePane: true,
    activateItem: true,
    pending: false,
    searchAllPanes: true,
    location: undefined
  };
  $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(atom.workspace.open("agda-mode://log.md", itemOptions))), (function (param) {
          if (param.tag) {
            return /* () */0;
          } else {
            param[0].insertText(text);
            return /* () */0;
          }
        }));
  return /* () */0;
}

exports.Protocol = Protocol;
exports.Log = Log;
exports.createLogEntry = createLogEntry;
exports.updateLatestEntry = updateLatestEntry$1;
exports.logRawText = logRawText$1;
exports.logSExpression = logSExpression$1;
exports.logResponse = logResponse$1;
exports.logError = logError$1;
exports.serialize = serialize$2;
exports.dump = dump;
/* serialize Not a pure module */
