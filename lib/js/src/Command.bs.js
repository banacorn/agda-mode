// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Goal$AgdaMode = require("./Goal.bs.js");
var Util$AgdaMode = require("./Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");

function of_string(param) {
  switch (param) {
    case 0 : 
        return "Simplified";
    case 1 : 
        return "Instantiated";
    case 2 : 
        return "Normalised";
    
  }
}

var Normalization = /* module */Block.localModule(["of_string"], [of_string]);

function of_string$1(param) {
  switch (param) {
    case 0 : 
        return "DefaultCompute";
    case 1 : 
        return "IgnoreAbstract";
    case 2 : 
        return "UseShowInstance";
    
  }
}

function ignoreAbstract(param) {
  return param !== 0;
}

var ComputeMode = /* module */Block.localModule([
    "of_string",
    "ignoreAbstract"
  ], [
    of_string$1,
    ignoreAbstract
  ]);

function parse(param) {
  switch (param) {
    case "abort" : 
        return /* Abort */3;
    case "auto" : 
        return /* Auto */15;
    case "case" : 
        return /* Case */16;
    case "compile" : 
        return /* Compile */4;
    case "compute-normal-form[DefaultCompute]" : 
        return /* ComputeNormalForm */Block.variant("ComputeNormalForm", 3, [/* DefaultCompute */0]);
    case "compute-normal-form[IgnoreAbstract]" : 
        return /* ComputeNormalForm */Block.variant("ComputeNormalForm", 3, [/* IgnoreAbstract */1]);
    case "compute-normal-form[UseShowInstance]" : 
        return /* ComputeNormalForm */Block.variant("ComputeNormalForm", 3, [/* UseShowInstance */2]);
    case "context[Instantiated]" : 
        return /* Context */Block.variant("Context", 5, [/* Instantiated */1]);
    case "context[Normalised]" : 
        return /* Context */Block.variant("Context", 5, [/* Normalised */2]);
    case "context[Simplified]" : 
        return /* Context */Block.variant("Context", 5, [/* Simplified */0]);
    case "deactivate-input-symbol" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* Abort */7]);
    case "give" : 
        return /* Give */13;
    case "go-to-definition" : 
        return /* GotoDefinition */18;
    case "goal-type-and-context[Instantiated]" : 
        return /* GoalTypeAndContext */Block.variant("GoalTypeAndContext", 6, [/* Instantiated */1]);
    case "goal-type-and-context[Normalised]" : 
        return /* GoalTypeAndContext */Block.variant("GoalTypeAndContext", 6, [/* Normalised */2]);
    case "goal-type-and-context[Simplified]" : 
        return /* GoalTypeAndContext */Block.variant("GoalTypeAndContext", 6, [/* Simplified */0]);
    case "goal-type-and-inferred-type[Instantiated]" : 
        return /* GoalTypeAndInferredType */Block.variant("GoalTypeAndInferredType", 7, [/* Instantiated */1]);
    case "goal-type-and-inferred-type[Normalised]" : 
        return /* GoalTypeAndInferredType */Block.variant("GoalTypeAndInferredType", 7, [/* Normalised */2]);
    case "goal-type-and-inferred-type[Simplified]" : 
        return /* GoalTypeAndInferredType */Block.variant("GoalTypeAndInferredType", 7, [/* Simplified */0]);
    case "goal-type[Instantiated]" : 
        return /* GoalType */Block.variant("GoalType", 4, [/* Instantiated */1]);
    case "goal-type[Normalised]" : 
        return /* GoalType */Block.variant("GoalType", 4, [/* Normalised */2]);
    case "goal-type[Simplified]" : 
        return /* GoalType */Block.variant("GoalType", 4, [/* Simplified */0]);
    case "infer-type[Instantiated]" : 
        return /* InferType */Block.variant("InferType", 1, [/* Instantiated */1]);
    case "infer-type[Normalised]" : 
        return /* InferType */Block.variant("InferType", 1, [/* Normalised */2]);
    case "infer-type[Simplified]" : 
        return /* InferType */Block.variant("InferType", 1, [/* Simplified */0]);
    case "input-symbol" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* Ordinary */0]);
    case "input-symbol-back-quote" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* BackQuote */6]);
    case "input-symbol-bracket" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* Bracket */2]);
    case "input-symbol-curly-bracket" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* CurlyBracket */1]);
    case "input-symbol-double-quote" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* DoubleQuote */4]);
    case "input-symbol-parenthesis" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* Parenthesis */3]);
    case "input-symbol-single-quote" : 
        return /* InputSymbol */Block.variant("InputSymbol", 8, [/* SingleQuote */5]);
    case "load" : 
        return /* Load */0;
    case "module-contents[Instantiated]" : 
        return /* ModuleContents */Block.variant("ModuleContents", 2, [/* Instantiated */1]);
    case "module-contents[Normalised]" : 
        return /* ModuleContents */Block.variant("ModuleContents", 2, [/* Normalised */2]);
    case "module-contents[Simplified]" : 
        return /* ModuleContents */Block.variant("ModuleContents", 2, [/* Simplified */0]);
    case "next-goal" : 
        return /* NextGoal */9;
    case "previous-goal" : 
        return /* PreviousGoal */10;
    case "query-symbol" : 
        return /* QuerySymbol */17;
    case "quit" : 
        return /* Quit */1;
    case "refine" : 
        return /* Refine */14;
    case "restart" : 
        return /* Restart */2;
    case "search-about[Instantiated]" : 
        return /* SearchAbout */Block.variant("SearchAbout", 0, [/* Instantiated */1]);
    case "search-about[Normalised]" : 
        return /* SearchAbout */Block.variant("SearchAbout", 0, [/* Normalised */2]);
    case "search-about[Simplified]" : 
        return /* SearchAbout */Block.variant("SearchAbout", 0, [/* Simplified */0]);
    case "show-constraints" : 
        return /* ShowConstraints */7;
    case "show-goals" : 
        return /* ShowGoals */8;
    case "solve-constraints" : 
        return /* SolveConstraints */6;
    case "toggle-display-of-implicit-arguments" : 
        return /* ToggleDisplayOfImplicitArguments */5;
    case "toggle-docking" : 
        return /* ToggleDocking */11;
    case "why-in-scope" : 
        return /* WhyInScope */12;
    default:
      return /* Load */0;
  }
}

var Primitive = /* module */Block.localModule(["parse"], [parse]);

function serialize(self) {
  var command = self[/* command */2];
  var filepath = self[/* filepath */1];
  var version = self[/* version */0];
  var path = atom.config.get("agda-mode.libraryPath");
  path.unshift(".");
  var libraryPath = Rebase.$$String[/* joinWith */11](", ", Rebase.List[/* fromArray */12](Rebase.$$Array[/* map */0]((function (x) {
                  return "\"" + (Parser$AgdaMode.filepath(x) + "\"");
                }), path)));
  var match = atom.config.get("agda-mode.highlightingMethod");
  var highlightingMethod = match === "Direct" ? "Direct" : "Indirect";
  var commonPart = function (param) {
    if (param) {
      return "IOTCM \"" + (String(filepath) + ("\" NonInteractive " + (String(highlightingMethod) + " ")));
    } else {
      return "IOTCM \"" + (String(filepath) + ("\" None " + (String(highlightingMethod) + " ")));
    }
  };
  var buildRange = function (goal) {
    if (Util$AgdaMode.Version[/* gte */1](version, "2.5.1")) {
      return Goal$AgdaMode.buildHaskellRange(false, filepath, goal);
    } else {
      return Goal$AgdaMode.buildHaskellRange(true, filepath, goal);
    }
  };
  if (typeof command === "number") {
    switch (command) {
      case 0 : 
          if (Util$AgdaMode.Version[/* gte */1](version, "2.5.0")) {
            return commonPart(/* NonInteractive */1) + ("( Cmd_load \"" + (String(filepath) + "\" [] )"));
          } else {
            return commonPart(/* NonInteractive */1) + ("( Cmd_load \"" + (String(filepath) + ("\" [" + (String(libraryPath) + "] )"))));
          }
      case 1 : 
          return commonPart(/* NonInteractive */1) + "( Cmd_abort )";
      case 2 : 
          var backend = atom.config.get("agda-mode.backend");
          if (Util$AgdaMode.Version[/* gte */1](version, "2.5.0")) {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compile " + (String(backend) + (" \"" + (String(filepath) + "\" [] )"))));
          } else {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compile " + (String(backend) + (" \"" + (String(filepath) + ("\" [" + (String(libraryPath) + "] )"))))));
          }
      case 3 : 
          return commonPart(/* NonInteractive */1) + "( ToggleImplicitArgs )";
      case 4 : 
          return commonPart(/* NonInteractive */1) + "( Cmd_solveAll Instantiated )";
      case 5 : 
          return commonPart(/* NonInteractive */1) + "( Cmd_constraints )";
      case 6 : 
          return commonPart(/* NonInteractive */1) + "( Cmd_metas )";
      
    }
  } else {
    switch (command.tag | 0) {
      case 0 : 
          var content = Parser$AgdaMode.userInput(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_why_in_scope " + (String(command[1]) + (" noRange \"" + (String(content) + "\" )"))));
      case 1 : 
          var content$1 = Parser$AgdaMode.userInput(command[0]);
          return commonPart(/* None */0) + ("( Cmd_why_in_scope_toplevel \"" + (String(content$1) + "\" )"));
      case 2 : 
          var normalization$prime = of_string(command[0]);
          var content$2 = Parser$AgdaMode.userInput(command[1]);
          return commonPart(/* None */0) + ("( Cmd_search_about_toplevel " + (String(normalization$prime) + ("  \"" + (String(content$2) + "\" )"))));
      case 3 : 
          var normalization$prime$1 = of_string(command[0]);
          var content$3 = Parser$AgdaMode.userInput(command[1]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_infer " + (String(normalization$prime$1) + (" " + (String(command[2]) + (" noRange \"" + (String(content$3) + "\" )"))))));
      case 4 : 
          var normalization$prime$2 = of_string(command[0]);
          var content$4 = Parser$AgdaMode.userInput(command[1]);
          return commonPart(/* None */0) + ("( Cmd_infer_toplevel " + (String(normalization$prime$2) + (" \"" + (String(content$4) + "\" )"))));
      case 5 : 
          var normalization$prime$3 = of_string(command[0]);
          var content$5 = Parser$AgdaMode.userInput(command[1]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_show_module_contents " + (String(normalization$prime$3) + (" " + (String(command[2]) + (" noRange \"" + (String(content$5) + "\" )"))))));
      case 6 : 
          var normalization$prime$4 = of_string(command[0]);
          var content$6 = Parser$AgdaMode.userInput(command[1]);
          return commonPart(/* None */0) + ("( Cmd_show_module_contents_toplevel " + (String(normalization$prime$4) + (" \"" + (String(content$6) + "\" )"))));
      case 7 : 
          var index = command[2];
          var computeMode = command[0];
          var computeMode$prime = of_string$1(computeMode);
          var ignoreAbstract$1 = ignoreAbstract(computeMode);
          var content$7 = Parser$AgdaMode.userInput(command[1]);
          if (Util$AgdaMode.Version[/* gte */1](version, "2.5.2")) {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compute " + (String(computeMode$prime) + (" " + (String(index) + (" noRange \"" + (String(content$7) + "\" )"))))));
          } else {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compute " + (String(ignoreAbstract$1) + (" " + (String(index) + (" noRange \"" + (String(content$7) + "\" )"))))));
          }
      case 8 : 
          var computeMode$1 = command[0];
          var computeMode$prime$1 = of_string$1(computeMode$1);
          var ignoreAbstract$2 = ignoreAbstract(computeMode$1);
          var content$8 = Parser$AgdaMode.userInput(command[1]);
          if (Util$AgdaMode.Version[/* gte */1](version, "2.5.2")) {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compute_toplevel " + (String(computeMode$prime$1) + (" \"" + (String(content$8) + "\" )"))));
          } else {
            return commonPart(/* NonInteractive */1) + ("( Cmd_compute_toplevel " + (String(ignoreAbstract$2) + (" \"" + (String(content$8) + "\" )"))));
          }
      case 9 : 
          var index$1 = command[1];
          var goal = command[0];
          var content$9 = Goal$AgdaMode.getContent(goal);
          var range = buildRange(goal);
          if (Util$AgdaMode.Version[/* gte */1](version, "2.5.3")) {
            return commonPart(/* NonInteractive */1) + ("( Cmd_give WithoutForce " + (String(index$1) + (" " + (String(range) + (" \"" + (String(content$9) + "\" )"))))));
          } else {
            return commonPart(/* NonInteractive */1) + ("( Cmd_give " + (String(index$1) + (" " + (String(range) + (" \"" + (String(content$9) + "\" )"))))));
          }
      case 10 : 
          var goal$1 = command[0];
          var content$10 = Goal$AgdaMode.getContent(goal$1);
          var range$1 = buildRange(goal$1);
          return commonPart(/* NonInteractive */1) + ("( Cmd_refine_or_intro False " + (String(command[1]) + (" " + (String(range$1) + (" \"" + (String(content$10) + "\" )"))))));
      case 11 : 
          var goal$2 = command[0];
          var content$11 = Goal$AgdaMode.getContent(goal$2);
          var range$2 = buildRange(goal$2);
          return commonPart(/* NonInteractive */1) + ("( Cmd_auto " + (String(command[1]) + (" " + (String(range$2) + (" \"" + (String(content$11) + "\" )"))))));
      case 12 : 
          var goal$3 = command[0];
          var content$12 = Goal$AgdaMode.getContent(goal$3);
          var range$3 = buildRange(goal$3);
          return commonPart(/* NonInteractive */1) + ("( Cmd_make_case " + (String(command[1]) + (" " + (String(range$3) + (" \"" + (String(content$12) + "\" )"))))));
      case 13 : 
          var normalization$prime$5 = of_string(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_goal_type " + (String(normalization$prime$5) + (" " + (String(command[1]) + " noRange \"\" )"))));
      case 14 : 
          var normalization$prime$6 = of_string(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_context " + (String(normalization$prime$6) + (" " + (String(command[1]) + " noRange \"\" )"))));
      case 15 : 
          var normalization$prime$7 = of_string(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_goal_type_context " + (String(normalization$prime$7) + (" " + (String(command[1]) + " noRange \"\" )"))));
      case 16 : 
          var content$13 = Goal$AgdaMode.getContent(command[1]);
          var normalization$prime$8 = of_string(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_goal_type_context_infer " + (String(normalization$prime$8) + (" " + (String(command[2]) + (" noRange \"" + (String(content$13) + "\" )"))))));
      case 17 : 
          var content$14 = Parser$AgdaMode.userInput(command[0]);
          return commonPart(/* NonInteractive */1) + ("( Cmd_why_in_scope " + (String(command[1]) + (" noRange \"" + (String(content$14) + "\" )"))));
      case 18 : 
          var content$15 = Parser$AgdaMode.userInput(command[0]);
          return commonPart(/* None */0) + ("( Cmd_why_in_scope_toplevel \"" + (String(content$15) + "\" )"));
      
    }
  }
}

var Remote = /* module */Block.localModule(["serialize"], [serialize]);

var names = /* array */[
  "load",
  "quit",
  "restart",
  "abort",
  "compile",
  "toggle-display-of-implicit-arguments",
  "solve-constraints",
  "show-constraints",
  "show-goals",
  "next-goal",
  "previous-goal",
  "toggle-docking",
  "why-in-scope",
  "search-about[Simplified]",
  "search-about[Instantiated]",
  "search-about[Normalised]",
  "infer-type[Simplified]",
  "infer-type[Instantiated]",
  "infer-type[Normalised]",
  "module-contents[Simplified]",
  "module-contents[Instantiated]",
  "module-contents[Normalised]",
  "compute-normal-form[DefaultCompute]",
  "compute-normal-form[IgnoreAbstract]",
  "compute-normal-form[UseShowInstance]",
  "give",
  "refine",
  "auto",
  "case",
  "goal-type[Simplified]",
  "goal-type[Instantiated]",
  "goal-type[Normalised]",
  "context[Simplified]",
  "context[Instantiated]",
  "context[Normalised]",
  "goal-type-and-context[Simplified]",
  "goal-type-and-context[Instantiated]",
  "goal-type-and-context[Normalised]",
  "goal-type-and-inferred-type[Simplified]",
  "goal-type-and-inferred-type[Instantiated]",
  "goal-type-and-inferred-type[Normalised]",
  "input-symbol",
  "input-symbol-curly-bracket",
  "input-symbol-bracket",
  "input-symbol-parenthesis",
  "input-symbol-double-quote",
  "input-symbol-single-quote",
  "input-symbol-back-quote",
  "deactivate-input-symbol",
  "query-symbol",
  "go-to-definition"
];

exports.Normalization = Normalization;
exports.ComputeMode = ComputeMode;
exports.Primitive = Primitive;
exports.Remote = Remote;
exports.names = names;
/* Goal-AgdaMode Not a pure module */
