// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Child_process = require("child_process");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Metadata$AgdaMode = require("./Metadata.bs.js");
var Response$AgdaMode = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function disconnect(error, self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  self[/* process */1].kill("SIGTERM");
  Rebase.$$Array.forEach((function (ev) {
          return Curry._1(ev[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [error]));
        }), self[/* queue */2]);
  self[/* queue */2] = /* array */[];
  Curry._1(self[/* errorEmitter */3][/* destroy */4], /* () */0);
  self[/* connected */4] = false;
  return /* () */0;
}

function autoSearch(name) {
  var match = $$Promise.pending(/* () */0);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */Caml_chrome_debugger.variant("ProcessHanging", 0, [name])]));
        }), 1000);
  var os = Os.type();
  var commandName;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["which"]);
        break;
    case "Windows_NT" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["where.exe"]);
        break;
    default:
      commandName = /* Error */Caml_chrome_debugger.variant("Error", 1, [os]);
  }
  if (commandName.tag) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotSupported */Caml_chrome_debugger.variant("NotSupported", 1, [commandName[0]])]));
  } else {
    Child_process.exec(commandName[0] + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            if (!(error == null)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          Rebase.$$Option.getOr("", error.message)
                        ])]));
            }
            var stderr$prime = stderr.toString();
            if (!Rebase.$$String.isEmpty(stderr$prime)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          stderr$prime
                        ])]));
            }
            var stdout$prime = stdout.toString();
            if (Rebase.$$String.isEmpty(stdout$prime)) {
              return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                name,
                                ""
                              ])]));
            } else {
              return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [stdout$prime]));
            }
          }));
  }
  return $$Promise.mapError(match[0], (function (e) {
                return /* PathSearchError */Caml_chrome_debugger.variant("PathSearchError", 0, [e]);
              }));
}

function validateAndMake(pathAndParams) {
  var match = Parser$AgdaMode.commandLine(pathAndParams);
  var args = match[1];
  var path = match[0];
  var parseError = function (error) {
    if (error == null) {
      return ;
    } else {
      var message = Rebase.$$Option.getOr("", error.message);
      if ((/No such file or directory/).test(message) || (/command not found/).test(message)) {
        return /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [error]);
      } else {
        return /* ShellError */Caml_chrome_debugger.variant("ShellError", 2, [error]);
      }
    }
  };
  var parseVersion = function (stdout) {
    var message = stdout.toString();
    var match = message.match((/Agda version (.*)/));
    if (match !== null) {
      var match$1 = Rebase.$$Array.get(match, 1);
      if (match$1 !== undefined) {
        var match$2 = (/--interaction-json/).test(message);
        return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* record */Caml_chrome_debugger.record([
                      "path",
                      "args",
                      "version",
                      "protocol",
                      "entries"
                    ], [
                      path,
                      args,
                      match$1,
                      match$2 ? /* EmacsAndJSON */1 : /* EmacsOnly */0,
                      []
                    ])]);
      } else {
        return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* WrongProcess */Caml_chrome_debugger.variant("WrongProcess", 4, [message])]);
      }
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, [/* WrongProcess */Caml_chrome_debugger.variant("WrongProcess", 4, [message])]);
    }
  };
  var match$1 = $$Promise.pending(/* () */0);
  var resolve = match$1[1];
  if (Rebase.$$String.isEmpty(path)) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* PathMalformed */Caml_chrome_debugger.variant("PathMalformed", 0, ["the path must not be empty"])]));
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */0]));
        }), 20000);
  return $$Promise.mapError((Child_process.exec(path + " -V", (function (error, stdout, stderr) {
                      clearTimeout(hangTimeout);
                      var match = parseError(error);
                      if (match !== undefined) {
                        Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [match]));
                      }
                      var stderr$prime = stderr.toString();
                      if (!Rebase.$$String.isEmpty(stderr$prime)) {
                        Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessError */Caml_chrome_debugger.variant("ProcessError", 3, [stderr$prime])]));
                      }
                      var match$1 = parseVersion(stdout);
                      if (match$1.tag) {
                        return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [match$1[0]]));
                      } else {
                        return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [match$1[0]]));
                      }
                    })), match$1[0]), (function (e) {
                return /* ValidationError */Caml_chrome_debugger.variant("ValidationError", 1, [e]);
              }));
}

function connect(metadata) {
  var match = $$Promise.pending(/* () */0);
  var resolve = match[1];
  var args = Rebase.$$Array.concat(metadata[/* args */1], /* array */["--interaction"]);
  var $$process = Child_process.spawn(metadata[/* path */0], args, {
        shell: true
      });
  var connection = /* record */Caml_chrome_debugger.record([
      "metadata",
      "process",
      "queue",
      "errorEmitter",
      "connected",
      "resetLogOnLoad"
    ], [
      metadata,
      $$process,
      [],
      Event$AgdaMode.make(/* () */0),
      true,
      true
    ]);
  return $$Promise.mapError(($$process.on("error", (function (exn) {
                        disconnect(/* ShellError */Caml_chrome_debugger.variant("ShellError", 1, [exn]), connection);
                        return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ShellError */Caml_chrome_debugger.variant("ShellError", 1, [exn])]));
                      })).on("close", (function (code, signal) {
                      disconnect(/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                              code,
                              signal
                            ]), connection);
                      return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                                        code,
                                        signal
                                      ])]));
                    })), $$process.stdout.once("data", (function (param) {
                      return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [connection]));
                    })), match[0]), (function (e) {
                return /* ConnectionError */Caml_chrome_debugger.variant("ConnectionError", 2, [e]);
              }));
}

function wire(self) {
  var response = function (res) {
    var match = Rebase.$$Array.get(self[/* queue */2], 0);
    if (match !== undefined) {
      Curry._1(match[/* emit */1], /* Ok */Caml_chrome_debugger.variant("Ok", 0, [res]));
      if (res) {
        return /* () */0;
      } else {
        return Rebase.$$Option.forEach((function (ev) {
                      return /* () */0;
                    }), Caml_option.undefined_to_opt(self[/* queue */2].pop()));
      }
    } else if (res) {
      var match$1 = res[0];
      if (match$1.tag) {
        return /* () */0;
      } else {
        return Curry._1(self[/* errorEmitter */3][/* emit */1], match$1[0]);
      }
    } else {
      return /* () */0;
    }
  };
  var partial_arg = Rebase.Result.map;
  var logSExpression = Curry._1(Parser$AgdaMode.Incr.$$Event.map, (function (param) {
          return partial_arg((function (expr) {
                        Metadata$AgdaMode.logSExpression(expr)(self[/* metadata */0]);
                        return expr;
                      }), param);
        }));
  var toResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.flatMap, (function (param) {
          if (param.tag) {
            return /* OnResult */Caml_chrome_debugger.simpleVariant("OnResult", [/* Error */Caml_chrome_debugger.variant("Error", 1, [param[0]])]);
          } else {
            var tokens = param[0];
            if (tokens.tag || tokens[0] !== "Agda2>") {
              return /* OnResult */Caml_chrome_debugger.simpleVariant("OnResult", [Response$AgdaMode.parse(tokens)]);
            } else {
              return /* OnFinish */0;
            }
          }
        }));
  var partial_arg$1 = Rebase.Result.map;
  var logResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.map, (function (param) {
          return partial_arg$1((function (expr) {
                        Metadata$AgdaMode.logResponse(expr)(self[/* metadata */0]);
                        return expr;
                      }), param);
        }));
  var callback = Parser$AgdaMode.SExpression.makeIncr(Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, logSExpression, toResponse), logResponse), response));
  var onData = function (chunk) {
    var rawText = chunk.toString();
    Metadata$AgdaMode.logRawText(rawText)(self[/* metadata */0]);
    var partial_arg = Parser$AgdaMode.Incr.feed;
    return Rebase.$$Array.forEach((function (param) {
                  return partial_arg(callback, param);
                }), Curry._1(Parser$AgdaMode.split, rawText));
  };
  self[/* process */1].stdout.on("data", onData);
  return self;
}

function send(request, self) {
  var reqEvent = Event$AgdaMode.make(/* () */0);
  self[/* queue */2].push(reqEvent);
  self[/* process */1].stdin.write(Buffer.from(request + "\n"));
  return reqEvent;
}

function resetLog(self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  return /* () */0;
}

exports.disconnect = disconnect;
exports.autoSearch = autoSearch;
exports.validateAndMake = validateAndMake;
exports.connect = connect;
exports.wire = wire;
exports.send = send;
exports.resetLog = resetLog;
/* os Not a pure module */
