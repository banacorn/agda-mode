// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Path = require("path");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Parser__Type$AgdaMode = require("./Parser/Parser__Type.bs.js");

function toString(param) {
  if (param.tag) {
    return "Parse error code: R" + (String(param[0]) + ("\n" + Parser__Type$AgdaMode.SExpression[/* toString */0](param[1])));
  } else {
    return "Parse error code: S" + (String(param[0]) + ("\n" + param[1]));
  }
}

var $$Error = /* module */Caml_chrome_debugger.localModule(["toString"], [toString]);

function captures(handler, regex, raw) {
  return Rebase.$$Option[/* flatMap */5](handler, Rebase.$$Option[/* map */0]((function (result) {
                    return Rebase.$$Array[/* map */0]((function (prim) {
                                  if (prim == null) {
                                    return undefined;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), result);
                  }), Caml_option.null_to_opt(regex.exec(raw))));
}

function agdaOutput(s) {
  return s.replace((/\\n/g), "\n");
}

function at(i, parser, captured) {
  if (i >= Rebase.$$Array[/* length */16](captured)) {
    return undefined;
  } else {
    return Rebase.$$Option[/* flatMap */5](parser, Rebase.$$Option[/* flatten */20](Rebase.$$Array[/* get */17](captured, i)));
  }
}

function choice(res, raw) {
  return Rebase.$$Array[/* reduce */3]((function (result, parse) {
                if (result !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(result));
                } else {
                  return Curry._1(parse, raw);
                }
              }), undefined, res);
}

function $$int(s) {
  var exit = 0;
  var i;
  try {
    i = Caml_format.caml_int_of_string(s);
    exit = 1;
  }
  catch (exn){
    return undefined;
  }
  if (exit === 1) {
    return i;
  }
  
}

function userInput(s) {
  var s$1 = s.replace((/\\/g), "\\\\").replace((/\"/g), "\\\"").replace((/\n/g), "\\n");
  var match = atom.config.get("agda-mode.trimSpaces");
  if (match) {
    return Rebase.$$String[/* trim */8](s$1);
  } else {
    return s$1;
  }
}

function filepath(s) {
  var removedBidi = s.charCodeAt(0) === 8234.0 ? s.slice(1) : s;
  var normalized = Path.normalize(removedBidi);
  return normalized.replace((/\\/g), "/");
}

function commandLine(s) {
  var parts = Rebase.List[/* fromArray */12](s.replace((/\s+/g), " ").split(" "));
  if (parts) {
    return /* tuple */[
            filepath(parts[0]),
            Rebase.$$Array[/* fromList */13](parts[1])
          ];
  } else {
    return /* tuple */[
            "",
            /* array */[]
          ];
  }
}

function splitAndTrim(string) {
  return Rebase.$$Array[/* map */0]((function (prim) {
                return prim.trim();
              }), Rebase.$$Array[/* filterMap */23]((function (x) {
                    return x;
                  }), Rebase.$$Array[/* map */0]((function (result) {
                        if (result !== undefined) {
                          var chunk = result;
                          if (chunk === "") {
                            return undefined;
                          } else {
                            return chunk;
                          }
                        }
                        
                      }), string.split((/\r\n|\n/)))));
}

var toString$1 = Parser__Type$AgdaMode.SExpression[/* toString */0];

function preprocess(string) {
  if (string.substring(0, 13) === "cannot read: ") {
    return /* Error */Caml_chrome_debugger.variant("Error", 1, [string.slice(12)]);
  } else if (Rebase.$$String[/* startsWith */3]("((last", string)) {
    var index = string.indexOf("(agda");
    return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [string.substring(index, Rebase.$$String[/* length */1](string) - 1 | 0)]);
  } else {
    return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [string]);
  }
}

function flatten(param) {
  if (param.tag) {
    return Rebase.$$Array[/* flatMap */5](flatten, param[0]);
  } else {
    return /* array */[param[0]];
  }
}

function parseWithContinuation(string) {
  var parseSExpression = function (state, string) {
    var in_str = state[/* in_str */3];
    var escaped = state[/* escaped */2];
    var word = state[/* word */1];
    var stack = state[/* stack */0];
    var pushToTheTop = function (elem) {
      var index = Rebase.$$Array[/* length */16](stack) - 1 | 0;
      var match = Rebase.$$Array[/* get */17](stack, index);
      if (match !== undefined) {
        var expr = match;
        var match$1 = expr[0];
        if (match$1.tag) {
          match$1[0].push(elem);
          return /* () */0;
        } else {
          expr[0] = /* L */Caml_chrome_debugger.variant("L", 1, [/* array */[
                expr[0],
                elem
              ]]);
          return /* () */0;
        }
      } else {
        return /* () */0;
      }
    };
    var totalLength = Rebase.$$String[/* length */1](string);
    for(var i = 0 ,i_finish = totalLength - 1 | 0; i <= i_finish; ++i){
      var $$char = string.charAt(i);
      if (escaped[0]) {
        if ($$char === "n") {
          word[0] = word[0] + "\\";
        }
        word[0] = word[0] + $$char;
        escaped[0] = false;
      } else if (!($$char === "'" && !in_str[0])) {
        if ($$char === "(" && !in_str[0]) {
          stack.push(/* record */Caml_chrome_debugger.record(["contents"], [Caml_chrome_debugger.variant("L", 1, [/* array */[]])]));
        } else if ($$char === ")" && !in_str[0]) {
          if (word[0] !== "") {
            pushToTheTop(/* A */Caml_chrome_debugger.variant("A", 0, [word[0]]));
            word[0] = "";
          }
          var match = stack.pop();
          if (match !== undefined) {
            pushToTheTop(match[0]);
          }
          
        } else if ($$char === " " && !in_str[0]) {
          if (word[0] !== "") {
            pushToTheTop(/* A */Caml_chrome_debugger.variant("A", 0, [word[0]]));
            word[0] = "";
          }
          
        } else if ($$char === "\"") {
          in_str[0] = !in_str[0];
        } else if ($$char === "\\" && in_str[0]) {
          escaped[0] = true;
        } else {
          word[0] = word[0] + $$char;
        }
      }
      
    }
    var match$1 = Rebase.$$Array[/* length */16](stack);
    if (match$1 !== 0) {
      if (match$1 !== 1) {
        return /* Continue */Caml_chrome_debugger.variant("Continue", 1, [(function (param) {
                      return parseSExpression(state, param);
                    })]);
      } else {
        var match$2 = Rebase.$$Array[/* get */17](stack, 0);
        if (match$2 !== undefined) {
          var match$3 = match$2[0];
          if (match$3.tag) {
            var match$4 = Rebase.$$Array[/* get */17](match$3[0], 0);
            if (match$4 !== undefined) {
              return /* Done */Caml_chrome_debugger.variant("Done", 2, [match$4]);
            } else {
              return /* Error */Caml_chrome_debugger.variant("Error", 0, [
                        2,
                        string
                      ]);
            }
          } else {
            return /* Error */Caml_chrome_debugger.variant("Error", 0, [
                      3,
                      string
                    ]);
          }
        } else {
          return /* Error */Caml_chrome_debugger.variant("Error", 0, [
                    1,
                    string
                  ]);
        }
      }
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 0, [
                0,
                string
              ]);
    }
  };
  var initialState = function (param) {
    return /* record */Caml_chrome_debugger.record([
              "stack",
              "word",
              "escaped",
              "in_str"
            ], [
              [/* record */Caml_chrome_debugger.record(["contents"], [Caml_chrome_debugger.variant("L", 1, [/* array */[]])])],
              Caml_chrome_debugger.record(["contents"], [""]),
              Caml_chrome_debugger.record(["contents"], [false]),
              Caml_chrome_debugger.record(["contents"], [false])
            ]);
  };
  var match = preprocess(string);
  if (match.tag) {
    return /* Error */Caml_chrome_debugger.variant("Error", 0, [
              4,
              string
            ]);
  } else {
    return parseSExpression(initialState(/* () */0), match[0]);
  }
}

function parse(input) {
  var resultAccum = /* record */Caml_chrome_debugger.record(["contents"], [[]]);
  var continuation = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  Rebase.$$Array[/* forEach */8]((function (line) {
          var $$continue = Rebase.$$Option[/* getOr */16](parseWithContinuation, continuation[0]);
          var match = Curry._1($$continue, line);
          switch (match.tag | 0) {
            case 0 : 
                resultAccum[0].push(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                            match[0],
                            match[1]
                          ])]));
                return /* () */0;
            case 1 : 
                continuation[0] = match[0];
                return /* () */0;
            case 2 : 
                resultAccum[0].push(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match[0]]));
                continuation[0] = undefined;
                return /* () */0;
            
          }
        }), splitAndTrim(input));
  return resultAccum[0];
}

function parse2(continuation, input) {
  var resultAccum = /* record */Caml_chrome_debugger.record(["contents"], [[]]);
  Rebase.$$Array[/* forEach */8]((function (line) {
          var $$continue = Rebase.$$Option[/* getOr */16](parseWithContinuation, continuation[0]);
          var match = Curry._1($$continue, line);
          switch (match.tag | 0) {
            case 0 : 
                resultAccum[0].push(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                            match[0],
                            match[1]
                          ])]));
                return /* () */0;
            case 1 : 
                continuation[0] = match[0];
                return /* () */0;
            case 2 : 
                resultAccum[0].push(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match[0]]));
                continuation[0] = undefined;
                return /* () */0;
            
          }
        }), splitAndTrim(input));
  return resultAccum[0];
}

function make(callback) {
  return /* record */Caml_chrome_debugger.record([
            "continuation",
            "callback"
          ], [
            Caml_chrome_debugger.record(["contents"], [undefined]),
            callback
          ]);
}

function feed(self, input) {
  var $$continue = Rebase.$$Option[/* getOr */16](parseWithContinuation, self[/* continuation */0][0]);
  var match = Curry._1($$continue, input);
  switch (match.tag | 0) {
    case 0 : 
        return Curry._1(self[/* callback */1], /* OnError */Caml_chrome_debugger.variant("OnError", 1, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                          match[0],
                          match[1]
                        ])]));
    case 1 : 
        self[/* continuation */0][0] = match[0];
        return /* () */0;
    case 2 : 
        Curry._1(self[/* callback */1], /* OnResult */Caml_chrome_debugger.variant("OnResult", 0, [match[0]]));
        self[/* continuation */0][0] = undefined;
        return /* () */0;
    
  }
}

function finish(self) {
  return Curry._1(self[/* callback */1], /* OnFinish */0);
}

var Incr = /* module */Caml_chrome_debugger.localModule([
    "make",
    "feed",
    "finish"
  ], [
    make,
    feed,
    finish
  ]);

var SExpression = /* module */Caml_chrome_debugger.localModule([
    "toString",
    "preprocess",
    "flatten",
    "parseWithContinuation",
    "parse",
    "parse2",
    "Incr"
  ], [
    toString$1,
    preprocess,
    flatten,
    parseWithContinuation,
    parse,
    parse2,
    Incr
  ]);

exports.$$Error = $$Error;
exports.captures = captures;
exports.agdaOutput = agdaOutput;
exports.at = at;
exports.choice = choice;
exports.$$int = $$int;
exports.userInput = userInput;
exports.filepath = filepath;
exports.commandLine = commandLine;
exports.splitAndTrim = splitAndTrim;
exports.SExpression = SExpression;
/* path Not a pure module */
