// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("./Util/Util.bs.js");
var Child_process = require("child_process");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Resource$AgdaMode = require("./Util/Resource.bs.js");

function toString(name) {
  switch (name.TAG | 0) {
    case /* ProcessHanging */0 :
        return [
                "Process not responding when looking for \"" + (name._0 + "\""),
                "Please restart the process"
              ];
    case /* NotSupported */1 :
        return [
                "Auto search failed",
                "currently auto path searching is not supported on " + name._0
              ];
    case /* NotFound */2 :
        return [
                "Auto search failed when looking for \"" + (name._0 + "\""),
                name._1
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function run(name) {
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: {
                        TAG: 0,
                        _0: name,
                        [Symbol.for("name")]: "ProcessHanging"
                      },
                      [Symbol.for("name")]: "Error"
                    });
        }), 1000);
  var os = Os.type();
  var commandName;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        commandName = {
          TAG: 0,
          _0: "which",
          [Symbol.for("name")]: "Ok"
        };
        break;
    case "Windows_NT" :
        commandName = {
          TAG: 0,
          _0: "where.exe",
          [Symbol.for("name")]: "Ok"
        };
        break;
    default:
      commandName = {
        TAG: 1,
        _0: os,
        [Symbol.for("name")]: "Error"
      };
  }
  if (commandName.TAG) {
    Curry._1(resolve, {
          TAG: 1,
          _0: {
            TAG: 1,
            _0: commandName._0,
            [Symbol.for("name")]: "NotSupported"
          },
          [Symbol.for("name")]: "Error"
        });
  } else {
    Child_process.exec(commandName._0 + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            Belt_Option.forEach((error == null) ? undefined : Caml_option.some(error), (function (err) {
                    return Curry._1(resolve, {
                                TAG: 1,
                                _0: {
                                  TAG: 2,
                                  _0: name,
                                  _1: Belt_Option.getWithDefault(err.message, ""),
                                  [Symbol.for("name")]: "NotFound"
                                },
                                [Symbol.for("name")]: "Error"
                              });
                  }));
            var stderr$1 = stderr.toString();
            if (stderr$1 !== "") {
              Curry._1(resolve, {
                    TAG: 1,
                    _0: {
                      TAG: 2,
                      _0: name,
                      _1: stderr$1,
                      [Symbol.for("name")]: "NotFound"
                    },
                    [Symbol.for("name")]: "Error"
                  });
            }
            var stdout$1 = $$String.trim(stdout.toString());
            if (stdout$1 === "") {
              return Curry._1(resolve, {
                          TAG: 1,
                          _0: {
                            TAG: 2,
                            _0: name,
                            _1: "",
                            [Symbol.for("name")]: "NotFound"
                          },
                          [Symbol.for("name")]: "Error"
                        });
            } else {
              return Curry._1(resolve, {
                          TAG: 0,
                          _0: stdout$1,
                          [Symbol.for("name")]: "Ok"
                        });
            }
          }));
  }
  return match[0];
}

var PathSearch = {
  $$Error: $$Error,
  run: run
};

function toString$1(msg) {
  if (typeof msg === "number") {
    return [
            "Process hanging",
            "The program has not been responding for more than 1 sec"
          ];
  }
  switch (msg.TAG | 0) {
    case /* PathMalformed */0 :
        return [
                "Path malformed",
                msg._0
              ];
    case /* NotFound */1 :
        return [
                "Command not found",
                Util$AgdaMode.JsError.toString(msg._0)
              ];
    case /* ShellError */2 :
        return [
                "Error from the shell",
                Util$AgdaMode.JsError.toString(msg._0)
              ];
    case /* ProcessError */3 :
        return [
                "Error from the stderr",
                msg._0
              ];
    case /* WrongProcess */4 :
        return [
                "Wrong process",
                msg._0
              ];
    
  }
}

var $$Error$1 = {
  toString: toString$1
};

function run$1(path, validator) {
  var parseError = function (error) {
    return Belt_Option.map((error == null) ? undefined : Caml_option.some(error), (function (err) {
                  var message = Belt_Option.getWithDefault(err.message, "");
                  if (/No such file or directory/.test(message) || /command not found/.test(message)) {
                    return {
                            TAG: 1,
                            _0: err,
                            [Symbol.for("name")]: "NotFound"
                          };
                  } else {
                    return {
                            TAG: 2,
                            _0: err,
                            [Symbol.for("name")]: "ShellError"
                          };
                  }
                }));
  };
  var match = $$Promise.pending(undefined);
  var resolve = match[1];
  if (path === "") {
    Curry._1(resolve, {
          TAG: 1,
          _0: {
            TAG: 0,
            _0: "the path must not be empty",
            [Symbol.for("name")]: "PathMalformed"
          },
          [Symbol.for("name")]: "Error"
        });
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, {
                      TAG: 1,
                      _0: /* ProcessHanging */0,
                      [Symbol.for("name")]: "Error"
                    });
        }), 20000);
  Child_process.exec(path, (function (error, stdout, stderr) {
          clearTimeout(hangTimeout);
          Belt_Option.forEach(parseError(error), (function (err) {
                  return Curry._1(resolve, {
                              TAG: 1,
                              _0: err,
                              [Symbol.for("name")]: "Error"
                            });
                }));
          var stderr$1 = stderr.toString();
          if (stderr$1 !== "") {
            Curry._1(resolve, {
                  TAG: 1,
                  _0: {
                    TAG: 3,
                    _0: stderr$1,
                    [Symbol.for("name")]: "ProcessError"
                  },
                  [Symbol.for("name")]: "Error"
                });
          }
          var stdout$1 = stdout.toString();
          var err = Curry._1(validator, stdout$1);
          if (err.TAG) {
            return Curry._1(resolve, {
                        TAG: 1,
                        _0: {
                          TAG: 4,
                          _0: err._0,
                          [Symbol.for("name")]: "WrongProcess"
                        },
                        [Symbol.for("name")]: "Error"
                      });
          } else {
            return Curry._1(resolve, {
                        TAG: 0,
                        _0: err._0,
                        [Symbol.for("name")]: "Ok"
                      });
          }
        }));
  return match[0];
}

var Validation = {
  $$Error: $$Error$1,
  run: run$1
};

function toString$2(error) {
  if (typeof error === "number") {
    if (error === /* DisconnectedByUser */0) {
      return [
              "Disconnected",
              "Connection disconnected by ourselves"
            ];
    } else {
      return [
              "Connection not established yet",
              "Please establish the connection first"
            ];
    }
  }
  switch (error.TAG | 0) {
    case /* ClosedByProcess */0 :
        return [
                "Socket closed by GCL",
                "exited with code: " + error._0 + "\nsignal: " + error._1 + "\n"
              ];
    case /* ShellError */1 :
        return [
                "Socket error",
                Util$AgdaMode.JsError.toString(error._0)
              ];
    case /* ExitedByProcess */2 :
        return [
                "GCL has crashed",
                "exited with code: " + error._0 + "\n  signal: " + error._1 + "\n  "
              ];
    
  }
}

var $$Error$2 = {
  toString: toString$2
};

function make(path, args) {
  var emitter = Event$AgdaMode.make(undefined);
  var $$process = Child_process.spawn(path, args, {
        shell: true
      });
  $$process.stdout.on("data", (function (chunk) {
          Curry._1(emitter.emit, {
                TAG: 0,
                _0: chunk.toString(),
                [Symbol.for("name")]: "Ok"
              });
          
        }));
  $$process.stdin.on("close", (function (param) {
          Curry._1(emitter.emit, {
                TAG: 1,
                _0: {
                  TAG: 0,
                  _0: 0,
                  _1: "",
                  [Symbol.for("name")]: "ClosedByProcess"
                },
                [Symbol.for("name")]: "Error"
              });
          
        }));
  $$process.on("close", (function (code, signal) {
                Curry._1(emitter.emit, {
                      TAG: 1,
                      _0: {
                        TAG: 0,
                        _0: code,
                        _1: signal,
                        [Symbol.for("name")]: "ClosedByProcess"
                      },
                      [Symbol.for("name")]: "Error"
                    });
                
              })).on("disconnect", (function (param) {
              Curry._1(emitter.emit, {
                    TAG: 1,
                    _0: /* DisconnectedByUser */0,
                    [Symbol.for("name")]: "Error"
                  });
              
            })).on("error", (function (exn) {
            Curry._1(emitter.emit, {
                  TAG: 1,
                  _0: {
                    TAG: 1,
                    _0: exn,
                    [Symbol.for("name")]: "ShellError"
                  },
                  [Symbol.for("name")]: "Error"
                });
            
          })).on("exit", (function (code, signal) {
          Curry._1(emitter.emit, {
                TAG: 1,
                _0: {
                  TAG: 2,
                  _0: code,
                  _1: signal,
                  [Symbol.for("name")]: "ExitedByProcess"
                },
                [Symbol.for("name")]: "Error"
              });
          
        }));
  var $$process$1 = {
    contents: {
      TAG: 0,
      _0: $$process,
      [Symbol.for("name")]: "Connected"
    }
  };
  var send = function (request) {
    var $$process$2 = $$process$1.contents;
    if (typeof $$process$2 === "number") {
      return {
              TAG: 1,
              _0: /* NotEstablishedYet */1,
              [Symbol.for("name")]: "Error"
            };
    }
    if ($$process$2.TAG) {
      return {
              TAG: 1,
              _0: /* NotEstablishedYet */1,
              [Symbol.for("name")]: "Error"
            };
    }
    var payload = Buffer.from(request + "\n");
    $$process$2._0.stdin.write(payload);
    return {
            TAG: 0,
            _0: undefined,
            [Symbol.for("name")]: "Ok"
          };
  };
  var disconnect = function (param) {
    var process$prime = $$process$1.contents;
    if (typeof process$prime === "number") {
      return $$Promise.resolved(undefined);
    }
    if (process$prime.TAG) {
      return Curry._1(process$prime._0.acquire, undefined);
    }
    var pending = Resource$AgdaMode.make(undefined);
    $$process$1.contents = {
      TAG: 1,
      _0: pending,
      [Symbol.for("name")]: "Disconnecting"
    };
    Curry._1(emitter.on, (function (param) {
            if (!param.TAG) {
              return ;
            }
            var tmp = param._0;
            if (typeof tmp === "number") {
              return ;
            }
            if (tmp.TAG !== /* ExitedByProcess */2) {
              return ;
            }
            Curry._1(emitter.destroy, undefined);
            $$process$1.contents = /* Disconnected */0;
            return Curry._1(pending.supply, undefined);
          }));
    process$prime._0.kill("SIGTERM");
    return Curry._1(pending.acquire, undefined);
  };
  var isConnected = function (param) {
    var match = $$process$1.contents;
    if (typeof match === "number" || match.TAG) {
      return false;
    } else {
      return true;
    }
  };
  return {
          send: send,
          emitter: emitter,
          disconnect: disconnect,
          isConnected: isConnected
        };
}

exports.PathSearch = PathSearch;
exports.Validation = Validation;
exports.$$Error = $$Error$2;
exports.make = make;
/* os Not a pure module */
