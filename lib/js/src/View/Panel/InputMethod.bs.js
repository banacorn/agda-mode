// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Hook$AgdaMode = require("../Hook.bs.js");
var Util$AgdaMode = require("../../Util/Util.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Buffer$AgdaMode = require("./InputMethod/Buffer.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var Editors$AgdaMode = require("../../Editors.bs.js");
var Channels$AgdaMode = require("../Channels.bs.js");
var Translator$AgdaMode = require("./InputMethod/Translator.bs.js");
var Type__View$AgdaMode = require("../../Type/Type__View.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var CandidateSymbols$AgdaMode = require("./InputMethod/CandidateSymbols.bs.js");

var initialState = {
  activated: false,
  buffer: Buffer$AgdaMode.initial,
  reality: ""
};

function addClass(editor) {
  atom.views.getView(editor).classList.add("agda-mode-input-method-activated");
  
}

function removeClass(editor) {
  atom.views.getView(editor).classList.remove("agda-mode-input-method-activated");
  
}

function getSelections(editor) {
  var getCharIndex = function (selection) {
    var start = selection.getBufferRange().start;
    return editor.getBuffer().characterIndexForPosition(start);
  };
  var compareSelection = function (a, b) {
    return Caml_primitive.caml_int_compare(getCharIndex(a), getCharIndex(b));
  };
  var selections = editor.getSelections();
  $$Array.sort(compareSelection, selections);
  return selections;
}

function insertTextBuffer(editor, $$char) {
  return Rebase.$$Array.forEach((function (selection) {
                var range = selection.getBufferRange();
                editor.setTextInBufferRange(range, $$char);
                
              }), getSelections(editor));
}

function rewriteTextBuffer(editor, markers, string) {
  return Rebase.$$Array.forEach((function (marker) {
                editor.getBuffer().setTextInRange(marker.getBufferRange(), string);
                
              }), markers);
}

function clearAndMarkSelectedAreas(editor) {
  return Rebase.$$Array.map((function (selection) {
                var range = selection.getBufferRange();
                editor.setTextInBufferRange(range, "");
                return editor.markBufferRange(range.copy());
              }), getSelections(editor));
}

function markerOnDidChange(editor, setReality, $$event) {
  var rangeOld = new Atom.Range($$event.oldTailBufferPosition, $$event.oldHeadBufferPosition);
  var rangeNew = new Atom.Range($$event.newTailBufferPosition, $$event.newHeadBufferPosition);
  editor.getTextInBufferRange(rangeOld);
  return Curry._1(setReality, editor.getTextInBufferRange(rangeNew));
}

function monitor(editor, setMarkers, setReality, send) {
  var disposables = new Atom.CompositeDisposable();
  addClass(editor);
  var markers = clearAndMarkSelectedAreas(editor);
  Curry._1(setMarkers, markers);
  Rebase.$$Option.forEach((function (marker) {
          disposables.add(marker.onDidChange((function (param) {
                      return markerOnDidChange(editor, setReality, param);
                    })));
          disposables.add(atom.commands.add("atom-text-editor.agda-mode-input-method-activated", "editor:newline", (function ($$event) {
                      Curry._1(send, /* Deactivate */1);
                      $$event.stopImmediatePropagation();
                      
                    })));
          
        }), Rebase.$$Array.get(markers, 0));
  disposables.add(editor.onDidChangeCursorPosition((function ($$event) {
              var point = $$event.newBufferPosition;
              var ranges = Rebase.$$Array.map((function (prim) {
                      return prim.getBufferRange();
                    }), markers);
              var inRange = Rebase.$$Array.exists((function (param) {
                      return param.containsPoint(point);
                    }), ranges);
              if (!inRange) {
                return Curry._1(send, /* Deactivate */1);
              }
              
            })));
  var decorations = Rebase.$$Array.map((function (marker) {
          return editor.decorateMarker(marker, {
                      type: "highlight",
                      class: "input-method-decoration"
                    });
        }), markers);
  return (function (param) {
            removeClass(editor);
            Rebase.$$Array.forEach((function (prim) {
                    prim.destroy();
                    
                  }), decorations);
            Rebase.$$Array.forEach((function (prim) {
                    prim.destroy();
                    
                  }), markers);
            disposables.dispose();
            return Curry._1(setMarkers, []);
          });
}

function reducer(state, action) {
  if (typeof action === "number") {
    if (action === /* Activate */0) {
      if (state.activated) {
        return {
                activated: false,
                buffer: Buffer$AgdaMode.initial,
                reality: ""
              };
      } else {
        return {
                activated: true,
                buffer: state.buffer,
                reality: state.reality
              };
      }
    } else if (state.activated) {
      return {
              activated: false,
              buffer: Buffer$AgdaMode.initial,
              reality: ""
            };
    } else {
      return state;
    }
  }
  if (action.tag) {
    return {
            activated: state.activated,
            buffer: state.buffer,
            reality: action[0]
          };
  }
  var buffer = action[0];
  if (buffer === state.buffer) {
    return state;
  } else {
    return {
            activated: state.activated,
            buffer: buffer,
            reality: state.reality
          };
  }
}

function hasChanged(state, changeLog) {
  var deactivateActivateCombo = !state.activated && changeLog === /* Noop */0;
  var aborted = changeLog === /* Abort */4;
  if (deactivateActivateCombo) {
    return aborted;
  } else {
    return true;
  }
}

function InputMethod(Props) {
  var editors = Props.editors;
  var onChange = Props.onChange;
  var panelActivated = Props.panelActivated;
  var editor = Editors$AgdaMode.Focus.get(editors);
  var match = Hook$AgdaMode.useState([]);
  var setMarkers = match[1];
  var markers = match[0];
  var match$1 = React.useReducer(reducer, initialState);
  var send = match$1[1];
  var state = match$1[0];
  var stateRef = React.useRef(state);
  var match$2 = Hook$AgdaMode.useState(/* Noop */0);
  var setChangeLog = match$2[1];
  var changeLog = match$2[0];
  stateRef.current = state;
  var channels = React.useContext(Channels$AgdaMode.context);
  Hook$AgdaMode.useChannel((function (shouldActivate) {
          var state = stateRef.current;
          if (shouldActivate) {
            if (state.activated) {
              if (Buffer$AgdaMode.isEmpty(state.buffer)) {
                insertTextBuffer(editor, "\\");
                Curry._1(send, /* Deactivate */1);
              } else {
                Curry._1(send, /* Deactivate */1);
                Curry._1(send, /* Activate */0);
              }
            } else {
              Curry._1(send, /* Activate */0);
            }
          } else {
            Curry._1(setChangeLog, /* Abort */4);
            Curry._1(send, /* Deactivate */1);
          }
          return $$Promise.resolved(undefined);
        }), channels.activateInputMethod);
  Hook$AgdaMode.useChannel((function ($$char) {
          insertTextBuffer(editor, $$char);
          return $$Promise.resolved(undefined);
        }), channels.interceptAndInsertKey);
  var setReality = function (s) {
    return Curry._1(send, /* UpdateReality */Caml_chrome_debugger.variant("UpdateReality", 1, [s]));
  };
  React.useEffect((function () {
          var buffer = Buffer$AgdaMode.next(state.buffer, state.reality);
          if (typeof buffer === "number") {
            if (buffer === /* Noop */0) {
              Curry._1(setChangeLog, /* Noop */0);
            } else {
              Curry._1(setChangeLog, /* Complete */2);
              Curry._1(send, /* Deactivate */1);
            }
          } else {
            switch (buffer.tag | 0) {
              case /* Insert */0 :
              case /* Backspace */1 :
                  Curry._1(setChangeLog, /* Noop */0);
                  Curry._1(send, /* UpdateBuffer */Caml_chrome_debugger.variant("UpdateBuffer", 0, [buffer[0]]));
                  break;
              case /* Rewrite */2 :
                  var buffer$1 = buffer[0];
                  Curry._1(setChangeLog, /* Rewrite */1);
                  Curry._1(send, /* UpdateBuffer */Caml_chrome_debugger.variant("UpdateBuffer", 0, [buffer$1]));
                  var surface = Buffer$AgdaMode.toSurface(buffer$1);
                  rewriteTextBuffer(editor, markers, surface);
                  break;
              case /* Stuck */3 :
                  Curry._1(setChangeLog, /* Stuck */3);
                  Curry._1(send, /* Deactivate */1);
                  break;
              
            }
          }
          
        }), [state.reality]);
  var debugDispatch = React.useContext(Type__View$AgdaMode.Debug.debugDispatch);
  React.useEffect((function () {
          if (hasChanged(state, changeLog)) {
            Curry._1(onChange.emit, state);
          }
          if (atom.inDevMode()) {
            Curry._1(debugDispatch, /* UpdateInputMethod */Caml_chrome_debugger.simpleVariant("UpdateInputMethod", [{
                      activated: state.activated,
                      markers: markers,
                      buffer: state.buffer
                    }]));
          }
          
        }), /* tuple */[
        state.activated,
        state.buffer
      ]);
  Hook$AgdaMode.useListenWhen((function (param) {
          return monitor(editor, setMarkers, setReality, send);
        }), state.activated);
  var translation = Translator$AgdaMode.translate(Buffer$AgdaMode.toSequence(state.buffer));
  return React.createElement("section", {
              className: "input-method" + Util$AgdaMode.React.showWhen(state.activated)
            }, React.createElement("div", {
                  className: "keyboard"
                }, React.createElement("div", {
                      className: "inline-block buffer" + Util$AgdaMode.React.showWhen(!Buffer$AgdaMode.isEmpty(state.buffer))
                    }, Buffer$AgdaMode.toSequence(state.buffer)), Caml_splice_call.spliceApply(React.createElement, [
                      "div",
                      {
                        className: "keys btn-group btn-group-sm"
                      },
                      Rebase.$$Array.map((function (key) {
                              return React.createElement("button", {
                                          key: key,
                                          className: "btn",
                                          onClick: (function (param) {
                                              return insertTextBuffer(editor, key);
                                            })
                                        }, key);
                            }), translation.keySuggestions)
                    ])), React.createElement(CandidateSymbols$AgdaMode.make, {
                  activated: panelActivated && state.activated,
                  candidateSymbols: translation.candidateSymbols,
                  updateTranslation: (function (replace) {
                      if (replace !== undefined) {
                        Curry._1(onChange.emit, state);
                        return rewriteTextBuffer(editor, markers, replace);
                      }
                      
                    }),
                  chooseSymbol: (function (symbol) {
                      rewriteTextBuffer(editor, markers, symbol);
                      return Curry._1(send, /* Deactivate */1);
                    })
                }));
}

var sort = $$Array.sort;

var make = InputMethod;

exports.sort = sort;
exports.initialState = initialState;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.getSelections = getSelections;
exports.insertTextBuffer = insertTextBuffer;
exports.rewriteTextBuffer = rewriteTextBuffer;
exports.clearAndMarkSelectedAreas = clearAndMarkSelectedAreas;
exports.markerOnDidChange = markerOnDidChange;
exports.monitor = monitor;
exports.reducer = reducer;
exports.hasChanged = hasChanged;
exports.make = make;
/* atom Not a pure module */
