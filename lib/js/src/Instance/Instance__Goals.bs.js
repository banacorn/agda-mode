// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Goal$AgdaMode = require("../Goal.bs.js");
var Hole$AgdaMode = require("../Hole.bs.js");
var Parser$AgdaMode = require("../Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function destroyAll(instance) {
  Rebase.$$Array.forEach(Goal$AgdaMode.destroy, instance[/* goals */5]);
  instance[/* goals */5] = /* array */[];
  return /* () */0;
}

function find(index, instance) {
  var found = Rebase.$$Array.filter((function (goal) {
          return goal[/* index */1] === index;
        }), instance[/* goals */5]);
  return Rebase.$$Array.get(found, 0);
}

function setCursor(goal, instance) {
  var position = goal[/* range */2].start.translate(new Atom.Point(0, 3));
  instance[/* editors */0][/* source */1].setCursorBufferPosition(position);
  return /* () */0;
}

function getPositions(instance) {
  return Rebase.$$Array.map((function (range) {
                return range.start.translate(new Atom.Point(0, 3));
              }), Rebase.$$Array.map((function (goal) {
                    return goal[/* range */2];
                  }), instance[/* goals */5]));
}

function getPreviousGoalPosition(instance) {
  var previousGoal = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  var cursor = instance[/* editors */0][/* source */1].getCursorBufferPosition();
  var positions = getPositions(instance);
  Rebase.$$Array.forEach((function (position) {
          if (position.isLessThan(cursor)) {
            previousGoal[0] = Caml_option.some(position);
            return /* () */0;
          } else {
            return 0;
          }
        }), positions);
  if (previousGoal[0] === undefined) {
    previousGoal[0] = Rebase.$$Array.get(positions, Rebase.$$Array.length(positions) - 1 | 0);
  }
  return previousGoal[0];
}

function getNextGoalPosition(instance) {
  var nextGoal = /* record */Caml_chrome_debugger.record(["contents"], [undefined]);
  var cursor = instance[/* editors */0][/* source */1].getCursorBufferPosition();
  var positions = getPositions(instance);
  Rebase.$$Array.forEach((function (position) {
          if (position.isGreaterThan(cursor) && nextGoal[0] === undefined) {
            nextGoal[0] = Caml_option.some(position);
            return /* () */0;
          } else {
            return 0;
          }
        }), positions);
  if (nextGoal[0] === undefined) {
    nextGoal[0] = Rebase.$$Array.get(positions, 0);
  }
  return nextGoal[0];
}

function instantiateAll(indices, instance) {
  destroyAll(instance);
  var textEditor = instance[/* editors */0][/* source */1];
  var filePath = Parser$AgdaMode.filepath(Rebase.$$Option.getOr("untitled", textEditor.getPath()));
  var textBuffer = textEditor.getBuffer();
  var source = textEditor.getText();
  var fileType = Goal$AgdaMode.FileType.parse(filePath);
  var result = Hole$AgdaMode.parse(source, indices, fileType);
  instance[/* goals */5] = Rebase.$$Array.map((function (result) {
          var start = textBuffer.positionForCharacterIndex(result[/* originalRange */2][0]);
          var end_ = textBuffer.positionForCharacterIndex(result[/* originalRange */2][1]);
          var range = new Atom.Range(start, end_);
          textEditor.setTextInBufferRange(range, result[/* content */3]);
          return Goal$AgdaMode.make(instance[/* editors */0][/* source */1], result[/* index */0], result[/* modifiedRange */1]);
        }), result);
  return /* () */0;
}

exports.destroyAll = destroyAll;
exports.find = find;
exports.setCursor = setCursor;
exports.getPositions = getPositions;
exports.getPreviousGoalPosition = getPreviousGoalPosition;
exports.getNextGoalPosition = getNextGoalPosition;
exports.instantiateAll = instantiateAll;
/* atom Not a pure module */
