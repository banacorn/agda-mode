// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");
var AgdaMode$AgdaMode = require("../src/AgdaMode.bs.js");
var Instance$AgdaMode = require("../src/Instance.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Webapi__Dom__Element = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__Element.js");
var Webapi__Dom__HtmlElement = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__HtmlElement.js");

var Exn = Caml_exceptions.create("Test__Util-AgdaMode.Exn");

function equal(message, expected, actual) {
  return Assert$BsMocha.equal(message, actual, expected);
}

function yes(param) {
  return Assert$BsMocha.equal(undefined, param, true);
}

function no(param) {
  return Assert$BsMocha.equal(undefined, param, false);
}

function ok(param) {
  return Assert$BsMocha.ok(true);
}

var Assert = {
  equal: equal,
  yes: yes,
  no: no,
  fail: Assert$BsMocha.fail,
  ok: ok
};

function getValue(param) {
  return param[0];
}

function fromChangeObject(obj) {
  if (obj.added) {
    return /* Added */Caml_chrome_debugger.variant("Added", 0, [obj.value]);
  } else if (obj.removed) {
    return /* Removed */Caml_chrome_debugger.variant("Removed", 1, [obj.value]);
  } else {
    return /* NoChange */Caml_chrome_debugger.variant("NoChange", 2, [obj.value]);
  }
}

function wordsWithSpace(a, b) {
  return Belt_Array.map(Diff.diffWordsWithSpace(a, b), fromChangeObject);
}

function firstChange(diffs) {
  var count = {
    contents: 0
  };
  var change = {
    contents: undefined
  };
  Belt_Array.forEach(diffs, (function (diff) {
          if (Belt_Option.isNone(change.contents)) {
            switch (diff.tag | 0) {
              case /* Added */0 :
                  change.contents = /* Added */Caml_chrome_debugger.variant("Added", 0, [diff[0]]);
                  return /* () */0;
              case /* Removed */1 :
                  change.contents = /* Removed */Caml_chrome_debugger.variant("Removed", 1, [diff[0]]);
                  return /* () */0;
              case /* NoChange */2 :
                  count.contents = count.contents + diff[0].length | 0;
                  return /* () */0;
              
            }
          } else {
            return 0;
          }
        }));
  return Belt_Option.map(change.contents, (function (change) {
                return /* tuple */[
                        change,
                        count.contents
                      ];
              }));
}

var Diff$1 = {
  getValue: getValue,
  fromChangeObject: fromChangeObject,
  wordsWithSpace: wordsWithSpace,
  firstChange: firstChange
};

function getGoldenFilepaths(dirname) {
  var readdir = Util.promisify((function (prim, prim$1) {
          Fs.readdir(prim, prim$1);
          return /* () */0;
        }));
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return readdir(dirname).then((function (paths) {
                return Promise.resolve(Belt_Array.map(Belt_Array.keep(paths, isInFile), toBasename));
              }));
}

function getGoldenFilepathsSync(dirname) {
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return Belt_Array.map(Belt_Array.keep(Fs.readdirSync(dirname), isInFile), toBasename);
}

var FileMissing = Caml_exceptions.create("Test__Util-AgdaMode.Golden.FileMissing");

function map(param, f) {
  return /* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
            param[0],
            Curry._1(f, param[1]),
            param[2]
          ]);
}

function readFile(filepath) {
  var readFile$1 = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          return /* () */0;
        }));
  return Promise.all([
                readFile$1(filepath + ".in"),
                readFile$1(filepath + ".out")
              ]).then((function (param) {
                if (param.length !== 2) {
                  return Promise.reject([
                              FileMissing,
                              filepath
                            ]);
                } else {
                  var input = param[0];
                  var output = param[1];
                  return Promise.resolve(/* Golden */Caml_chrome_debugger.simpleVariant("Golden", [
                                filepath,
                                input.toString(),
                                output.toString()
                              ]));
                }
              }));
}

function compare(param) {
  var actual = param[1].trim();
  var expected = param[2].trim();
  Belt_Option.forEach(firstChange(wordsWithSpace(actual, expected)), (function (param) {
          var count = param[1];
          var diff = param[0];
          var value = diff[0];
          var change = value.length > 100 ? value.substr(0, 100) + " ..." : value;
          var expected$prime = expected.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var actual$prime = actual.substr(Caml_primitive.caml_int_max(0, count - 50 | 0), (50 + value.length | 0) + 50 | 0);
          var message = "\n\nexpected => " + (expected$prime + ("\n\nactual   => " + (actual$prime + "\n\nchange => ")));
          switch (diff.tag | 0) {
            case /* Added */0 :
                return Assert$BsMocha.fail(message + (" added \"" + (change + ("\"\n at position " + String(count)))));
            case /* Removed */1 :
                return Assert$BsMocha.fail(message + (" removed \"" + (change + ("\"\n\n at position " + String(count)))));
            case /* NoChange */2 :
                return /* () */0;
            
          }
        }));
  return Promise.resolve(/* () */0);
}

var Golden = {
  Diff: Diff$1,
  getGoldenFilepaths: getGoldenFilepaths,
  getGoldenFilepathsSync: getGoldenFilepathsSync,
  FileMissing: FileMissing,
  map: map,
  readFile: readFile,
  compare: compare
};

function serialize(xs) {
  return Caml_splice_call.spliceObjApply("", "concat", [Belt_Array.map(xs, (function (x) {
                      return x + "\n";
                    }))]);
}

function serializeWith(f, xs) {
  return serialize(Belt_Array.map(xs, f));
}

function breakInput(input, breakpoints) {
  var breakpoints$prime = Belt_Array.concat([0], breakpoints);
  return Belt_Array.map(Belt_Array.mapWithIndex(breakpoints$prime, (function (i, x) {
                    var match = Belt_Array.get(breakpoints$prime, i + 1 | 0);
                    if (match !== undefined) {
                      return /* tuple */[
                              x,
                              match - x | 0
                            ];
                    } else {
                      return /* tuple */[
                              x,
                              input.length - x | 0
                            ];
                    }
                  })), (function (param) {
                return input.substr(param[0], param[1]);
              }));
}

function childHtmlElements(elem) {
  return Belt_Array.keepMap(Array.prototype.slice.call(elem.childNodes), Webapi__Dom__HtmlElement.ofNode);
}

function getPanelContainersAtBottom(param) {
  return Belt_Array.keep(Belt_Array.concatMany(Belt_Array.map(Belt_Array.map(atom.workspace.getBottomPanels(), (function (prim) {
                            return atom.views.getView(prim);
                          })), childHtmlElements)), (function (elem) {
                return elem.className === "agda-mode-panel-container";
              }));
}

function getPanelContainersAtPanes(param) {
  return Belt_Array.keep(Belt_Array.map(atom.workspace.getPaneItems(), (function (prim) {
                    return atom.views.getView(prim);
                  })), (function (elem) {
                return elem.className === "agda-mode-panel-container";
              }));
}

function getPanelContainers(param) {
  return Belt_Array.concat(getPanelContainersAtBottom(/* () */0), getPanelContainersAtPanes(/* () */0));
}

var PanelNotFound = Caml_exceptions.create("Test__Util-AgdaMode.View.PanelNotFound");

function getPanel(instance) {
  var isTarget = function (element) {
    return element.id === "agda-mode:" + Instance$AgdaMode.getID(instance);
  };
  var panels = Belt_Array.concatMany(Belt_Array.map(getPanelContainers(/* () */0), (function (x) {
              return Belt_Array.keep(childHtmlElements(x), isTarget);
            })));
  var match = Belt_Array.get(panels, 0);
  if (match !== undefined) {
    return Promise.resolve(Caml_option.valFromOption(match));
  } else {
    return Promise.reject(PanelNotFound);
  }
}

var ElementNotFound = Caml_exceptions.create("Test__Util-AgdaMode.View.ElementNotFound");

function querySelector(selector, elem) {
  return Belt_Option.mapWithDefault(Belt_Option.flatMap(Caml_option.nullable_to_opt(elem.querySelector(selector)), Webapi__Dom__Element.asHtmlElement), Promise.reject([
                  ElementNotFound,
                  "cannot find `" + (selector + "`")
                ]), (function (prim) {
                return Promise.resolve(prim);
              }));
}

var View = {
  childHtmlElements: childHtmlElements,
  getPanelContainersAtBottom: getPanelContainersAtBottom,
  getPanelContainersAtPanes: getPanelContainersAtPanes,
  getPanelContainers: getPanelContainers,
  PanelNotFound: PanelNotFound,
  getPanel: getPanel,
  ElementNotFound: ElementNotFound,
  querySelector: querySelector
};

var base = Path.join(__dirname, "../../../");

function file(path) {
  return Path.join(base, path);
}

function asset(path) {
  return Path.join(Path.join(base, "test/asset"), path);
}

var Path$1 = {
  base: base,
  file: file,
  asset: asset
};

function open_(uri) {
  return atom.workspace.open(uri);
}

function openAsset(x) {
  return atom.workspace.open(asset(x));
}

function close(uri) {
  var pane = atom.workspace.paneForURI(uri);
  if (pane !== undefined) {
    var p = Caml_option.valFromOption(pane);
    var item = p.itemForURI(uri);
    if (item !== undefined) {
      return p.destroyItem(Caml_option.valFromOption(item), true);
    } else {
      return Promise.resolve(false);
    }
  } else {
    return Promise.resolve(false);
  }
}

var $$File = {
  open_: open_,
  openAsset: openAsset,
  close: close
};

function activeNames(param) {
  return Belt_Array.map(atom.packages.getActivePackages(), (function (prim) {
                return prim.name;
              }));
}

function loadedNames(param) {
  return Belt_Array.map(atom.packages.getLoadedPackages(), (function (prim) {
                return prim.name;
              }));
}

function activate(param) {
  atom.packages.activatePackage("agda-mode");
  return AgdaMode$AgdaMode.activate(/* () */0);
}

function deactivate(param) {
  return atom.packages.deactivatePackage("agda-mode", false);
}

function after_each(param) {
  var resetConfig = function (param) {
    atom.config.set("agda-mode.agdaPath", "");
    atom.config.set("agda-mode.agdaName", "agda");
    return Promise.resolve(/* () */0);
  };
  var clearAllFiles = function (param) {
    return atom.workspace.open(asset("Temp.agda")).then((function (editor) {
                  var _param = /* () */0;
                  while(true) {
                    editor.setText("");
                    if (editor.getText() !== "") {
                      _param = /* () */0;
                      continue ;
                    } else {
                      return editor.save();
                    }
                  };
                }));
  };
  var destroyAllTextEditors = function (param) {
    var __x = Promise.all(Belt_Array.concatMany(Belt_Array.map(atom.workspace.getPanes(), (function (pane) {
                    return Belt_Array.map(pane.getItems(), (function (item) {
                                  return pane.destroyItem(item, true);
                                }));
                  }))));
    return __x.then((function (param) {
                  return Promise.resolve(/* () */0);
                }));
  };
  return resetConfig(/* () */0).then(destroyAllTextEditors).then(clearAllFiles);
}

var Package = {
  activeNames: activeNames,
  loadedNames: loadedNames,
  activate: activate,
  deactivate: deactivate,
  after_each: after_each
};

function getInstance(editor) {
  return Belt_Option.getWithDefault(Belt_Option.map(AgdaMode$AgdaMode.Instances.get(editor), (function (instance) {
                    return Promise.resolve(instance);
                  })), Promise.reject([
                  Exn,
                  "instance doesn't exist"
                ]));
}

var DispatchFailure = Caml_exceptions.create("Test__Util-AgdaMode.DispatchFailure");

function dispatch($$event, instance) {
  var onDispatch = $$Promise.Js.toBsPromise(Curry._1(instance.onDispatch.once, /* () */0));
  var match = atom.commands.dispatch(atom.views.getView(instance.editors.source), $$event);
  if (match !== undefined) {
    return Caml_option.valFromOption(match).then((function (param) {
                    return onDispatch;
                  })).then((function (param) {
                  return Promise.resolve(instance);
                }));
  } else {
    return Promise.reject([
                DispatchFailure,
                $$event
              ]);
  }
}

function openAndLoad(path) {
  return atom.workspace.open(asset(path)).then(getInstance).then((function (param) {
                return dispatch("agda-mode:load", param);
              }));
}

function close$1(instance) {
  var onDestroy = $$Promise.Js.toBsPromise(Curry._1(instance.view.onDestroy.once, /* () */0));
  atom.workspace.hide(instance.editors.source);
  return onDestroy;
}

function dispatch$1(key, instance) {
  var element = atom.views.getView(instance.editors.source);
  var onDispatch = $$Promise.Js.toBsPromise(Curry._1(instance.onDispatch.once, /* () */0));
  var keyboardEvent = atom.keymaps.constructor.buildKeydownEvent(key, {
        ctrl: false,
        alt: false,
        shift: false,
        cmd: false,
        which: 0,
        target: element
      });
  atom.keymaps.handleKeyboardEvent(keyboardEvent);
  return onDispatch.then((function (param) {
                return new Promise((function (resolve, param) {
                              setTimeout((function (param) {
                                      return resolve(instance);
                                    }), 0);
                              return /* () */0;
                            }));
              }));
}

function insertUntilSuccess(text, instance) {
  var editor = instance.editors.source;
  var before = editor.getText();
  editor.insertText(text);
  return editor.save().then((function (param) {
                var after = editor.getText();
                if (before !== after) {
                  return Promise.resolve(instance);
                } else {
                  editor.setText(before);
                  return insertUntilSuccess(text, instance);
                }
              }));
}

function insert(key, instance) {
  var onChange = $$Promise.Js.toBsPromise(Curry._1(instance.view.onInputMethodChange.once, /* () */0));
  return insertUntilSuccess(key, instance).then((function (param) {
                  return onChange;
                })).then((function (param) {
                return Promise.resolve(instance);
              }));
}

function backspace(instance) {
  var backspaceUntilSuccess = function (param) {
    var before = instance.editors.source.getText();
    instance.editors.source.backspace();
    return instance.editors.source.save().then((function (param) {
                  var after = instance.editors.source.getText();
                  if (before !== after) {
                    return Promise.resolve(/* () */0);
                  } else {
                    instance.editors.source.setText(before);
                    return backspaceUntilSuccess(/* () */0);
                  }
                }));
  };
  var onChange = $$Promise.Js.toBsPromise(Curry._1(instance.view.onInputMethodChange.once, /* () */0));
  return backspaceUntilSuccess(/* () */0).then((function (param) {
                  return onChange;
                })).then((function (param) {
                return Promise.resolve(instance);
              }));
}

var Keyboard = {
  dispatch: dispatch$1,
  insertUntilSuccess: insertUntilSuccess,
  insert: insert,
  backspace: backspace
};

exports.Exn = Exn;
exports.Assert = Assert;
exports.Golden = Golden;
exports.serialize = serialize;
exports.serializeWith = serializeWith;
exports.breakInput = breakInput;
exports.View = View;
exports.Path = Path$1;
exports.$$File = $$File;
exports.Package = Package;
exports.getInstance = getInstance;
exports.DispatchFailure = DispatchFailure;
exports.dispatch = dispatch;
exports.openAndLoad = openAndLoad;
exports.close = close$1;
exports.Keyboard = Keyboard;
/* base Not a pure module */
