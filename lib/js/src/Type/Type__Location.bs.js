// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");
var Util$AgdaMode = require("../Util/Util.bs.js");
var Parser$AgdaMode = require("../Parser.bs.js");

function decode(param) {
  return Json_decode.andThen((function (tup, param) {
                return {
                        pos: Rebase.$$Array.get(tup, 2),
                        line: Rebase.$$Option.getOr(0, Rebase.$$Array.get(tup, 0)),
                        col: Rebase.$$Option.getOr(0, Rebase.$$Array.get(tup, 1))
                      };
              }), (function (param) {
                return Json_decode.array(Json_decode.$$int, param);
              }), param);
}

var Position = {
  decode: decode
};

function fuse(a, b) {
  var start = Caml_obj.caml_greaterthan(a.start.pos, b.start.pos) ? b.start : a.start;
  var end_ = Caml_obj.caml_greaterthan(a.end_.pos, b.end_.pos) ? a.end_ : b.end_;
  return {
          start: start,
          end_: end_
        };
}

function toString(self) {
  if (self.start.line === self.end_.line) {
    return String(self.start.line) + ("," + (String(self.start.col) + ("-" + String(self.end_.col))));
  } else {
    return String(self.start.line) + ("," + (String(self.start.col) + ("-" + (String(self.end_.line) + ("," + String(self.end_.col))))));
  }
}

function toAtomRange(self) {
  var start = new Atom.Point(self.start.line - 1 | 0, self.start.col - 1 | 0);
  var end_ = new Atom.Point(self.end_.line - 1 | 0, self.end_.col - 1 | 0);
  return new Atom.Range(start, end_);
}

function decode$1(json) {
  return {
          start: Json_decode.field("start", decode, json),
          end_: Json_decode.field("end", decode, json)
        };
}

var Interval = {
  fuse: fuse,
  toString: toString,
  toAtomRange: toAtomRange,
  decode: decode$1
};

var partial_arg = /^(\S+)\:(?:(\d+)\,(\d+)\-(\d+)\,(\d+)|(\d+)\,(\d+)\-(\d+))$/;

function parse(param) {
  return Parser$AgdaMode.captures((function (captured) {
                var srcFile = Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 1));
                var sameRow = Rebase.$$Option.isSome(Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 6)));
                if (sameRow) {
                  return Rebase.$$Option.flatMap((function (row) {
                                return Rebase.$$Option.flatMap((function (colStart) {
                                              return Rebase.$$Option.flatMap((function (colEnd) {
                                                            return {
                                                                    _0: srcFile,
                                                                    _1: [{
                                                                        start: {
                                                                          pos: undefined,
                                                                          line: row,
                                                                          col: colStart
                                                                        },
                                                                        end_: {
                                                                          pos: undefined,
                                                                          line: row,
                                                                          col: colEnd
                                                                        }
                                                                      }],
                                                                    [Symbol.for("name")]: "Range"
                                                                  };
                                                          }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 8))));
                                            }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 7))));
                              }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 6))));
                } else {
                  return Rebase.$$Option.flatMap((function (rowStart) {
                                return Rebase.$$Option.flatMap((function (colStart) {
                                              return Rebase.$$Option.flatMap((function (rowEnd) {
                                                            return Rebase.$$Option.flatMap((function (colEnd) {
                                                                          return {
                                                                                  _0: srcFile,
                                                                                  _1: [{
                                                                                      start: {
                                                                                        pos: undefined,
                                                                                        line: rowStart,
                                                                                        col: colStart
                                                                                      },
                                                                                      end_: {
                                                                                        pos: undefined,
                                                                                        line: rowEnd,
                                                                                        col: colEnd
                                                                                      }
                                                                                    }],
                                                                                  [Symbol.for("name")]: "Range"
                                                                                };
                                                                        }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 5))));
                                                          }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 4))));
                                            }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 3))));
                              }), Rebase.$$Option.flatMap(Parser$AgdaMode.$$int, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, 2))));
                }
              }), partial_arg, param);
}

function fuse$1(a, b) {
  var mergeTouching = function (l, e, s, r) {
    return Rebase.List.concat(Rebase.List.concat(l, {
                    hd: {
                      start: e.start,
                      end_: s.end_
                    },
                    tl: /* [] */0
                  }), r);
  };
  var fuseSome = function (s1, r1, s2, r2) {
    var r1$prime = Util$AgdaMode.List_.dropWhile((function (x) {
            return Caml_obj.caml_lessequal(x.end_.pos, s2.end_.pos);
          }), r1);
    return helpFuse(r1$prime, {
                hd: fuse(s1, s2),
                tl: r2
              });
  };
  var outputLeftPrefix = function (s1, r1, s2, is2) {
    var match = Util$AgdaMode.List_.span((function (s) {
            return Caml_obj.caml_lessthan(s.end_.pos, s2.start.pos);
          }), r1);
    return Rebase.List.concat(Rebase.List.concat({
                    hd: s1,
                    tl: /* [] */0
                  }, match[0]), helpFuse(match[1], is2));
  };
  var helpFuse = function (a, b) {
    var match = Rebase.List.reverse(a);
    var match$1 = Rebase.List.reverse(b);
    if (!a) {
      return a;
    }
    if (!match) {
      if (b) {
        return Pervasives.failwith("something wrong with Range::fuse");
      } else {
        return b;
      }
    }
    if (!b) {
      if (b) {
        return Pervasives.failwith("something wrong with Range::fuse");
      } else {
        return b;
      }
    }
    if (!match$1) {
      return Pervasives.failwith("something wrong with Range::fuse");
    }
    var e2 = match$1.hd;
    var r2 = b.tl;
    var s2 = b.hd;
    var e1 = match.hd;
    var r1 = a.tl;
    var s1 = a.hd;
    if (Caml_obj.caml_lessthan(e1.end_.pos, s2.start.pos)) {
      return Rebase.List.concat(a, b);
    } else if (Caml_obj.caml_lessthan(e2.end_.pos, s1.start.pos)) {
      return Rebase.List.concat(b, a);
    } else if (e1.end_.pos === s2.start.pos) {
      return mergeTouching(match.tl, e1, s2, r2);
    } else if (e2.end_.pos === s1.start.pos) {
      return mergeTouching(match$1.tl, e2, s1, r1);
    } else if (Caml_obj.caml_lessthan(s1.end_.pos, s2.start.pos)) {
      return outputLeftPrefix(s1, r1, s2, b);
    } else if (Caml_obj.caml_lessthan(s2.end_.pos, s1.start.pos)) {
      return outputLeftPrefix(s2, r2, s1, a);
    } else if (Caml_obj.caml_lessthan(s1.end_.pos, s2.end_.pos)) {
      return fuseSome(s1, r1, s2, r2);
    } else {
      return fuseSome(s2, r2, s1, r1);
    }
  };
  if (a) {
    if (b) {
      return {
              _0: a._0,
              _1: Rebase.$$Array.fromList(helpFuse(Rebase.List.fromArray(a._1), Rebase.List.fromArray(b._1))),
              [Symbol.for("name")]: "Range"
            };
    } else {
      return a;
    }
  } else {
    return b;
  }
}

function toString$1(self) {
  if (!self) {
    return "";
  }
  var filepath = self._0;
  if (filepath !== undefined) {
    var xs = self._1;
    if (xs.length === 0) {
      return filepath;
    }
    var match = Rebase.$$Array.get(xs, 0);
    var match$1 = Rebase.$$Array.get(xs, Rebase.$$Array.length(xs) - 1 | 0);
    return filepath + (":" + (
              match !== undefined && match$1 !== undefined ? toString({
                      start: match.start,
                      end_: match$1.end_
                    }) : ""
            ));
  }
  var xs$1 = self._1;
  var match$2 = Rebase.$$Array.get(xs$1, 0);
  var match$3 = Rebase.$$Array.get(xs$1, Rebase.$$Array.length(xs$1) - 1 | 0);
  if (match$2 !== undefined && match$3 !== undefined) {
    return toString({
                start: match$2.start,
                end_: match$3.end_
              });
  } else {
    return "";
  }
}

function toAtomRanges(self) {
  if (self) {
    return Rebase.$$Array.map(toAtomRange, self._1);
  } else {
    return [];
  }
}

function decode$2(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "NoRange" :
                      return /* NoRange */0;
                  case "Range" :
                      return {
                              _0: Json_decode.field("source", (function (param) {
                                      return Json_decode.optional(Json_decode.string, param);
                                    }), json),
                              _1: Json_decode.field("intervals", (function (param) {
                                      return Json_decode.array(decode$1, param);
                                    }), json),
                              [Symbol.for("name")]: "Range"
                            };
                  default:
                    return Pervasives.failwith("unknown kind of Range");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

var $$Range = {
  parse: parse,
  fuse: fuse$1,
  toString: toString$1,
  toAtomRanges: toAtomRanges,
  decode: decode$2
};

exports.Position = Position;
exports.Interval = Interval;
exports.$$Range = $$Range;
/* atom Not a pure module */
