// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Path = require("path");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Parser__Type$AgdaMode = require("./Parser/Parser__Type.bs.js");

function toString(param) {
  if (param.tag) {
    return "Parse error code: R" + (String(param[0]) + (" \"" + (Parser__Type$AgdaMode.SExpression.toString(param[1]) + "\"")));
  } else {
    return "Parse error code: S" + (String(param[0]) + (" \"" + (param[1] + "\"")));
  }
}

var $$Error = {
  toString: toString
};

function captures(handler, regex, raw) {
  return Rebase.$$Option.flatMap(handler, Rebase.$$Option.map((function (result) {
                    return Rebase.$$Array.map((function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), result);
                  }), Caml_option.null_to_opt(regex.exec(raw))));
}

function at(captured, i, parser) {
  if (i >= Rebase.$$Array.length(captured)) {
    return ;
  } else {
    return Rebase.$$Option.flatMap(parser, Rebase.$$Option.flatten(Rebase.$$Array.get(captured, i)));
  }
}

function choice(res, raw) {
  return Rebase.$$Array.reduce((function (result, parse) {
                if (result !== undefined) {
                  return Caml_option.some(Caml_option.valFromOption(result));
                } else {
                  return Curry._1(parse, raw);
                }
              }), undefined, res);
}

function $$int(s) {
  var i;
  try {
    i = Caml_format.caml_int_of_string(s);
  }
  catch (exn){
    return ;
  }
  return i;
}

function userInput(s) {
  var s$1 = s.replace(/\\/g, "\\\\").replace(/\"/g, "\\\"").replace(/\n/g, "\\n");
  if (atom.config.get("agda-mode.trimSpaces")) {
    return Rebase.$$String.trim(s$1);
  } else {
    return s$1;
  }
}

function filepath(s) {
  var removedBidi = s.charCodeAt(0) === 8234.0 ? s.slice(1) : s;
  var normalized = Path.normalize(removedBidi);
  return normalized.replace(/\\/g, "/");
}

function agdaOutput(s) {
  return s.replace(/\\n/g, "\n");
}

function commandLine(s) {
  var parts = Rebase.List.fromArray(s.replace(/\s+/g, " ").split(" "));
  if (parts) {
    return /* tuple */[
            filepath(parts[0]),
            Rebase.$$Array.fromList(parts[1])
          ];
  } else {
    return /* tuple */[
            "",
            []
          ];
  }
}

var partial_arg = /\r\n|\n/;

var split = Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, (function (param) {
            return param.split(partial_arg);
          }), (function (param) {
            return Rebase.$$Array.map((function (param) {
                          if (param !== undefined) {
                            var chunk = param;
                            if (chunk === "") {
                              return ;
                            } else {
                              return chunk;
                            }
                          }
                          
                        }), param);
          })), (function (param) {
        return Rebase.$$Array.filterMap(Rebase.Fn.id, param);
      }));

function map(f, param) {
  if (param) {
    return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [Curry._1(f, param[0])]);
  } else {
    return /* Stop */0;
  }
}

function tap(f, param) {
  if (param) {
    var x = param[0];
    Curry._1(f, x);
    return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [x]);
  } else {
    return /* Stop */0;
  }
}

function flatMap(f, param) {
  if (param) {
    return Curry._1(f, param[0]);
  } else {
    return /* Stop */0;
  }
}

var $$Event = {
  map: map,
  tap: tap,
  flatMap: flatMap
};

function make(initialContinuation, callback) {
  return {
          initialContinuation: initialContinuation,
          continuation: {
            contents: undefined
          },
          callback: callback
        };
}

function feed(self, input) {
  var $$continue = Rebase.$$Option.getOr(self.initialContinuation, self.continuation.contents);
  var match = Curry._1($$continue, input);
  switch (match.tag | 0) {
    case /* Error */0 :
        return Curry._1(self.callback, /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [/* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]])]));
    case /* Continue */1 :
        self.continuation.contents = match[0];
        return /* () */0;
    case /* Done */2 :
        Curry._1(self.callback, /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match[0]])]));
        self.continuation.contents = undefined;
        return /* () */0;
    
  }
}

function stop(self) {
  return Curry._1(self.callback, /* Stop */0);
}

var Incr = {
  $$Event: $$Event,
  make: make,
  feed: feed,
  stop: stop
};

var toString$1 = Parser__Type$AgdaMode.SExpression.toString;

function preprocess(string) {
  if (string.substring(0, 13) === "cannot read: ") {
    return /* Error */Caml_chrome_debugger.variant("Error", 1, [string.slice(12)]);
  } else {
    return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [string]);
  }
}

function flatten(param) {
  if (param.tag) {
    return Rebase.$$Array.flatMap(flatten, param[0]);
  } else {
    return [param[0]];
  }
}

function parseWithContinuation(string) {
  var parseSExpression = function (state, string) {
    var in_str = state.in_str;
    var escaped = state.escaped;
    var word = state.word;
    var stack = state.stack;
    var pushToTheTop = function (elem) {
      var index = Rebase.$$Array.length(stack) - 1 | 0;
      var match = Rebase.$$Array.get(stack, index);
      if (match !== undefined) {
        var expr = match;
        var match$1 = expr.contents;
        if (match$1.tag) {
          match$1[0].push(elem);
          return /* () */0;
        } else {
          expr.contents = /* L */Caml_chrome_debugger.variant("L", 1, [[
                expr.contents,
                elem
              ]]);
          return /* () */0;
        }
      } else {
        return /* () */0;
      }
    };
    var totalLength = Rebase.$$String.length(string);
    for(var i = 0 ,i_finish = totalLength - 1 | 0; i <= i_finish; ++i){
      var $$char = string.charAt(i);
      if (escaped.contents) {
        if ($$char === "n") {
          word.contents = word.contents + "\\";
        }
        word.contents = word.contents + $$char;
        escaped.contents = false;
      } else if (!($$char === "'" && !in_str.contents)) {
        if ($$char === "(" && !in_str.contents) {
          stack.push({
                contents: /* L */Caml_chrome_debugger.variant("L", 1, [[]])
              });
        } else if ($$char === ")" && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop(/* A */Caml_chrome_debugger.variant("A", 0, [word.contents]));
            word.contents = "";
          }
          var match = stack.pop();
          if (match !== undefined) {
            pushToTheTop(match.contents);
          }
          
        } else if ($$char === " " && !in_str.contents) {
          if (word.contents !== "") {
            pushToTheTop(/* A */Caml_chrome_debugger.variant("A", 0, [word.contents]));
            word.contents = "";
          }
          
        } else if ($$char === "\"") {
          in_str.contents = !in_str.contents;
        } else if ($$char === "\\" && in_str.contents) {
          escaped.contents = true;
        } else {
          word.contents = word.contents + $$char;
        }
      }
      
    }
    var match$1 = Rebase.$$Array.length(stack);
    if (match$1 !== 0) {
      if (match$1 !== 1) {
        return /* Continue */Caml_chrome_debugger.variant("Continue", 1, [(function (param) {
                      return parseSExpression(state, param);
                    })]);
      } else {
        var match$2 = Rebase.$$Array.get(stack, 0);
        if (match$2 !== undefined) {
          var match$3 = match$2.contents;
          if (match$3.tag) {
            var match$4 = Rebase.$$Array.get(match$3[0], 0);
            if (match$4 !== undefined) {
              return /* Done */Caml_chrome_debugger.variant("Done", 2, [match$4]);
            } else {
              return /* Continue */Caml_chrome_debugger.variant("Continue", 1, [(function (param) {
                            return parseSExpression(state, param);
                          })]);
            }
          } else {
            return /* Error */Caml_chrome_debugger.variant("Error", 0, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                          3,
                          string
                        ])]);
          }
        } else {
          return /* Error */Caml_chrome_debugger.variant("Error", 0, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                        1,
                        string
                      ])]);
        }
      }
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 0, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                    0,
                    string
                  ])]);
    }
  };
  var initialState = function (param) {
    return {
            stack: [{
                contents: /* L */Caml_chrome_debugger.variant("L", 1, [[]])
              }],
            word: {
              contents: ""
            },
            escaped: {
              contents: false
            },
            in_str: {
              contents: false
            }
          };
  };
  var match = preprocess(string);
  if (match.tag) {
    return /* Error */Caml_chrome_debugger.variant("Error", 0, [/* SExpression */Caml_chrome_debugger.variant("SExpression", 0, [
                  4,
                  string
                ])]);
  } else {
    return parseSExpression(initialState(/* () */0), match[0]);
  }
}

function parse(input) {
  var resultAccum = {
    contents: []
  };
  var continuation = {
    contents: undefined
  };
  Rebase.$$Array.forEach((function (line) {
          var $$continue = Rebase.$$Option.getOr(parseWithContinuation, continuation.contents);
          var match = Curry._1($$continue, line);
          switch (match.tag | 0) {
            case /* Error */0 :
                resultAccum.contents.push(/* Error */Caml_chrome_debugger.variant("Error", 1, [match[0]]));
                return /* () */0;
            case /* Continue */1 :
                continuation.contents = match[0];
                return /* () */0;
            case /* Done */2 :
                resultAccum.contents.push(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [match[0]]));
                continuation.contents = undefined;
                return /* () */0;
            
          }
        }), Curry._1(split, input));
  return resultAccum.contents;
}

function makeIncr(callback) {
  return make(parseWithContinuation, callback);
}

var SExpression = {
  toString: toString$1,
  preprocess: preprocess,
  flatten: flatten,
  parseWithContinuation: parseWithContinuation,
  parse: parse,
  makeIncr: makeIncr
};

exports.$$Error = $$Error;
exports.captures = captures;
exports.at = at;
exports.choice = choice;
exports.$$int = $$int;
exports.userInput = userInput;
exports.filepath = filepath;
exports.agdaOutput = agdaOutput;
exports.commandLine = commandLine;
exports.split = split;
exports.Incr = Incr;
exports.SExpression = SExpression;
/* split Not a pure module */
