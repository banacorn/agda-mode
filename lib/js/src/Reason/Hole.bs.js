// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function make(raw) {
  return /* array */[/* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              raw,
              [
                0,
                Rebase.$$String[/* length */1](raw)
              ],
              0
            ])];
}

function lex(regex, source, target, self) {
  var f = function (token) {
    if (token[/* type_ */2] === source) {
      var cursor = /* record */Block.record(["contents"], [token[/* range */1][0]]);
      return Rebase.$$Array[/* map */0]((function (content) {
                    var match = regex.test(content);
                    var type_ = match ? target : source;
                    var cursorOld = cursor[0];
                    cursor[0] = cursor[0] + Rebase.$$String[/* length */1](content) | 0;
                    return /* record */Block.record([
                              "content",
                              "range",
                              "type_"
                            ], [
                              content,
                              [
                                cursorOld,
                                cursor[0]
                              ],
                              type_
                            ]);
                  }), Rebase.$$Array[/* filterMap */23]((function (x) {
                        return x;
                      }), token[/* content */0].split(regex)));
    } else {
      return /* array */[token];
    }
  };
  return Rebase.$$Array[/* flatMap */5](f, self);
}

function map(f, self) {
  var delta = /* record */Block.record(["contents"], [0]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var match = Curry._1(f, token);
                var content = match[/* content */0];
                var match$1 = token[/* range */1];
                var lengthDiff = Rebase.$$String[/* length */1](content) - Rebase.$$String[/* length */1](token[/* content */0]) | 0;
                var result_001 = /* range : tuple */[
                  match$1[0] + delta[0] | 0,
                  (match$1[1] + delta[0] | 0) + lengthDiff | 0
                ];
                var result_002 = /* type_ */match[/* type_ */2];
                var result = /* record */Block.record([
                    "content",
                    "range",
                    "type_"
                  ], [
                    content,
                    result_001,
                    result_002
                  ]);
                delta[0] = delta[0] + lengthDiff | 0;
                return result;
              }), self);
}

function mapOnly(type_, f, self) {
  return map((function (token) {
                var match = token[/* type_ */2] === type_;
                if (match) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = /* module */Block.localModule([
    "make",
    "lex",
    "map",
    "mapOnly"
  ], [
    make,
    lex,
    map,
    mapOnly
  ]);

var texBegin = (/\\begin\{code\}.*/);

var texEnd = (/\\end\{code\}.*/);

var markdown = (/\`\`\`(agda)?/);

var comment = (/(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/);

var goalBracket = (/(\{\!(?:(?!\!\})(?:.|\s))*\!\})/);

var goalQuestionMarkRaw = (/([\s\(\{\_\;\.\"@]\?)/);

var goalQuestionMark = (/(\?)/);

var goalBracketContent = (/\{\!((?:(?!\!\})(?:.|\s))*)\!\}/);

var Regex = /* module */Block.localModule([
    "texBegin",
    "texEnd",
    "markdown",
    "comment",
    "goalBracket",
    "goalQuestionMarkRaw",
    "goalQuestionMark",
    "goalBracketContent"
  ], [
    texBegin,
    texEnd,
    markdown,
    comment,
    goalBracket,
    goalQuestionMarkRaw,
    goalQuestionMark,
    goalBracketContent
  ]);

function isHole(token) {
  var match = token[/* type_ */2];
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

function toLines(raw) {
  var cursor = /* record */Block.record(["contents"], [0]);
  return Rebase.Option[/* mapOr */18]((function (lines) {
                return Rebase.$$Array[/* map */0]((function (line) {
                              var cursorOld = cursor[0];
                              cursor[0] = cursor[0] + Rebase.$$String[/* length */1](line) | 0;
                              return /* record */Block.record([
                                        "content",
                                        "range",
                                        "type_"
                                      ], [
                                        raw.substring(cursorOld, cursor[0]),
                                        [
                                          cursorOld,
                                          cursor[0]
                                        ],
                                        1
                                      ]);
                            }), Rebase.$$Array[/* filter */10]((function (x) {
                                  return !Rebase.$$String[/* isEmpty */5](x);
                                }), lines));
              }), /* array */[], Caml_option.null_to_opt(raw.match((/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g))));
}

function filterOutTex(raw) {
  var insideAgda = /* record */Block.record(["contents"], [false]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var content = token[/* content */0];
                if (texEnd.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (texBegin.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Block.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function filterOutMarkdown(raw) {
  var insideAgda = /* record */Block.record(["contents"], [false]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var content = token[/* content */0];
                if (insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (!insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Block.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function parse(raw, indices, fileType) {
  var i = /* record */Block.record(["contents"], [0]);
  var preprocessed;
  if (fileType !== 0) {
    switch (fileType - 1 | 0) {
      case 0 : 
          preprocessed = filterOutTex(raw);
          break;
      case 1 : 
          preprocessed = make(raw);
          break;
      case 2 : 
          preprocessed = filterOutMarkdown(raw);
          break;
      
    }
  } else {
    preprocessed = make(raw);
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return /* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              "{!   !}",
              token[/* range */1],
              3
            ]);
  };
  var adjustGoalBracket = function (token) {
    var match = Rebase.$$Array[/* get */17](indices, i[0]);
    var goalIndex = match !== undefined ? String(match) : "*";
    var requiredSpaces = Rebase.$$String[/* length */1](goalIndex);
    var content = Rebase.Option[/* getOr */16]("", Rebase.Option[/* flatMap */5]((function (result) {
                return Rebase.Option[/* flatten */20](Rebase.Option[/* map */0]((function (prim) {
                                  if (prim == null) {
                                    return undefined;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), Rebase.$$Array[/* get */17](result, 1)));
              }), Caml_option.null_to_opt(goalBracketContent.exec(token[/* content */0]))));
    var actualSpaces = Rebase.Option[/* getOr */16](0, Rebase.Option[/* flatMap */5]((function (matches) {
                return Rebase.Option[/* map */0](Rebase.$$String[/* length */1], Rebase.$$Array[/* get */17](matches, 0));
              }), Caml_option.null_to_opt(content.match((/\s*$/)))));
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token[/* content */0].replace((/\{!.*!\}/), "{!" + (content + (padding + "!}")));
    } else {
      newContent = token[/* content */0];
    }
    i[0] = i[0] + 1 | 0;
    return /* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              newContent,
              [
                1,
                2
              ],
              3
            ]);
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Rebase.$$Array[/* filter */10](isHole, original);
  var modifiedHoles = Rebase.$$Array[/* filter */10](isHole, modified);
  return Rebase.$$Array[/* filterMap */23]((function (x) {
                return x;
              }), Rebase.$$Array[/* mapi */27]((function (token, idx) {
                    var match = Rebase.$$Array[/* get */17](modifiedHoles, idx);
                    var match$1 = Rebase.$$Array[/* get */17](indices, idx);
                    if (match !== undefined && match$1 !== undefined) {
                      var modifiedHole = match;
                      var match$2 = modifiedHole[/* range */1];
                      var start = match$2[0];
                      return /* record */Block.record([
                                "index",
                                "modifiedRange",
                                "originalRange",
                                "content"
                              ], [
                                match$1,
                                modifiedHole[/* range */1],
                                [
                                  start,
                                  start + Rebase.$$String[/* length */1](token[/* content */0]) | 0
                                ],
                                modifiedHole[/* content */0]
                              ]);
                    }
                    
                  }), originalHoles));
}

exports.Lexer = Lexer;
exports.Regex = Regex;
exports.isHole = isHole;
exports.toLines = toLines;
exports.filterOutTex = filterOutTex;
exports.filterOutMarkdown = filterOutMarkdown;
exports.parse = parse;
/* texBegin Not a pure module */
