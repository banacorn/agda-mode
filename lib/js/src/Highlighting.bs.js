// Generated by BUCKLESCRIPT VERSION 5.0.1, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function parse(param) {
  if (param.tag) {
    var xs = param[0];
    var exit = 0;
    var len = xs.length;
    if (len >= 7) {
      exit = 1;
    } else {
      switch (len) {
        case 3 : 
            var match = xs[0];
            if (match.tag) {
              exit = 1;
            } else {
              var match$1 = xs[1];
              if (match$1.tag) {
                exit = 1;
              } else {
                var types = xs[2];
                return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                              "start",
                              "end_",
                              "types",
                              "source"
                            ], [
                              Caml_format.caml_int_of_string(match[0]),
                              Caml_format.caml_int_of_string(match$1[0]),
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](types),
                              undefined
                            ])]);
              }
            }
            break;
        case 4 : 
            var match$2 = xs[0];
            if (match$2.tag) {
              exit = 1;
            } else {
              var match$3 = xs[1];
              if (match$3.tag) {
                exit = 1;
              } else {
                var types$1 = xs[2];
                return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                              "start",
                              "end_",
                              "types",
                              "source"
                            ], [
                              Caml_format.caml_int_of_string(match$2[0]),
                              Caml_format.caml_int_of_string(match$3[0]),
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](types$1),
                              undefined
                            ])]);
              }
            }
            break;
        case 0 : 
        case 1 : 
        case 2 : 
        case 5 : 
            exit = 1;
            break;
        case 6 : 
            var match$4 = xs[0];
            if (match$4.tag) {
              exit = 1;
            } else {
              var match$5 = xs[1];
              if (match$5.tag) {
                exit = 1;
              } else {
                var types$2 = xs[2];
                var match$6 = xs[5];
                if (match$6.tag) {
                  var match$7 = match$6[0];
                  if (match$7.length !== 3) {
                    exit = 1;
                  } else {
                    var match$8 = match$7[0];
                    if (match$8.tag) {
                      exit = 1;
                    } else {
                      var match$9 = match$7[2];
                      if (match$9.tag) {
                        exit = 1;
                      } else {
                        return /* Ok */Block.variant("Ok", 0, [/* record */Block.record([
                                      "start",
                                      "end_",
                                      "types",
                                      "source"
                                    ], [
                                      Caml_format.caml_int_of_string(match$4[0]),
                                      Caml_format.caml_int_of_string(match$5[0]),
                                      Emacs__Parser$AgdaMode.SExpression[/* flatten */2](types$2),
                                      /* tuple */[
                                        match$8[0],
                                        Caml_format.caml_int_of_string(match$9[0])
                                      ]
                                    ])]);
                      }
                    }
                  }
                } else {
                  exit = 1;
                }
              }
            }
            break;
        
      }
    }
    if (exit === 1) {
      return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* L */Block.variant("L", 1, [xs]))]);
    }
    
  } else {
    return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* A */Block.variant("A", 0, [param[0]]))]);
  }
}

function parseDirectHighlighting(tokens) {
  return Rebase.$$Array[/* filterMap */23](Rebase.$$Option[/* fromResult */12], Rebase.$$Array[/* map */0](parse, tokens.slice(2)));
}

function parseIndirectHighlighting(tokens) {
  return Rebase.$$Array[/* filterMap */23](Rebase.$$Option[/* fromResult */12], Rebase.$$Array[/* map */0](parse, tokens.slice(1)));
}

function shouldHighlight(annotation) {
  if (annotation[/* types */2].includes("unsolvedmeta") || annotation[/* types */2].includes("unsolvedconstraint") || annotation[/* types */2].includes("terminationproblem")) {
    return true;
  } else {
    return annotation[/* types */2].includes("coverageproblem");
  }
}

var Annotation = /* module */Block.localModule([
    "parse",
    "parseDirectHighlighting",
    "parseIndirectHighlighting",
    "shouldHighlight"
  ], [
    parse,
    parseDirectHighlighting,
    parseIndirectHighlighting,
    shouldHighlight
  ]);

var Token = 0;

exports.Token = Token;
exports.Annotation = Annotation;
/* Emacs__Parser-AgdaMode Not a pure module */
