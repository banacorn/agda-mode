// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Goal$AgdaMode = require("../Goal.bs.js");
var Parser$AgdaMode = require("../Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function getPath(instance) {
  return Parser$AgdaMode.filepath(Rebase.$$Option.getOr("untitled", instance[/* editors */1][/* source */1].getPath()));
}

function pointingAt(cursor, instance) {
  var cursor_ = cursor !== undefined ? Caml_option.valFromOption(cursor) : instance[/* editors */1][/* source */1].getCursorBufferPosition();
  var pointedGoals = Rebase.$$Array.filter((function (goal) {
          return goal[/* range */2].containsPoint(cursor_);
        }), instance[/* goals */5]);
  return Rebase.$$Array.get(pointedGoals, 0);
}

function getPointedGoal(instance) {
  var pointed = pointingAt(undefined, instance);
  if (pointed !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [pointed]));
  } else {
    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* OutOfGoal */2]));
  }
}

function getPointedGoalAt(cursor, instance) {
  var pointed = pointingAt(Caml_option.some(cursor), instance);
  if (pointed !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [pointed]));
  } else {
    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* OutOfGoal */2]));
  }
}

function handleOutOfGoal(promise, callback) {
  return $$Promise.flatMapError(promise, (function (error) {
                if (typeof error === "number" && error >= 2) {
                  return Curry._1(callback, /* () */0);
                } else {
                  return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [error]));
                }
              }));
}

function getGoalIndex(goal) {
  var match = goal[/* index */1];
  if (match !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                    goal,
                    match
                  ]]));
  } else {
    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* GoalNotIndexed */1]));
  }
}

function restoreCursorPosition(callback, instance) {
  var originalPosition = instance[/* editors */1][/* source */1].getCursorBufferPosition();
  console.log(" ~~~~~ SAVE ", originalPosition);
  var result = Curry._1(callback, /* () */0);
  handleOutOfGoal($$Promise.mapOk(getPointedGoalAt(originalPosition, instance), (function (goal) {
              if (Goal$AgdaMode.isEmpty(goal)) {
                var delta = new Atom.Point(0, 3);
                var newPosition = goal[/* range */2].start.translate(delta);
                console.log(" MOVE (EMPTY) ", newPosition, goal[/* index */1]);
                setTimeout((function (param) {
                        instance[/* editors */1][/* source */1].setCursorBufferPosition(newPosition);
                        return /* () */0;
                      }), 0);
                return /* () */0;
              } else {
                console.log(" RESTORE (FILLED) ", originalPosition, goal[/* range */2]);
                instance[/* editors */1][/* source */1].setCursorBufferPosition(originalPosition);
                return /* () */0;
              }
            })), (function (param) {
          console.log(" RESTORE (OUTSIDE) ", originalPosition);
          instance[/* editors */1][/* source */1].setCursorBufferPosition(originalPosition);
          return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
        }));
  return result;
}

function restoreCursorPosition2(callback, instance) {
  var originalPosition = instance[/* editors */1][/* source */1].getCursorBufferPosition();
  console.log(" ~~~~~ SAVE ", originalPosition);
  $$Promise.get(Curry._1(callback, /* () */0), (function (param) {
          return /* () */0;
        }));
  handleOutOfGoal($$Promise.mapOk(getPointedGoalAt(originalPosition, instance), (function (goal) {
              if (Goal$AgdaMode.isEmpty(goal)) {
                var delta = new Atom.Point(0, 3);
                var newPosition = goal[/* range */2].start.translate(delta);
                console.log(" MOVE (EMPTY) ", newPosition, goal[/* index */1]);
                setTimeout((function (param) {
                        instance[/* editors */1][/* source */1].setCursorBufferPosition(newPosition);
                        return /* () */0;
                      }), 0);
                return /* () */0;
              } else {
                console.log(" RESTORE (FILLED) ", originalPosition, goal[/* range */2]);
                instance[/* editors */1][/* source */1].setCursorBufferPosition(originalPosition);
                return /* () */0;
              }
            })), (function (param) {
          console.log(" RESTORE (OUTSIDE) ", originalPosition);
          instance[/* editors */1][/* source */1].setCursorBufferPosition(originalPosition);
          return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* () */0]));
        }));
  return /* () */0;
}

function startCheckpoint(command, instance) {
  var checkpoint = instance[/* editors */1][/* source */1].createCheckpoint();
  instance[/* history */3][/* checkpoints */0].push(checkpoint);
  if (Rebase.$$Array.length(instance[/* history */3][/* checkpoints */0]) === 1) {
    instance[/* history */3][/* needsReloading */1] = typeof command === "number" ? (
        command >= 13 ? command < 17 : command === 6
      ) : false;
    return /* () */0;
  } else {
    return 0;
  }
}

function endCheckpoint(instance) {
  var checkpoint = instance[/* history */3][/* checkpoints */0].pop();
  if (Rebase.$$Array.length(instance[/* history */3][/* checkpoints */0]) === 0) {
    Rebase.$$Option.forEach((function (n) {
            instance[/* editors */1][/* source */1].groupChangesSinceCheckpoint(n);
            return /* () */0;
          }), checkpoint === undefined ? undefined : Caml_option.some(checkpoint));
  }
  return /* () */0;
}

exports.getPath = getPath;
exports.pointingAt = pointingAt;
exports.getPointedGoal = getPointedGoal;
exports.getPointedGoalAt = getPointedGoalAt;
exports.handleOutOfGoal = handleOutOfGoal;
exports.getGoalIndex = getGoalIndex;
exports.restoreCursorPosition = restoreCursorPosition;
exports.restoreCursorPosition2 = restoreCursorPosition2;
exports.startCheckpoint = startCheckpoint;
exports.endCheckpoint = endCheckpoint;
/* atom Not a pure module */
