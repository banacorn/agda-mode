// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Atom = require("atom");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("./Util.bs.js");
var View$AgdaMode = require("./View.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Command$AgdaMode = require("./Command.bs.js");
var Editors$AgdaMode = require("./Editors.bs.js");
var Connection$AgdaMode = require("./Connection.bs.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function make(textEditor) {
  var editors = Editors$AgdaMode.make(textEditor);
  return /* record */Block.record([
            "editors",
            "view",
            "connection"
          ], [
            editors,
            View$AgdaMode.initialize(editors),
            undefined
          ]);
}

function activate(self) {
  return Util$AgdaMode.Event[/* resolve */9](true, self[/* view */1][/* activatePanel */4]);
}

function connect(self) {
  var queryConnection = function (error, self) {
    activate(self);
    var p = Util$AgdaMode.$$Promise[/* then_ */6]((function (param) {
            Util$AgdaMode.Event[/* resolve */9](/* Connection */1, self[/* view */1][/* navigateSettingsView */11]);
            var promise = Util$AgdaMode.Event[/* once */8](self[/* view */1][/* onInquireConnection */7]);
            Util$AgdaMode.Event[/* resolve */9](/* tuple */[
                  error,
                  ""
                ], self[/* view */1][/* inquireConnection */6]);
            return promise;
          }), Util$AgdaMode.Event[/* once */8](self[/* view */1][/* onSettingsView */10]));
    Util$AgdaMode.Event[/* resolve */9](true, self[/* view */1][/* activateSettingsView */9]);
    return p;
  };
  var getAgdaPath = function (param) {
    var storedPath = Parser$AgdaMode.filepath(atom.config.get("agda-mode.agdaPath"));
    if (Rebase.$$String[/* isEmpty */5](storedPath)) {
      return Connection$AgdaMode.autoSearch("agda");
    } else {
      return Promise.resolve(storedPath);
    }
  };
  var getMetadata = function (self, path) {
    return Util$AgdaMode.$$Promise[/* catch */7]((function (param) {
                  return Connection$AgdaMode.handleValidationError((function (err) {
                                return Util$AgdaMode.$$Promise[/* then_ */6]((function (param) {
                                              return getMetadata(self, param);
                                            }), queryConnection(/* Validation */Block.variant("Validation", 1, [
                                                  path,
                                                  err
                                                ]), self));
                              }), param);
                }), Connection$AgdaMode.validateAndMake(path));
  };
  var match = self[/* connection */2];
  if (match !== undefined) {
    return Util$AgdaMode.$$Promise[/* resolve */1](match);
  } else {
    return Util$AgdaMode.$$Promise[/* then_ */6](Connection$AgdaMode.wire, Util$AgdaMode.$$Promise[/* then_ */6]((function (param) {
                      var self$1 = self;
                      var connection = param;
                      self$1[/* connection */2] = connection;
                      atom.config.set("agda-mode.agdaPath", connection[/* metadata */0][/* path */0]);
                      Util$AgdaMode.Event[/* resolve */9](connection, self$1[/* view */1][/* updateConnection */5]);
                      return Util$AgdaMode.$$Promise[/* resolve */1](connection);
                    }), Util$AgdaMode.$$Promise[/* then_ */6](Connection$AgdaMode.connect, Util$AgdaMode.$$Promise[/* then_ */6]((function (param) {
                              return getMetadata(self, param);
                            }), Util$AgdaMode.$$Promise[/* catch */7]((function (param) {
                                  return Connection$AgdaMode.handleAutoSearchError((function (err) {
                                                return queryConnection(/* AutoSearch */Block.variant("AutoSearch", 0, [err]), self);
                                              }), param);
                                }), getAgdaPath(/* () */0))))));
  }
}

function disconnect(self) {
  var match = self[/* connection */2];
  if (match !== undefined) {
    return Connection$AgdaMode.disconnect(match);
  } else {
    return /* () */0;
  }
}

function getConnection(self) {
  var match = self[/* connection */2];
  if (match !== undefined) {
    return Util$AgdaMode.$$Promise[/* resolve */1](match);
  } else {
    return connect(self);
  }
}

function deactivate(self) {
  return Util$AgdaMode.Event[/* resolve */9](false, self[/* view */1][/* activatePanel */4]);
}

function destroy(self) {
  deactivate(self);
  return Curry._1(self[/* view */1][/* destroy */12][0], /* () */0);
}

function prepareCommand(command, self) {
  var prepare = function (command, self) {
    return Util$AgdaMode.$$Promise[/* then_ */6]((function (connection) {
                  return Util$AgdaMode.$$Promise[/* resolve */1](/* record */Block.record([
                                "connection",
                                "filepath",
                                "command"
                              ], [
                                connection,
                                self[/* editors */0][/* source */1].getPath(),
                                command
                              ]));
                }), getConnection(self));
  };
  if (typeof command === "number") {
    switch (command) {
      case 0 : 
          return prepare(/* Load */0, self);
      case 1 : 
          disconnect(self);
          return Util$AgdaMode.$$Promise[/* resolve */1](undefined);
      case 2 : 
          disconnect(self);
          return prepare(/* Load */0, self);
      default:
        return prepare(/* Load */0, self);
    }
  } else if (command.tag === 8) {
    var enabled = atom.config.get("agda-mode.inputMethod");
    if (enabled) {
      switch (command[0]) {
        case 0 : 
            Util$AgdaMode.Event[/* resolve */9](true, self[/* view */1][/* activatePanel */4]);
            Util$AgdaMode.Event[/* resolve */9](true, self[/* view */1][/* activateInputMethod */13]);
            break;
        case 1 : 
            Util$AgdaMode.Event[/* resolve */9]("{", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        case 2 : 
            Util$AgdaMode.Event[/* resolve */9]("[", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        case 3 : 
            Util$AgdaMode.Event[/* resolve */9]("(", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        case 4 : 
            Util$AgdaMode.Event[/* resolve */9]("\"", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        case 5 : 
            Util$AgdaMode.Event[/* resolve */9]("'", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        case 6 : 
            Util$AgdaMode.Event[/* resolve */9]("`", self[/* view */1][/* interceptAndInsertKey */14]);
            break;
        
      }
    } else {
      Editors$AgdaMode.Focus[/* get */0](self[/* editors */0]).insertText("\\");
    }
    return Util$AgdaMode.$$Promise[/* resolve */1](undefined);
  } else {
    return prepare(/* Load */0, self);
  }
}

function dispatch(command, self) {
  return Util$AgdaMode.$$Promise[/* then_ */6]((function (prepared) {
                if (prepared !== undefined) {
                  var cmd = prepared;
                  var s = Command$AgdaMode.Packed[/* serialize */0](cmd);
                  return Util$AgdaMode.$$Promise[/* map */0](Rebase.Option[/* some */11], Connection$AgdaMode.send(s, cmd[/* connection */0]));
                } else {
                  return Util$AgdaMode.$$Promise[/* resolve */1](undefined);
                }
              }), prepareCommand(command, self));
}

function dispatchUndo(_self) {
  console.log("Undo");
  return /* () */0;
}

var Instance = /* module */Block.localModule([
    "make",
    "activate",
    "connect",
    "disconnect",
    "getConnection",
    "deactivate",
    "destroy",
    "prepareCommand",
    "dispatch",
    "dispatchUndo"
  ], [
    make,
    activate,
    connect,
    disconnect,
    getConnection,
    deactivate,
    destroy,
    prepareCommand,
    dispatch,
    dispatchUndo
  ]);

var instances = { };

function get(textEditor) {
  var id = String(textEditor.id);
  return Js_dict.get(instances, id);
}

function getThen(f, textEditor) {
  return Rebase.Option[/* forEach */8](f, get(textEditor));
}

function add(textEditor) {
  var id = String(textEditor.id);
  var match = get(textEditor);
  if (match !== undefined) {
    return /* () */0;
  } else {
    instances[id] = make(textEditor);
    return /* () */0;
  }
}

function remove(textEditor) {
  var id = String(textEditor.id);
  var match = Js_dict.get(instances, id);
  if (match !== undefined) {
    destroy(match);
    return (delete instances[id]);
  } else {
    return /* () */0;
  }
}

function contains(textEditor) {
  return get(textEditor) !== undefined;
}

var Instances = /* module */Block.localModule([
    "get",
    "getThen",
    "add",
    "remove",
    "contains"
  ], [
    get,
    getThen,
    add,
    remove,
    contains
  ]);

function isAgdaFile(textEditor) {
  var filepath = textEditor.getPath();
  var onWindows = Os.type() === "Windows_NT";
  if (onWindows) {
    return (/\.agda$|\.lagda$/i).test(filepath);
  } else {
    return (/\.agda$|\.lagda$/).test(filepath);
  }
}

var subscriptions = new Atom.CompositeDisposable();

function onEditorActivationChange(param) {
  var previous = /* record */Block.record(["contents"], [atom.workspace.getActiveTextEditor()]);
  subscriptions.add(atom.workspace.onDidChangeActiveTextEditor((function (next) {
              Rebase.Option[/* forEach */8]((function (param) {
                      return getThen(deactivate, param);
                    }), previous[0]);
              if (next !== undefined) {
                var nextEditor = Caml_option.valFromOption(next);
                getThen(activate, nextEditor);
                previous[0] = Caml_option.some(nextEditor);
                return /* () */0;
              } else {
                return /* () */0;
              }
            })));
  return /* () */0;
}

function onTriggerCommand(param) {
  return Rebase.$$Array[/* forEach */8]((function (command) {
                subscriptions.add(atom.commands.add("atom-text-editor", "agda-mode:" + command, (function (_event) {
                            return Rebase.Option[/* forEach */8]((function (self) {
                                          console.log("triggering: " + command);
                                          dispatch(Command$AgdaMode.Bare[/* parse */0](command), self).then((function (result) {
                                                  return Promise.resolve(Rebase.Option[/* forEach */8]((function (x) {
                                                                    console.log(Rebase.$$Array[/* map */0](Emacs__Parser$AgdaMode.SExpression[/* parse */4], Rebase.$$Array[/* map */0]((function (x) {
                                                                                    return x.trim();
                                                                                  }), x.split("\n"))));
                                                                    return /* () */0;
                                                                  }), result));
                                                }));
                                          return /* () */0;
                                        }), Rebase.Option[/* flatMap */5](get, atom.workspace.getActiveTextEditor()));
                          })));
                return /* () */0;
              }), Command$AgdaMode.names);
}

function onUndo(param) {
  subscriptions.add(atom.commands.add("atom-text-editor", "core:undo", (function ($$event) {
              $$event.stopImmediatePropagation();
              var activated = atom.workspace.getActiveTextEditor();
              return Rebase.Option[/* forEach */8](dispatchUndo, activated);
            })));
  return /* () */0;
}

function activate$1(param) {
  subscriptions.add(atom.workspace.observeTextEditors((function (textEditor) {
              var textEditorSubscriptions = new Atom.CompositeDisposable();
              if (isAgdaFile(textEditor)) {
                add(textEditor);
              }
              textEditorSubscriptions.add(textEditor.onDidChangePath((function (param) {
                          if (!isAgdaFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          if (isAgdaFile(textEditor) && !contains(textEditor)) {
                            return add(textEditor);
                          } else {
                            return 0;
                          }
                        })));
              textEditorSubscriptions.add(textEditor.onDidDestroy((function (param) {
                          if (isAgdaFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          textEditorSubscriptions.dispose();
                          return /* () */0;
                        })));
              return /* () */0;
            })));
  onEditorActivationChange(/* () */0);
  onTriggerCommand(/* () */0);
  return onUndo(/* () */0);
}

function deactivate$1(param) {
  subscriptions.dispose();
  return /* () */0;
}

var config = {
  agdaPath: {
    title: "Agda",
    description: "Path to the executable of Agda, automatically inferred when possible. Overwrite to override.",
    type: "string",
    default: "",
    order: 1
  },
  enableJSONProtocol: {
    title: "Enable the JSON protocol (experimental)",
    description: "Demand Agda to output in JSON format when possible",
    type: "boolean",
    default: false,
    order: 2
  },
  libraryPath: {
    title: "Libraries",
    description: "Paths to include (such as agda-stdlib), seperate with comma. Useless after Agda 2.5.0",
    type: "array",
    default: /* array */[],
    items: {
      type: "string"
    },
    order: 5
  },
  backend: {
    title: "Backend",
    description: "The backend which is used to compile Agda programs.",
    type: "string",
    default: "GHCNoMain",
    enum: /* array */[
      "GHC",
      "GHCNoMain"
    ],
    order: 10
  },
  highlightingMethod: {
    title: "Highlighting information passing",
    description: "Receive parsed result from Agda, directly from stdio, or indirectly from temporary files (which requires frequent disk access)",
    type: "string",
    default: "Direct",
    enum: /* array */[
      "Indirect",
      "Direct"
    ],
    order: 20
  },
  maxBodyHeight: {
    title: "Max panel size",
    description: "The max height the panel could strech",
    type: "integer",
    default: 170,
    minimum: 40,
    maximum: 1010,
    order: 30
  },
  inputMethod: {
    title: "Input Method",
    description: "Enable input method",
    type: "boolean",
    default: true,
    order: 40
  },
  trimSpaces: {
    title: "Trim spaces",
    description: "Remove leading and trailing spaces of an expression in an hole, when giving it to Agda. (Default to be False in Emacs, but True in here)",
    type: "boolean",
    default: true,
    order: 50
  }
};

var Event = 0;

exports.Event = Event;
exports.Instance = Instance;
exports.instances = instances;
exports.Instances = Instances;
exports.isAgdaFile = isAgdaFile;
exports.subscriptions = subscriptions;
exports.onEditorActivationChange = onEditorActivationChange;
exports.onTriggerCommand = onTriggerCommand;
exports.onUndo = onUndo;
exports.activate = activate$1;
exports.deactivate = deactivate$1;
exports.config = config;
/* subscriptions Not a pure module */
