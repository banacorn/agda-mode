// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var ElementRe = require("bs-webapi/lib/js/src/dom/nodes/ElementRe.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Util$AgdaMode = require("../Util.bs.js");

function setRef(r, param) {
  param[/* state */1][/* ref */1][0] = Rebase.Option[/* map */0]((function (r) {
          return r.getModel();
        }), (r == null) ? undefined : Js_primitive.some(r));
  return /* () */0;
}

var component = ReasonReact.reducerComponent("MiniEditor");

function make($staropt$star, $staropt$star$1, hidden, $staropt$star$2, $staropt$star$3, $staropt$star$4, $staropt$star$5, $staropt$star$6, _) {
  var value = $staropt$star !== undefined ? $staropt$star : "";
  var placeholder = $staropt$star$1 !== undefined ? $staropt$star$1 : "";
  var onConfirm = $staropt$star$2 !== undefined ? $staropt$star$2 : (function () {
        return /* () */0;
      });
  var onCancel = $staropt$star$3 !== undefined ? $staropt$star$3 : (function () {
        return /* () */0;
      });
  var onFocus = $staropt$star$4 !== undefined ? $staropt$star$4 : (function () {
        return /* () */0;
      });
  var onBlur = $staropt$star$5 !== undefined ? $staropt$star$5 : (function () {
        return /* () */0;
      });
  var editorRef = $staropt$star$6 !== undefined ? $staropt$star$6 : (function () {
        return /* () */0;
      });
  var observeFocus = function (self, editor) {
    var observer = new MutationObserver((function (mutations, _) {
            var focusedNow = Rebase.$$Array[/* exists */9]((function (m) {
                    return Rebase.Option[/* mapOr */18](Rebase.Fn[/* id */0], false, Rebase.Option[/* map */0]((function (elem) {
                                      return elem.classList.contains("is-focused");
                                    }), ElementRe.ofNode(m.target)));
                  }), mutations);
            if (focusedNow) {
              Curry._1(self[/* send */3], /* Focus */0);
              return Curry._1(onFocus, /* () */0);
            } else {
              Curry._1(self[/* send */3], /* Blur */1);
              return Curry._1(onBlur, /* () */0);
            }
          }));
    var config = {
      attributes: true,
      childList: false,
      subtree: false
    };
    var element = atom.views.getView(editor);
    observer.observe(element, config);
    return Curry._1(self[/* onUnmount */4], (function () {
                  observer.disconnect();
                  return /* () */0;
                }));
  };
  return /* record */Block.record([
            "debugName",
            "reactClassInternal",
            "handedOffState",
            "willReceiveProps",
            "didMount",
            "didUpdate",
            "willUnmount",
            "willUpdate",
            "shouldUpdate",
            "render",
            "initialState",
            "retainedProps",
            "reducer",
            "jsElementWrapped"
          ], [
            component[/* debugName */0],
            component[/* reactClassInternal */1],
            component[/* handedOffState */2],
            component[/* willReceiveProps */3],
            (function (self) {
                var match = self[/* state */1][/* ref */1][0];
                if (match !== undefined) {
                  var editor = Js_primitive.valFromOption(match);
                  Curry._1(editorRef, editor);
                  var disposables = new Atom.CompositeDisposable();
                  disposables.add(atom.commands.add(atom.views.getView(editor), "core:confirm", (function (_, _$1, _$2) {
                              return Curry._1(onConfirm, editor.getText());
                            })));
                  disposables.add(atom.commands.add(atom.views.getView(editor), "core:cancel", (function (_, _$1, _$2) {
                              return Curry._1(onCancel, /* () */0);
                            })));
                  Curry._1(self[/* onUnmount */4], (function () {
                          disposables.dispose();
                          return /* () */0;
                        }));
                  observeFocus(self, editor);
                  editor.setText(value);
                  editor.setPlaceholderText(placeholder);
                  return /* () */0;
                } else {
                  return /* () */0;
                }
              }),
            component[/* didUpdate */5],
            component[/* willUnmount */6],
            component[/* willUpdate */7],
            component[/* shouldUpdate */8],
            (function (self) {
                var className = Util$AgdaMode.toClassName(Util$AgdaMode.addClass("hidden", hidden, /* :: */Block.simpleVariant("::", [
                            "mini-editor",
                            /* [] */0
                          ])));
                return React.createElement("atom-text-editor", {
                            class: className,
                            mini: "true",
                            ref: Curry._1(self[/* handle */0], setRef)
                          });
              }),
            (function () {
                return /* record */Block.record([
                          "focused",
                          "ref"
                        ], [
                          false,
                          Block.record(["contents"], [undefined])
                        ]);
              }),
            component[/* retainedProps */11],
            (function (action, state) {
                if (action) {
                  return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                "focused",
                                "ref"
                              ], [
                                false,
                                state[/* ref */1]
                              ])]);
                } else {
                  return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                                "focused",
                                "ref"
                              ], [
                                true,
                                state[/* ref */1]
                              ])]);
                }
              }),
            component[/* jsElementWrapped */13]
          ]);
}

var jsComponent = ReasonReact.wrapReasonForJs(component, (function (jsProps) {
        return make(jsProps.value, jsProps.placeholder, jsProps.hidden, jsProps.onConfirm, jsProps.onCancel, jsProps.onFocus, jsProps.onBlur, jsProps.editorRef, /* array */[]);
      }));

exports.setRef = setRef;
exports.component = component;
exports.make = make;
exports.jsComponent = jsComponent;
/* component Not a pure module */
