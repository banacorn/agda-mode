// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function isHole(token) {
  var match = token.kind;
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

var Token = {
  isHole: isHole
};

function make(raw) {
  return [{
            content: raw,
            range: /* tuple */[
              0,
              raw.length
            ],
            kind: /* AgdaRaw */0
          }];
}

function lex(regex, source, target, self) {
  var f = function (token) {
    if (token.kind === source) {
      var cursor = {
        contents: token.range[0]
      };
      return Belt_Array.map(Belt_Array.keepMap(token.content.split(regex), (function (x) {
                        return x;
                      })), (function (content) {
                    var kind = regex.test(content) ? target : source;
                    var cursorOld = cursor.contents;
                    cursor.contents = cursor.contents + content.length | 0;
                    return {
                            content: content,
                            range: /* tuple */[
                              cursorOld,
                              cursor.contents
                            ],
                            kind: kind
                          };
                  }));
    } else {
      return [token];
    }
  };
  return Belt_Array.concatMany(Belt_Array.map(self, f));
}

function map(f, self) {
  var delta = {
    contents: 0
  };
  return Belt_Array.map(self, (function (token) {
                var match = Curry._1(f, token);
                var content = match.content;
                var match$1 = token.range;
                var lengthDiff = content.length - token.content.length | 0;
                var result_range = /* tuple */[
                  match$1[0] + delta.contents | 0,
                  (match$1[1] + delta.contents | 0) + lengthDiff | 0
                ];
                var result_kind = match.kind;
                var result = {
                  content: content,
                  range: result_range,
                  kind: result_kind
                };
                delta.contents = delta.contents + lengthDiff | 0;
                return result;
              }));
}

function mapOnly(kind, f, self) {
  return map((function (token) {
                if (token.kind === kind) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = /\\begin\{code\}.*/;

var texEnd = /\\end\{code\}.*/;

var markdown = /\`\`\`(agda)?/;

var comment = /(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/;

var goalBracket = /(\{\!(?:(?!\!\})(?:.|\s))*\!\})/;

var goalQuestionMarkRaw = /([\s\(\{\_\;\.\"@]\?)/;

var goalQuestionMark = /(\?)/;

var goalBracketContent = /\{\!((?:(?!\!\})(?:.|\s))*)\!\}/;

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function toString(param) {
  var originalRange = param.originalRange;
  var modifiedRange = param.modifiedRange;
  return "Hole [" + (String(param.index) + ("] (" + (String(originalRange[0]) + (", " + (String(originalRange[1]) + (") => (" + (String(modifiedRange[0]) + (", " + (String(modifiedRange[1]) + (") \"" + (param.content + "\"")))))))))));
}

var Diff = {
  toString: toString
};

function toLiterateTokens(raw) {
  var cursor = {
    contents: 0
  };
  return Belt_Option.mapWithDefault(Caml_option.null_to_opt(raw.match(/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g)), [], (function (lines) {
                return Belt_Array.map(Belt_Array.keep(lines, (function (x) {
                                  return x !== "";
                                })), (function (line) {
                              var cursorOld = cursor.contents;
                              cursor.contents = cursor.contents + line.length | 0;
                              return {
                                      content: raw.substring(cursorOld, cursor.contents),
                                      range: /* tuple */[
                                        cursorOld,
                                        cursor.contents
                                      ],
                                      kind: /* Literate */1
                                    };
                            }));
              }));
}

function markLiterate(begin_, end_, raw) {
  var previous = {
    contents: false
  };
  var current = {
    contents: false
  };
  return Belt_Array.map(toLiterateTokens(raw), (function (token) {
                var content = token.content;
                previous.contents = current.contents;
                if (begin_.test(content) && !current.contents) {
                  current.contents = true;
                } else if (end_.test(content) && current.contents) {
                  current.contents = false;
                }
                var insideAgda = previous.contents && current.contents;
                var kind = insideAgda ? /* AgdaRaw */0 : /* Literate */1;
                console.log(/* tuple */[
                      begin_.test(content),
                      end_.test(content)
                    ], kind, content);
                return {
                        content: content,
                        range: token.range,
                        kind: kind
                      };
              }));
}

function parse(raw, indices, fileType) {
  var i = {
    contents: 0
  };
  var preprocessed;
  if (fileType !== 0) {
    switch (fileType - 1 | 0) {
      case /* Agda */0 :
          preprocessed = markLiterate(texBegin, texEnd, raw);
          break;
      case /* LiterateTeX */1 :
          preprocessed = make(raw);
          break;
      case /* LiterateReStructuredText */2 :
          preprocessed = markLiterate(markdown, markdown, raw);
          break;
      
    }
  } else {
    preprocessed = make(raw);
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return {
            content: "{!   !}",
            range: token.range,
            kind: /* GoalBracket */3
          };
  };
  var adjustGoalBracket = function (token) {
    var match = Belt_Array.get(indices, i.contents);
    var goalIndex = match !== undefined ? String(match) : "*";
    var requiredSpaces = goalIndex.length;
    var content = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_option.null_to_opt(goalBracketContent.exec(token.content)), (function (result) {
                return Belt_Option.flatMap(Belt_Option.map(Belt_Array.get(result, 1), (function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                })), (function (x) {
                              return x;
                            }));
              })), "");
    var actualSpaces = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_option.null_to_opt(content.match(/\s*$/)), (function (matches) {
                return Belt_Option.map(Belt_Array.get(matches, 0), (function (prim) {
                              return prim.length;
                            }));
              })), 0);
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token.content.replace(/\{!.*!\}/, "{!" + (content + (padding + "!}")));
    } else {
      newContent = token.content;
    }
    i.contents = i.contents + 1 | 0;
    return {
            content: newContent,
            range: /* tuple */[
              1,
              2
            ],
            kind: /* GoalBracket */3
          };
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Belt_Array.keep(original, isHole);
  var modifiedHoles = Belt_Array.keep(modified, isHole);
  return Belt_Array.keepMap(Belt_Array.mapWithIndex(originalHoles, (function (idx, token) {
                    var match = Belt_Array.get(modifiedHoles, idx);
                    var match$1 = Belt_Array.get(indices, idx);
                    if (match !== undefined && match$1 !== undefined) {
                      var modifiedHole = match;
                      var match$2 = modifiedHole.range;
                      var start = match$2[0];
                      return {
                              index: match$1,
                              modifiedRange: modifiedHole.range,
                              originalRange: /* tuple */[
                                start,
                                start + token.content.length | 0
                              ],
                              content: modifiedHole.content
                            };
                    }
                    
                  })), (function (x) {
                return x;
              }));
}

exports.Token = Token;
exports.Lexer = Lexer;
exports.Regex = Regex;
exports.Diff = Diff;
exports.toLiterateTokens = toLiterateTokens;
exports.markLiterate = markLiterate;
exports.parse = parse;
/* No side effect */
