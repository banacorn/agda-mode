// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Highlighting$AgdaMode = require("./Highlighting.bs.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function parse(xs) {
  var match = Rebase.$$Array[/* get */17](xs, 1);
  if (match !== undefined) {
    var match$1 = match;
    if (match$1.tag) {
      return undefined;
    } else {
      var payload = match$1[0].replace((/\\r\\n|\\n/g), "\n");
      var match$2 = Rebase.$$Array[/* get */17](xs, 0);
      if (match$2 !== undefined) {
        var match$3 = match$2;
        if (match$3.tag) {
          return undefined;
        } else {
          var title = match$3[0];
          switch (title) {
            case "*Agda Version*" : 
                return /* Version */Block.variant("Version", 15, [payload]);
            case "*Auto*" : 
                return /* Auto */Block.variant("Auto", 5, [payload]);
            case "*Compilation result*" : 
                return /* CompilationOk */0;
            case "*Constraints*" : 
                if (payload === "nil") {
                  return /* Constraints */Block.variant("Constraints", 0, [undefined]);
                } else {
                  return /* Constraints */Block.variant("Constraints", 0, [payload]);
                }
            case "*Context*" : 
                return /* Context */Block.variant("Context", 13, [payload]);
            case "*Current Goal*" : 
                return /* CurrentGoal */Block.variant("CurrentGoal", 11, [payload]);
            case "*Error*" : 
                return /* Error */Block.variant("Error", 3, [payload]);
            case "*Goal type etc.*" : 
                return /* GoalType */Block.variant("GoalType", 10, [payload]);
            case "*Helper function*" : 
                return /* HelperFunction */Block.variant("HelperFunction", 14, [payload]);
            case "*Inferred Type*" : 
                return /* InferredType */Block.variant("InferredType", 12, [payload]);
            case "*Intro*" : 
                return /* Intro */Block.variant("Intro", 4, [payload]);
            case "*Module contents*" : 
                return /* ModuleContents */Block.variant("ModuleContents", 6, [payload]);
            case "*Normal Form*" : 
                return /* NormalForm */Block.variant("NormalForm", 9, [payload]);
            case "*Scope Info*" : 
                return /* WhyInScope */Block.variant("WhyInScope", 8, [payload]);
            case "*Search About*" : 
                return /* SearchAbout */Block.variant("SearchAbout", 7, [payload]);
            case "*Time*" : 
                return /* Time */Block.variant("Time", 2, [payload]);
            default:
              return /* AllGoalsWarnings */Block.variant("AllGoalsWarnings", 1, [Emacs__Parser$AgdaMode.Response[/* allGoalsWarnings */1](title, payload)]);
          }
        }
      } else {
        return undefined;
      }
    }
  }
  
}

function handle(info, handler) {
  if (typeof info === "number") {
    return Curry._3(handler, "Compilation Done!", /* Success */3, /* Nothing */0);
  } else {
    switch (info.tag | 0) {
      case 0 : 
          var match = info[0];
          if (match !== undefined) {
            return Curry._3(handler, "Constraints", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* Constraints */Block.variant("Constraints", 3, [match])]));
          } else {
            return Curry._3(handler, "No Constraints", /* Success */3, /* Nothing */0);
          }
      case 1 : 
          var payload = info[0];
          return Curry._3(handler, payload[/* title */0], /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* AllGoalsWarnings */Block.variant("AllGoalsWarnings", 0, [payload])]));
      case 2 : 
          return Curry._3(handler, "Time", /* PlainText */0, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 3 : 
          return Curry._3(handler, "Error", /* Error */1, /* Emacs */Block.variant("Emacs", 0, [/* Error */Block.variant("Error", 6, [info[0]])]));
      case 4 : 
          return Curry._3(handler, "Intro", /* PlainText */0, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 5 : 
          return Curry._3(handler, "Auto", /* PlainText */0, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 6 : 
          return Curry._3(handler, "Module Contents", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 7 : 
          return Curry._3(handler, "Searching about ...", /* PlainText */0, /* Emacs */Block.variant("Emacs", 0, [/* SearchAbout */Block.variant("SearchAbout", 5, [info[0]])]));
      case 8 : 
          return Curry._3(handler, "Scope info", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* WhyInScope */Block.variant("WhyInScope", 4, [info[0]])]));
      case 9 : 
          return Curry._3(handler, "Normal form", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 10 : 
          return Curry._3(handler, "Goal type", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* GoalTypeContext */Block.variant("GoalTypeContext", 1, [info[0]])]));
      case 11 : 
          return Curry._3(handler, "Current goal", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 12 : 
          return Curry._3(handler, "Inferred type", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 13 : 
          return Curry._3(handler, "Context", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* Context */Block.variant("Context", 2, [info[0]])]));
      case 14 : 
          return Curry._3(handler, "Helper function", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 15 : 
          return Curry._3(handler, "Version", /* Info */2, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      
    }
  }
}

var Info = /* module */Block.localModule([
    "parse",
    "handle"
  ], [
    parse,
    handle
  ]);

function parse$1(tokens) {
  var err = /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](tokens)]);
  if (tokens.tag) {
    var xs = tokens[0];
    var match = Rebase.$$Array[/* get */17](xs, 0);
    var exit = 0;
    if (match !== undefined) {
      var match$1 = match;
      if (match$1.tag) {
        return err;
      } else {
        switch (match$1[0]) {
          case "agda2-abort-done" : 
              return /* Ok */Block.variant("Ok", 0, [/* DoneAborting */3]);
          case "agda2-give-action" : 
              var match$2 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$2 !== undefined) {
                var match$3 = match$2;
                if (match$3.tag) {
                  return err;
                } else {
                  var i = Caml_format.caml_int_of_string(match$3[0]);
                  var match$4 = Rebase.$$Array[/* get */17](xs, 2);
                  if (match$4 !== undefined) {
                    var match$5 = match$4;
                    if (match$5.tag) {
                      return err;
                    } else {
                      var result = match$5[0];
                      switch (result) {
                        case "no-paren" : 
                            return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                          i,
                                          /* NoParen */1
                                        ])]);
                        case "paren" : 
                            return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                          i,
                                          /* Paren */0
                                        ])]);
                        default:
                          return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                        i,
                                        /* String */Block.simpleVariant("String", [result])
                                      ])]);
                      }
                    }
                  } else {
                    return err;
                  }
                }
              } else {
                return err;
              }
          case "agda2-goals-action" : 
              var match$6 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$6 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* InteractionPoints */Block.variant("InteractionPoints", 4, [Rebase.$$Array[/* map */0](Caml_format.caml_int_of_string, Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$6))])]);
              } else {
                return err;
              }
          case "agda2-highlight-add-annotations" : 
              var annotations = Highlighting$AgdaMode.Annotation[/* parseDirectHighlighting */1](xs);
              var match$7 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$7 !== undefined) {
                var match$8 = match$7;
                if (match$8.tag) {
                  return err;
                } else {
                  switch (match$8[0]) {
                    case "nil" : 
                        return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoDirect */Block.variant("HighlightingInfoDirect", 0, [
                                      /* Keep */1,
                                      annotations
                                    ])]);
                    case "remove" : 
                        return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoDirect */Block.variant("HighlightingInfoDirect", 0, [
                                      /* Remove */0,
                                      annotations
                                    ])]);
                    default:
                      return err;
                  }
                }
              } else {
                return err;
              }
          case "agda2-highlight-clear" : 
              return /* Ok */Block.variant("Ok", 0, [/* ClearHighlighting */2]);
          case "agda2-highlight-load-and-delete-action" : 
              var match$9 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$9 !== undefined) {
                var match$10 = match$9;
                if (match$10.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoIndirect */Block.variant("HighlightingInfoIndirect", 1, [match$10[0]])]);
                }
              } else {
                return err;
              }
          case "agda2-info-action" : 
          case "agda2-info-action-and-copy" : 
              exit = 1;
              break;
          case "agda2-make-case-action" : 
              var match$11 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$11 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* MakeCase */Block.variant("MakeCase", 6, [
                              /* Function */0,
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$11)
                            ])]);
              } else {
                return err;
              }
          case "agda2-make-case-action-extendlam" : 
              var match$12 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$12 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* MakeCase */Block.variant("MakeCase", 6, [
                              /* ExtendedLambda */1,
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$12)
                            ])]);
              } else {
                return err;
              }
          case "agda2-maybe-goto" : 
              var match$13 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$13 !== undefined) {
                var match$14 = match$13;
                if (match$14.tag) {
                  var match$15 = match$14[0];
                  if (match$15.length !== 3) {
                    return err;
                  } else {
                    var match$16 = match$15[0];
                    if (match$16.tag) {
                      return err;
                    } else {
                      var match$17 = match$15[2];
                      if (match$17.tag) {
                        return err;
                      } else {
                        return /* Ok */Block.variant("Ok", 0, [/* JumpToError */Block.variant("JumpToError", 3, [
                                      match$16[0],
                                      Caml_format.caml_int_of_string(match$17[0])
                                    ])]);
                      }
                    }
                  }
                } else {
                  return err;
                }
              } else {
                return err;
              }
          case "agda2-solveAll-action" : 
              var match$18 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$18 !== undefined) {
                var tokens$1 = Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$18);
                var isEven = function (i) {
                  return i % 2 === 0;
                };
                var i$1 = /* record */Block.record(["contents"], [0]);
                var solutions = Rebase.$$Array[/* filterMap */23]((function (token) {
                        var solution;
                        if (isEven(i$1[0])) {
                          var index = Caml_format.caml_int_of_string(token);
                          solution = Rebase.Option[/* map */0]((function (s) {
                                  return /* tuple */[
                                          index,
                                          s
                                        ];
                                }), Rebase.$$Array[/* get */17](tokens$1, i$1[0] + 1 | 0));
                        } else {
                          solution = undefined;
                        }
                        i$1[0] = i$1[0] + 1 | 0;
                        return solution;
                      }), tokens$1);
                return /* Ok */Block.variant("Ok", 0, [/* SolveAll */Block.variant("SolveAll", 7, [solutions])]);
              } else {
                return err;
              }
          case "agda2-status-action" : 
              var match$19 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$19 !== undefined) {
                var match$20 = match$19;
                if (match$20.tag) {
                  return /* Ok */Block.variant("Ok", 0, [/* NoStatus */0]);
                } else {
                  var pulp = match$20[0].split(",");
                  return /* Ok */Block.variant("Ok", 0, [/* Status */Block.variant("Status", 2, [
                                pulp.includes("ShowImplicit"),
                                pulp.includes("Checked")
                              ])]);
                }
              } else {
                return /* Ok */Block.variant("Ok", 0, [/* NoStatus */0]);
              }
          case "agda2-verbose" : 
              var match$21 = Rebase.$$Array[/* get */17](xs, 2);
              if (match$21 !== undefined) {
                var match$22 = match$21;
                if (match$22.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* RunningInfo */Block.variant("RunningInfo", 9, [
                                2,
                                match$22[0]
                              ])]);
                }
              } else {
                return err;
              }
          default:
            return err;
        }
      }
    } else {
      return err;
    }
    if (exit === 1) {
      var match$23 = Rebase.$$Array[/* get */17](xs, 1);
      var exit$1 = 0;
      if (match$23 !== undefined) {
        var match$24 = match$23;
        if (match$24.tag || match$24[0] !== "*Type-checking*") {
          exit$1 = 2;
        } else {
          var match$25 = Rebase.$$Array[/* get */17](xs, 3);
          if (match$25 !== undefined) {
            var match$26 = match$25;
            if (match$26.tag || match$26[0] !== "t") {
              return /* Ok */Block.variant("Ok", 0, [/* ClearRunningInfo */1]);
            } else {
              var match$27 = Rebase.$$Array[/* get */17](xs, 2);
              if (match$27 !== undefined) {
                var match$28 = match$27;
                if (match$28.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* RunningInfo */Block.variant("RunningInfo", 9, [
                                1,
                                match$28[0]
                              ])]);
                }
              } else {
                return err;
              }
            }
          } else {
            return /* Ok */Block.variant("Ok", 0, [/* ClearRunningInfo */1]);
          }
        }
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        var match$29 = parse(xs.slice(1));
        if (match$29 !== undefined) {
          return /* Ok */Block.variant("Ok", 0, [/* DisplayInfo */Block.variant("DisplayInfo", 8, [match$29])]);
        } else {
          return err;
        }
      }
      
    }
    
  } else {
    return err;
  }
}

var Event = 0;

var Token = 0;

exports.Event = Event;
exports.Token = Token;
exports.Info = Info;
exports.parse = parse$1;
/* Highlighting-AgdaMode Not a pure module */
