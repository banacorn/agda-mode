// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(raw) {
  return /* array */[/* record */Caml_chrome_debugger.record([
              "content",
              "range",
              "type_"
            ], [
              raw,
              [
                0,
                Rebase.$$String.length(raw)
              ],
              0
            ])];
}

function lex(regex, source, target, self) {
  var f = function (token) {
    if (token[/* type_ */2] === source) {
      var cursor = /* record */Caml_chrome_debugger.record(["contents"], [token[/* range */1][0]]);
      return Rebase.$$Array.map((function (content) {
                    var match = regex.test(content);
                    var type_ = match ? target : source;
                    var cursorOld = cursor[0];
                    cursor[0] = cursor[0] + Rebase.$$String.length(content) | 0;
                    return /* record */Caml_chrome_debugger.record([
                              "content",
                              "range",
                              "type_"
                            ], [
                              content,
                              [
                                cursorOld,
                                cursor[0]
                              ],
                              type_
                            ]);
                  }), Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), token[/* content */0].split(regex)));
    } else {
      return /* array */[token];
    }
  };
  return Rebase.$$Array.flatMap(f, self);
}

function map(f, self) {
  var delta = /* record */Caml_chrome_debugger.record(["contents"], [0]);
  return Rebase.$$Array.map((function (token) {
                var match = Curry._1(f, token);
                var content = match[/* content */0];
                var match$1 = token[/* range */1];
                var lengthDiff = Rebase.$$String.length(content) - Rebase.$$String.length(token[/* content */0]) | 0;
                var result_001 = /* range : tuple */[
                  match$1[0] + delta[0] | 0,
                  (match$1[1] + delta[0] | 0) + lengthDiff | 0
                ];
                var result_002 = /* type_ */match[/* type_ */2];
                var result = /* record */Caml_chrome_debugger.record([
                    "content",
                    "range",
                    "type_"
                  ], [
                    content,
                    result_001,
                    result_002
                  ]);
                delta[0] = delta[0] + lengthDiff | 0;
                return result;
              }), self);
}

function mapOnly(type_, f, self) {
  return map((function (token) {
                var match = token[/* type_ */2] === type_;
                if (match) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = (/\\begin\{code\}.*/);

var texEnd = (/\\end\{code\}.*/);

var markdown = (/\`\`\`(agda)?/);

var comment = (/(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/);

var goalBracket = (/(\{\!(?:(?!\!\})(?:.|\s))*\!\})/);

var goalQuestionMarkRaw = (/([\s\(\{\_\;\.\"@]\?)/);

var goalQuestionMark = (/(\?)/);

var goalBracketContent = (/\{\!((?:(?!\!\})(?:.|\s))*)\!\}/);

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function isHole(token) {
  var match = token[/* type_ */2];
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

function toLines(raw) {
  var cursor = /* record */Caml_chrome_debugger.record(["contents"], [0]);
  return Rebase.$$Option.mapOr((function (lines) {
                return Rebase.$$Array.map((function (line) {
                              var cursorOld = cursor[0];
                              cursor[0] = cursor[0] + Rebase.$$String.length(line) | 0;
                              return /* record */Caml_chrome_debugger.record([
                                        "content",
                                        "range",
                                        "type_"
                                      ], [
                                        raw.substring(cursorOld, cursor[0]),
                                        [
                                          cursorOld,
                                          cursor[0]
                                        ],
                                        1
                                      ]);
                            }), Rebase.$$Array.filter((function (x) {
                                  return !Rebase.$$String.isEmpty(x);
                                }), lines));
              }), /* array */[], Caml_option.null_to_opt(raw.match((/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g))));
}

function filterOutTex(raw) {
  var insideAgda = /* record */Caml_chrome_debugger.record(["contents"], [false]);
  return Rebase.$$Array.map((function (token) {
                var content = token[/* content */0];
                if (texEnd.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (texBegin.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Caml_chrome_debugger.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function filterOutMarkdown(raw) {
  var insideAgda = /* record */Caml_chrome_debugger.record(["contents"], [false]);
  return Rebase.$$Array.map((function (token) {
                var content = token[/* content */0];
                if (insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (!insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Caml_chrome_debugger.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function parse(raw, indices, fileType) {
  var i = /* record */Caml_chrome_debugger.record(["contents"], [0]);
  var preprocessed;
  if (fileType !== 0) {
    switch (fileType - 1 | 0) {
      case /* Agda */0 :
          preprocessed = filterOutTex(raw);
          break;
      case /* LiterateTeX */1 :
          preprocessed = make(raw);
          break;
      case /* LiterateReStructuredText */2 :
          preprocessed = filterOutMarkdown(raw);
          break;
      
    }
  } else {
    preprocessed = make(raw);
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return /* record */Caml_chrome_debugger.record([
              "content",
              "range",
              "type_"
            ], [
              "{!   !}",
              token[/* range */1],
              3
            ]);
  };
  var adjustGoalBracket = function (token) {
    var match = Rebase.$$Array.get(indices, i[0]);
    var goalIndex = match !== undefined ? String(match) : "*";
    var requiredSpaces = Rebase.$$String.length(goalIndex);
    var content = Rebase.$$Option.getOr("", Rebase.$$Option.flatMap((function (result) {
                return Rebase.$$Option.flatten(Rebase.$$Option.map((function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), Rebase.$$Array.get(result, 1)));
              }), Caml_option.null_to_opt(goalBracketContent.exec(token[/* content */0]))));
    var actualSpaces = Rebase.$$Option.getOr(0, Rebase.$$Option.flatMap((function (matches) {
                return Rebase.$$Option.map(Rebase.$$String.length, Rebase.$$Array.get(matches, 0));
              }), Caml_option.null_to_opt(content.match((/\s*$/)))));
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token[/* content */0].replace((/\{!.*!\}/), "{!" + (content + (padding + "!}")));
    } else {
      newContent = token[/* content */0];
    }
    i[0] = i[0] + 1 | 0;
    return /* record */Caml_chrome_debugger.record([
              "content",
              "range",
              "type_"
            ], [
              newContent,
              [
                1,
                2
              ],
              3
            ]);
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Rebase.$$Array.filter(isHole, original);
  var modifiedHoles = Rebase.$$Array.filter(isHole, modified);
  return Rebase.$$Array.filterMap((function (x) {
                return x;
              }), Rebase.$$Array.mapi((function (token, idx) {
                    var match = Rebase.$$Array.get(modifiedHoles, idx);
                    var match$1 = Rebase.$$Array.get(indices, idx);
                    if (match !== undefined && match$1 !== undefined) {
                      var modifiedHole = match;
                      var match$2 = modifiedHole[/* range */1];
                      var start = match$2[0];
                      return /* record */Caml_chrome_debugger.record([
                                "index",
                                "modifiedRange",
                                "originalRange",
                                "content"
                              ], [
                                match$1,
                                modifiedHole[/* range */1],
                                [
                                  start,
                                  start + Rebase.$$String.length(token[/* content */0]) | 0
                                ],
                                modifiedHole[/* content */0]
                              ]);
                    }
                    
                  }), originalHoles));
}

exports.Lexer = Lexer;
exports.Regex = Regex;
exports.isHole = isHole;
exports.toLines = toLines;
exports.filterOutTex = filterOutTex;
exports.filterOutMarkdown = filterOutMarkdown;
exports.parse = parse;
/* texBegin Not a pure module */
