// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Metadata$AgdaMode = require("./Metadata.bs.js");
var Response$AgdaMode = require("./Response.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Connection2$AgdaMode = require("./Connection2.bs.js");

function disconnect(error, self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  Curry._1(self[/* process */1][/* disconnect */2], /* () */0);
  Rebase.$$Array.forEach((function (ev) {
          return Curry._1(ev[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [error]));
        }), self[/* queue */2]);
  self[/* queue */2] = /* array */[];
  Curry._1(self[/* errorEmitter */3][/* destroy */4], /* () */0);
  self[/* connected */4] = false;
  self[/* encountedFirstPrompt */6] = false;
  return /* () */0;
}

function autoSearch(name) {
  return $$Promise.mapError(Connection2$AgdaMode.PathSearch.run(name), (function (e) {
                return /* PathSearchError */Caml_chrome_debugger.variant("PathSearchError", 0, [e]);
              }));
}

function validateAndMake(pathAndParams) {
  var validator = function (output) {
    var match = output.match((/Agda version (.*)/));
    if (match !== null) {
      var match$1 = Rebase.$$Array.get(match, 1);
      if (match$1 !== undefined) {
        var match$2 = (/--interaction-json/).test(output);
        return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [/* tuple */[
                    match$1,
                    match$2 ? /* EmacsAndJSON */1 : /* EmacsOnly */0
                  ]]);
      } else {
        return /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read Agda version"]);
      }
    } else {
      return /* Error */Caml_chrome_debugger.variant("Error", 1, ["Cannot read Agda version"]);
    }
  };
  var match = Parser$AgdaMode.commandLine(pathAndParams);
  var args = match[1];
  var path = match[0];
  return $$Promise.mapError($$Promise.mapOk(Connection2$AgdaMode.Validation.run(path + " -V", validator), (function (param) {
                    return /* record */Caml_chrome_debugger.record([
                              "path",
                              "args",
                              "version",
                              "protocol",
                              "entries"
                            ], [
                              path,
                              args,
                              param[0],
                              param[1],
                              []
                            ]);
                  })), (function (e) {
                return /* ValidationError */Caml_chrome_debugger.variant("ValidationError", 1, [e]);
              }));
}

function connect(metadata) {
  var args = Rebase.$$Array.concat(metadata[/* args */1], /* array */["--interaction"]);
  var $$process = Connection2$AgdaMode.Process.make(metadata[/* path */0], args);
  return /* record */Caml_chrome_debugger.record([
            "metadata",
            "process",
            "queue",
            "errorEmitter",
            "connected",
            "resetLogOnLoad",
            "encountedFirstPrompt"
          ], [
            metadata,
            $$process,
            [],
            Event$AgdaMode.make(/* () */0),
            true,
            true,
            false
          ]);
}

function wire(self) {
  var handleResponse = function (res) {
    var match = Rebase.$$Array.get(self[/* queue */2], 0);
    if (match !== undefined) {
      Curry._1(match[/* emit */1], /* Ok */Caml_chrome_debugger.variant("Ok", 0, [res]));
      if (res) {
        return /* () */0;
      } else if (self[/* encountedFirstPrompt */6]) {
        return Rebase.$$Option.forEach((function (ev) {
                      return /* () */0;
                    }), Caml_option.undefined_to_opt(self[/* queue */2].pop()));
      } else {
        self[/* encountedFirstPrompt */6] = true;
        return /* () */0;
      }
    } else if (res) {
      var match$1 = res[0];
      if (match$1.tag) {
        return /* () */0;
      } else {
        var data = match$1[0];
        console.log("[ unbound response ] ", data);
        return Curry._1(self[/* errorEmitter */3][/* emit */1], data);
      }
    } else {
      return /* () */0;
    }
  };
  var partial_arg = Rebase.Result.forEach;
  var logSExpression = Curry._1(Parser$AgdaMode.Incr.$$Event.tap, (function (param) {
          return partial_arg((function (expr) {
                        return Metadata$AgdaMode.logSExpression(expr)(self[/* metadata */0]);
                      }), param);
        }));
  var toResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.flatMap, (function (param) {
          if (param.tag) {
            return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [/* Error */Caml_chrome_debugger.variant("Error", 1, [param[0]])]);
          } else {
            var tokens = param[0];
            if (tokens.tag || tokens[0] !== "Agda2>") {
              return /* Yield */Caml_chrome_debugger.simpleVariant("Yield", [Response$AgdaMode.parse(tokens)]);
            } else {
              return /* Stop */0;
            }
          }
        }));
  var partial_arg$1 = Rebase.Result.forEach;
  var logResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.tap, (function (param) {
          return partial_arg$1((function (expr) {
                        return Metadata$AgdaMode.logResponse(expr)(self[/* metadata */0]);
                      }), param);
        }));
  var pipeline = Parser$AgdaMode.SExpression.makeIncr(Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, logSExpression, toResponse), logResponse), handleResponse));
  var onData = function (param) {
    if (param.tag) {
      var e = param[0];
      Rebase.$$Array.forEach((function (req) {
              Curry._1(req[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [e]));
              return Curry._1(req[/* destroy */4], /* () */0);
            }), self[/* queue */2]);
      self[/* queue */2] = /* array */[];
      return /* () */0;
    } else {
      var rawText = param[0];
      Metadata$AgdaMode.logRawText(rawText)(self[/* metadata */0]);
      var partial_arg = Parser$AgdaMode.Incr.feed;
      return Rebase.$$Array.forEach((function (param) {
                    return partial_arg(pipeline, param);
                  }), Curry._1(Parser$AgdaMode.split, rawText));
    }
  };
  Curry._1(self[/* process */1][/* emitter */1][/* on */3], onData);
  return self;
}

function send(request, self) {
  var reqEvent = Event$AgdaMode.make(/* () */0);
  self[/* queue */2].push(reqEvent);
  Curry._1(self[/* process */1][/* send */0], request);
  return reqEvent;
}

function resetLog(self) {
  self[/* metadata */0][/* entries */4] = /* array */[];
  return /* () */0;
}

exports.disconnect = disconnect;
exports.autoSearch = autoSearch;
exports.validateAndMake = validateAndMake;
exports.connect = connect;
exports.wire = wire;
exports.send = send;
exports.resetLog = resetLog;
/* Promise Not a pure module */
