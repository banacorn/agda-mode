// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Async$AgdaMode = require("./Async.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function make(resolve, id) {
  return /* record */Caml_chrome_debugger.record([
            "resolve",
            "id"
          ], [
            resolve,
            id
          ]);
}

function contraMap(f, listener) {
  return /* record */Caml_chrome_debugger.record([
            "resolve",
            "id"
          ], [
            (function ($$event) {
                return Curry._1(listener[/* resolve */0], Curry._1(f, $$event));
              }),
            listener[/* id */1]
          ]);
}

function contraMap_(f, listener) {
  return /* record */Caml_chrome_debugger.record([
            "resolve",
            "id"
          ], [
            (function (x) {
                return Rebase.$$Array[/* forEach */8](listener[/* resolve */0], Curry._1(f, x));
              }),
            listener[/* id */1]
          ]);
}

var Listener = /* module */Caml_chrome_debugger.localModule([
    "make",
    "contraMap",
    "contraMap_"
  ], [
    make,
    contraMap,
    contraMap_
  ]);

function make$1(param) {
  return /* record */Caml_chrome_debugger.record([
            "counter",
            "listeners"
          ], [
            Caml_chrome_debugger.record(["contents"], [0]),
            { }
          ]);
}

function removeListener(_id, _self) {
  return (delete _self[1][String(_id)]);
}

function removeListener$prime(_id, _self) {
  return (delete _self[1][_id]);
}

function removeAllListeners(self) {
  Rebase.$$Array[/* forEach */8]((function (id) {
          return removeListener$prime(id, self);
        }), Object.keys(self[/* listeners */1]));
  return /* () */0;
}

function listen(callback, self) {
  var id = self[/* counter */0][0] + 1 | 0;
  self[/* counter */0][0] = id;
  var listener = /* record */Caml_chrome_debugger.record([
      "resolve",
      "id"
    ], [
      callback,
      id
    ]);
  self[/* listeners */1][String(id)] = listener;
  return (function (param) {
      return removeListener(id, self);
    });
}

function destroyWhen(trigger, destructor) {
  return Curry._1(trigger, destructor);
}

function contraMap$1(f, x) {
  return /* record */Caml_chrome_debugger.record([
            "counter",
            "listeners"
          ], [
            x[/* counter */0],
            Js_dict.map((function (l) {
                    return contraMap(f, l);
                  }), x[/* listeners */1])
          ]);
}

function contraMap_$1(f, x) {
  return /* record */Caml_chrome_debugger.record([
            "counter",
            "listeners"
          ], [
            x[/* counter */0],
            Js_dict.map((function (l) {
                    return contraMap_(f, l);
                  }), x[/* listeners */1])
          ]);
}

function onOk(callback) {
  return (function (param) {
      return listen((function (param) {
                    if (param.tag) {
                      return /* () */0;
                    } else {
                      return Curry._1(callback, param[0]);
                    }
                  }), param);
    });
}

function onError(callback) {
  return (function (param) {
      return listen((function (param) {
                    if (param.tag) {
                      return Curry._1(callback, param[0]);
                    } else {
                      return /* () */0;
                    }
                  }), param);
    });
}

function once(self) {
  var id = self[/* counter */0][0] + 1 | 0;
  self[/* counter */0][0] = id;
  return Async$AgdaMode.make((function (resolve, reject) {
                var callback = function (param) {
                  if (param.tag) {
                    Curry._1(reject, param[0]);
                    return removeListener(id, self);
                  } else {
                    Curry._1(resolve, param[0]);
                    return removeListener(id, self);
                  }
                };
                var listener = /* record */Caml_chrome_debugger.record([
                    "resolve",
                    "id"
                  ], [
                    callback,
                    id
                  ]);
                self[/* listeners */1][String(id)] = listener;
                return /* () */0;
              }));
}

function emit(x, self) {
  return Rebase.$$Array[/* forEach */8]((function (listener) {
                return Curry._1(listener[/* resolve */0], x);
              }), Js_dict.values(self[/* listeners */1]));
}

function emitOk(x, self) {
  return emit(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [x]), self);
}

function emitError(e, self) {
  return emit(/* Error */Caml_chrome_debugger.variant("Error", 1, [e]), self);
}

function pipe(to_, from) {
  return listen((function (param) {
                if (param.tag) {
                  return emit(/* Error */Caml_chrome_debugger.variant("Error", 1, [param[0]]), to_);
                } else {
                  return emit(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [param[0]]), to_);
                }
              }), from);
}

function pipeMap(to_, f, from) {
  return listen((function (a) {
                return Rebase.$$Array[/* forEach */8]((function (x) {
                              return emit(x, to_);
                            }), Curry._1(f, a));
              }), from);
}

var destroy = removeAllListeners;

var on = listen;

exports.Listener = Listener;
exports.make = make$1;
exports.removeListener = removeListener;
exports.removeListener$prime = removeListener$prime;
exports.removeAllListeners = removeAllListeners;
exports.destroy = destroy;
exports.listen = listen;
exports.destroyWhen = destroyWhen;
exports.on = on;
exports.contraMap = contraMap$1;
exports.contraMap_ = contraMap_$1;
exports.onOk = onOk;
exports.onError = onError;
exports.once = once;
exports.emit = emit;
exports.emitOk = emitOk;
exports.emitError = emitError;
exports.pipe = pipe;
exports.pipeMap = pipeMap;
/* Async-AgdaMode Not a pure module */
