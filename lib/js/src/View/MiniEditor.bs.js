// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var ReactDOMRe = require("reason-react/lib/js/src/ReactDOMRe.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Hook$AgdaMode = require("./Hook.bs.js");
var Util$AgdaMode = require("../Util/Util.bs.js");
var Webapi__Dom__Element = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__Element.js");

function observeFocus(setFocused, editor) {
  var observer = new MutationObserver((function (mutations, param) {
          var partial_arg = Curry._2(Rebase.Fn.$great$great, (function (prim) {
                  return prim.classList;
                }), (function (param) {
                  return param.contains("is-focused");
                }));
          return Curry._1(setFocused, Rebase.$$Array.exists(Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, Curry._2(Rebase.Fn.$great$great, (function (prim) {
                                        return prim.target;
                                      }), Webapi__Dom__Element.ofNode), (function (param) {
                                    return Rebase.$$Option.map(partial_arg, param);
                                  })), (function (param) {
                                return Rebase.$$Option.mapOr(Rebase.Fn.id, false, param);
                              })), mutations));
        }));
  var config = {
    attributes: true,
    childList: false,
    subtree: false
  };
  var element = atom.views.getView(editor);
  observer.observe(element, config);
  return (function (param) {
            observer.disconnect();
            
          });
}

function ofTextEditor(r) {
  return r.getModel();
}

function MiniEditor(Props) {
  var valueOpt = Props.value;
  var placeholderOpt = Props.placeholder;
  var hidden = Props.hidden;
  var grammarOpt = Props.grammar;
  var onConfirmOpt = Props.onConfirm;
  var onChangeOpt = Props.onChange;
  var onCancelOpt = Props.onCancel;
  var onFocusOpt = Props.onFocus;
  var onBlurOpt = Props.onBlur;
  var onEditorRefOpt = Props.onEditorRef;
  var value = valueOpt !== undefined ? valueOpt : "";
  var placeholder = placeholderOpt !== undefined ? placeholderOpt : "";
  var grammar = grammarOpt !== undefined ? grammarOpt : "";
  var onConfirm = onConfirmOpt !== undefined ? onConfirmOpt : (function (param) {
        
      });
  var onChange = onChangeOpt !== undefined ? onChangeOpt : (function (param) {
        
      });
  var onCancel = onCancelOpt !== undefined ? onCancelOpt : (function (param) {
        
      });
  var onFocus = onFocusOpt !== undefined ? onFocusOpt : (function (param) {
        
      });
  var onBlur = onBlurOpt !== undefined ? onBlurOpt : (function (param) {
        
      });
  var onEditorRef = onEditorRefOpt !== undefined ? onEditorRefOpt : (function (param) {
        
      });
  var match = Hook$AgdaMode.useState(false);
  var setFocused = match[1];
  var focused = match[0];
  var match$1 = Hook$AgdaMode.useState(undefined);
  var setEditorRef = match$1[1];
  var editorRef = match$1[0];
  var editorElem = React.useRef(undefined);
  React.useEffect((function () {
          Rebase.$$Option.forEach((function (param) {
                  param.setText(value);
                  
                }), Rebase.$$Option.map(ofTextEditor, editorElem.current));
          
        }), [value]);
  React.useEffect((function () {
          Rebase.$$Option.forEach((function (param) {
                  param.setPlaceholderText(placeholder);
                  
                }), Rebase.$$Option.map(ofTextEditor, editorElem.current));
          
        }), [placeholder]);
  React.useEffect((function () {
          return Rebase.$$Option.flatMap((function (editor) {
                        Curry._1(setEditorRef, Caml_option.some(editor));
                        if (grammar === "agda") {
                          Rebase.$$Option.forEach((function (grammar) {
                                  try {
                                    editor.setGrammar(grammar);
                                    return ;
                                  }
                                  catch (exn){
                                    return ;
                                  }
                                }), atom.grammars.grammarForScopeName("source.agda"));
                        }
                        Curry._1(onEditorRef, editor);
                        var disposables = new Atom.CompositeDisposable();
                        var element = atom.views.getView(editor);
                        disposables.add(atom.commands.add(element, "core:confirm", (function (_event) {
                                    return Curry._1(onConfirm, editor.getText());
                                  })));
                        disposables.add(atom.commands.add(element, "core:cancel", (function (_event) {
                                    return Curry._1(onCancel, undefined);
                                  })));
                        disposables.add(editor.onDidChange(onChange));
                        return (function (param) {
                                  disposables.dispose();
                                  
                                });
                      }), Rebase.$$Option.map(ofTextEditor, editorElem.current));
        }), []);
  React.useEffect((function () {
          return Rebase.$$Option.flatMap((function (param) {
                        return observeFocus(setFocused, param);
                      }), editorRef);
        }), [editorRef]);
  React.useEffect((function () {
          if (focused) {
            Curry._1(onFocus, undefined);
          } else {
            Curry._1(onBlur, undefined);
          }
          
        }), [focused]);
  return ReactDOMRe.createElementVariadic("atom-text-editor", {
              class: "mini-editor" + Util$AgdaMode.React.showWhen(!hidden),
              mini: "true",
              ref: editorElem
            }, []);
}

var make = MiniEditor;

exports.observeFocus = observeFocus;
exports.ofTextEditor = ofTextEditor;
exports.make = make;
/* atom Not a pure module */
