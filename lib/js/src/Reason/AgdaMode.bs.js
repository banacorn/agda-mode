// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var View$AgdaMode = require("./View.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function make(textEditor) {
  return /* record */Block.record([
            "textEditor",
            "view"
          ], [
            textEditor,
            View$AgdaMode.initialize(textEditor)
          ]);
}

function activate(self) {
  return Curry._1(self[/* view */1][/* updateActivation */4][0], true);
}

function deactivate(self) {
  return Curry._1(self[/* view */1][/* updateActivation */4][0], false);
}

function destroy(self) {
  deactivate(self);
  return Curry._1(self[/* view */1][/* destroy */9][0], /* () */0);
}

function modeDisplay(self) {
  return Curry._1(self[/* view */1][/* updateMode */2][0], /* Display */0);
}

function modeQuery(self) {
  return Curry._1(self[/* view */1][/* updateMode */2][0], /* Query */1);
}

function interceptAndInsertKey(self, key) {
  return Curry._1(self[/* view */1][/* interceptAndInsertKey */6][0], key);
}

function inputMethodHandle(self, activate) {
  return Curry._1(self[/* view */1][/* activateInputMethod */7][0], activate);
}

function updateRawBody(self, raw) {
  return Curry._1(self[/* view */1][/* updateRawBody */1][0], raw);
}

function updateHeader(self, raw) {
  return Curry._1(self[/* view */1][/* updateHeader */0][0], raw);
}

function inquireQuery(self, placeholder, value) {
  return Curry._2(self[/* view */1][/* inquireQuery */5][0], placeholder, value);
}

var Instance = /* module */Block.localModule([
    "make",
    "activate",
    "deactivate",
    "destroy",
    "modeDisplay",
    "modeQuery",
    "interceptAndInsertKey",
    "inputMethodHandle",
    "updateRawBody",
    "updateHeader",
    "inquireQuery"
  ], [
    make,
    activate,
    deactivate,
    destroy,
    modeDisplay,
    modeQuery,
    interceptAndInsertKey,
    inputMethodHandle,
    updateRawBody,
    updateHeader,
    inquireQuery
  ]);

var InstanceNotFound = Caml_exceptions.create("AgdaMode-AgdaMode.InstanceNotFound");

var instances = { };

function initialize(textEditor) {
  var filepath = textEditor.getPath();
  console.log("initializing " + filepath);
  var match = Js_dict.get(instances, filepath);
  if (match !== undefined) {
    console.log("already initialized: " + filepath);
    return /* () */0;
  } else {
    instances[filepath] = /* record */Block.record([
        "textEditor",
        "view"
      ], [
        textEditor,
        View$AgdaMode.initialize(textEditor)
      ]);
    return /* () */0;
  }
}

function lookup(textEditor) {
  var filepath = textEditor.getPath();
  return Js_dict.get(instances, filepath);
}

function activate$1(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    activate(match);
    return /* () */0;
  } else {
    console.log("cannot activate, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function destroy$1(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    destroy(match);
    return /* () */0;
  } else {
    console.log("cannot destroy, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function deactivate$1(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    deactivate(match);
    return /* () */0;
  } else {
    console.log("cannot deactivate, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function modeDisplay$1(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    modeDisplay(match);
    return /* () */0;
  } else {
    console.log("cannot modeDisplay, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function modeQuery$1(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    modeQuery(match);
    return /* () */0;
  } else {
    console.log("cannot modeQuery, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function interceptAndInsertKey$1(textEditor, key) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    interceptAndInsertKey(match, key);
    return /* () */0;
  } else {
    console.log("cannot interceptAndInsertKey, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function activateInputMethod(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    inputMethodHandle(match, true);
    return /* () */0;
  } else {
    console.log("cannot activateInputMethod, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function deactivateInputMethod(textEditor) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    inputMethodHandle(match, false);
    return /* () */0;
  } else {
    console.log("cannot deactivateInputMethod, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function jsUpdateEmacsBody(textEditor, raw) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    updateRawBody(match, /* RawEmacs */Block.variant("RawEmacs", 0, [/* record */Block.record([
                "kind",
                "header",
                "body"
              ], [
                raw.kind,
                raw.header,
                raw.body
              ])]));
    return /* () */0;
  } else {
    console.log("cannot jsUpdateEmacsBody, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function jsUpdateJSONBody(textEditor, raw) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    updateRawBody(match, /* RawJSON */Block.variant("RawJSON", 1, [/* record */Block.record([
                "kind",
                "rawJSON",
                "rawString"
              ], [
                raw.kind,
                raw.rawJSON,
                raw.rawString
              ])]));
    return /* () */0;
  } else {
    console.log("cannot jsUpdateJSONBody, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function jsUpdateHeader(textEditor, raw) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    updateHeader(match, /* record */Block.record([
            "text",
            "style"
          ], [
            raw.text,
            raw.style
          ]));
    return /* () */0;
  } else {
    console.log("cannot jsUpdateHeader, does not exist: " + textEditor.getPath());
    return /* () */0;
  }
}

function jsInquireQuery(textEditor, placeholder, value) {
  var match = lookup(textEditor);
  if (match !== undefined) {
    return inquireQuery(match, placeholder, value);
  } else {
    return Promise.reject(InstanceNotFound);
  }
}

exports.Instance = Instance;
exports.InstanceNotFound = InstanceNotFound;
exports.instances = instances;
exports.initialize = initialize;
exports.lookup = lookup;
exports.activate = activate$1;
exports.destroy = destroy$1;
exports.deactivate = deactivate$1;
exports.modeDisplay = modeDisplay$1;
exports.modeQuery = modeQuery$1;
exports.interceptAndInsertKey = interceptAndInsertKey$1;
exports.activateInputMethod = activateInputMethod;
exports.deactivateInputMethod = deactivateInputMethod;
exports.jsUpdateEmacsBody = jsUpdateEmacsBody;
exports.jsUpdateJSONBody = jsUpdateJSONBody;
exports.jsUpdateHeader = jsUpdateHeader;
exports.jsInquireQuery = jsInquireQuery;
/* View-AgdaMode Not a pure module */
