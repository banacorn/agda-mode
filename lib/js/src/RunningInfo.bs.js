// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

function make(param) {
  return {
          editor: undefined,
          isOpeningEditor: false,
          buffer: [],
          subscriptions: new Atom.CompositeDisposable()
        };
}

var itemOptions = {
  initialLine: 0,
  initialColumn: 0,
  split: "right",
  activatePane: false,
  activateItem: false,
  pending: false,
  searchAllPanes: true,
  location: undefined
};

function destroy(self) {
  self.editor = undefined;
  self.isOpeningEditor = false;
  self.buffer = [];
  self.subscriptions.dispose();
  
}

function add(info, self) {
  var editor = self.editor;
  if (editor !== undefined) {
    Caml_option.valFromOption(editor).insertText(info);
    return $$Promise.resolved(undefined);
  } else if (self.isOpeningEditor) {
    self.buffer.unshift(info);
    return $$Promise.resolved(undefined);
  } else {
    self.isOpeningEditor = true;
    return $$Promise.map($$Promise.mapOk($$Promise.Js.toResult($$Promise.Js.fromBsPromise(atom.workspace.open("agda-mode://running-info", itemOptions))), (function (newItem) {
                      self.isOpeningEditor = false;
                      self.editor = Caml_option.some(newItem);
                      newItem.insertText(Caml_splice_call.spliceObjApply("", "concat", [self.buffer]));
                      self.buffer = [];
                      self.subscriptions.add(newItem.onDidDestroy((function (param) {
                                  return destroy(self);
                                })));
                      
                    })), (function (param) {
                  
                }));
  }
}

exports.make = make;
exports.itemOptions = itemOptions;
exports.destroy = destroy;
exports.add = add;
/* atom Not a pure module */
