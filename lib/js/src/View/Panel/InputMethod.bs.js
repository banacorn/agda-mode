// Generated by BUCKLESCRIPT VERSION 5.0.3, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var ReactUpdate = require("reason-react-update/lib/js/src/ReactUpdate.bs.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Hook$AgdaMode = require("../Hook.bs.js");
var Util$AgdaMode = require("../../Util.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Event$AgdaMode = require("../../Util/Event.bs.js");
var Editors$AgdaMode = require("../../Editors.bs.js");
var ReasonReactCompat = require("reason-react/lib/js/src/ReasonReactCompat.js");
var Translator$AgdaMode = require("./Translator.bs.js");
var CandidateSymbols$AgdaMode = require("./CandidateSymbols.bs.js");

function init(string) {
  return string.substring(0, Rebase.$$String[/* length */1](string) - 1 | 0);
}

var initial = /* record */Block.record([
    "surfaceHead",
    "surfaceBody",
    "underlying"
  ], [
    undefined,
    "",
    ""
  ]);

function isEmpty(self) {
  if (self[/* surfaceHead */0] === undefined && Rebase.$$String[/* isEmpty */5](self[/* surfaceBody */1])) {
    return true;
  } else {
    return Rebase.$$String[/* isEmpty */5](self[/* underlying */2]);
  }
}

function toString(self) {
  var match = self[/* surfaceHead */0];
  if (match !== undefined) {
    return match + (self[/* surfaceBody */1] + (" | " + self[/* underlying */2]));
  } else {
    return " | " + self[/* underlying */2];
  }
}

function toSurface(self) {
  var match = self[/* surfaceHead */0];
  if (match !== undefined) {
    return match + self[/* surfaceBody */1];
  } else {
    return self[/* underlying */2];
  }
}

function next(param, input) {
  var underlying = param[/* underlying */2];
  var surfaceBody = param[/* surfaceBody */1];
  var surfaceHead = param[/* surfaceHead */0];
  var surface = toSurface(/* record */Block.record([
          "surfaceHead",
          "surfaceBody",
          "underlying"
        ], [
          surfaceHead,
          surfaceBody,
          underlying
        ]));
  if (input === surface) {
    return /* Noop */Block.variant("Noop", 0, [/* record */Block.record([
                  "surfaceHead",
                  "surfaceBody",
                  "underlying"
                ], [
                  surfaceHead,
                  surfaceBody,
                  underlying
                ])]);
  } else if (init(input) === surface) {
    var insertedChar = input.substr(-1);
    var underlying$prime = underlying + insertedChar;
    var translation = Translator$AgdaMode.translate(underlying$prime);
    var match = translation[/* symbol */0];
    if (match !== undefined) {
      return /* Rewrite */Block.variant("Rewrite", 1, [
                /* record */Block.record([
                    "surfaceHead",
                    "surfaceBody",
                    "underlying"
                  ], [
                    match,
                    "",
                    underlying$prime
                  ]),
                translation[/* further */1]
              ]);
    } else if (translation[/* further */1]) {
      return /* Noop */Block.variant("Noop", 0, [/* record */Block.record([
                    "surfaceHead",
                    "surfaceBody",
                    "underlying"
                  ], [
                    surfaceHead,
                    surfaceBody + insertedChar,
                    underlying$prime
                  ])]);
    } else {
      return /* Stuck */0;
    }
  } else if (input === init(surface)) {
    if (Rebase.$$String[/* isEmpty */5](input)) {
      if (Rebase.$$Option[/* isSome */13](surfaceHead)) {
        return /* Rewrite */Block.variant("Rewrite", 1, [
                  /* record */Block.record([
                      "surfaceHead",
                      "surfaceBody",
                      "underlying"
                    ], [
                      undefined,
                      init(underlying),
                      init(underlying)
                    ]),
                  true
                ]);
      } else {
        return /* Stuck */0;
      }
    } else {
      return /* Noop */Block.variant("Noop", 0, [/* record */Block.record([
                    "surfaceHead",
                    "surfaceBody",
                    "underlying"
                  ], [
                    surfaceHead,
                    init(surfaceBody),
                    init(underlying)
                  ])]);
    }
  } else {
    return /* Stuck */0;
  }
}

var $$Buffer = /* module */Block.localModule([
    "init",
    "initial",
    "isEmpty",
    "toString",
    "toSurface",
    "next"
  ], [
    init,
    initial,
    isEmpty,
    toString,
    toSurface,
    next
  ]);

var initialState_002 = /* markers : array */[];

var initialState = /* record */Block.record([
    "activated",
    "mute",
    "markers",
    "buffer"
  ], [
    false,
    false,
    initialState_002,
    initial
  ]);

function addClass(editor) {
  atom.views.getView(editor).classList.add("agda-mode-input-method-activated");
  return /* () */0;
}

function removeClass(editor) {
  atom.views.getView(editor).classList.remove("agda-mode-input-method-activated");
  return /* () */0;
}

function clearAndMarkSelectedAreas(editor) {
  return Rebase.$$Array[/* map */0]((function (range) {
                editor.getBuffer().setTextInRange(range, "");
                return editor.markBufferRange(range.copy());
              }), editor.getSelectedBufferRanges());
}

function markerOnDidChange(editor, send, $$event) {
  var rangeOld = new Atom.Range($$event.oldTailBufferPosition, $$event.oldHeadBufferPosition);
  var rangeNew = new Atom.Range($$event.newTailBufferPosition, $$event.newHeadBufferPosition);
  var oldBuffer = editor.getBuffer().getTextInRange(rangeOld);
  var newBuffer = editor.getBuffer().getTextInRange(rangeNew);
  return Curry._1(send, /* MarkerEvent */Block.variant("MarkerEvent", 1, [
                oldBuffer,
                newBuffer
              ]));
}

function monitor(editor, send) {
  var disposables = new Atom.CompositeDisposable();
  addClass(editor);
  var markers = clearAndMarkSelectedAreas(editor);
  Curry._1(send, /* UpdateMarker */Block.variant("UpdateMarker", 0, [markers]));
  Rebase.$$Option[/* forEach */8]((function (marker) {
          disposables.add(marker.onDidChange((function (param) {
                      return markerOnDidChange(editor, send, param);
                    })));
          disposables.add(atom.commands.add("atom-text-editor.agda-mode-input-method-activated", "editor:newline", (function ($$event) {
                      Curry._1(send, /* Deactivate */1);
                      $$event.stopImmediatePropagation();
                      return /* () */0;
                    })));
          return /* () */0;
        }), Rebase.$$Array[/* get */17](markers, 0));
  disposables.add(editor.onDidChangeCursorPosition((function ($$event) {
              var point = $$event.newBufferPosition;
              var ranges = Rebase.$$Array[/* map */0]((function (prim) {
                      return prim.getBufferRange();
                    }), markers);
              var inRange = Rebase.$$Array[/* exists */9]((function (param) {
                      return param.containsPoint(point);
                    }), ranges);
              if (inRange) {
                return 0;
              } else {
                return Curry._1(send, /* Deactivate */1);
              }
            })));
  var decorations = Rebase.$$Array[/* map */0]((function (marker) {
          return editor.decorateMarker(marker, {
                      type: "highlight",
                      class: "input-method-decoration"
                    });
        }), markers);
  return (function (param) {
            Rebase.$$Array[/* forEach */8]((function (prim) {
                    prim.destroy();
                    return /* () */0;
                  }), decorations);
            Rebase.$$Array[/* forEach */8]((function (prim) {
                    prim.destroy();
                    return /* () */0;
                  }), markers);
            disposables.dispose();
            return /* () */0;
          });
}

function insertTextBuffer(editor, $$char) {
  var textBuffer = editor.getBuffer();
  var getCharIndex = function (selection) {
    var start = selection.getBufferRange().start;
    return textBuffer.characterIndexForPosition(start);
  };
  var compareSelection = function (a, b) {
    var indexA = getCharIndex(a);
    var indexB = getCharIndex(b);
    return Caml_primitive.caml_int_compare(indexA, indexB);
  };
  var selections = editor.getSelections();
  $$Array.sort(compareSelection, selections);
  return Rebase.$$Array[/* forEach */8]((function (selection) {
                var range = selection.getBufferRange();
                textBuffer.setTextInRange(range, $$char);
                return /* () */0;
              }), selections);
}

function rewriteTextBuffer(editor, markers, string) {
  return Rebase.$$Array[/* forEach */8]((function (marker) {
                editor.getBuffer().setTextInRange(marker.getBufferRange(), string);
                return /* () */0;
              }), markers);
}

function reducer(editor, action, state) {
  if (typeof action === "number") {
    if (action === 0) {
      var match = state[/* activated */0];
      if (match) {
        return /* SideEffects */Block.variant("SideEffects", 2, [(function (param) {
                      var send = param[/* send */0];
                      Curry._1(send, /* Insert */Block.variant("Insert", 2, ["\\"]));
                      if (isEmpty(state[/* buffer */3])) {
                        Curry._1(send, /* Deactivate */1);
                      }
                      return undefined;
                    })]);
      } else {
        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                      "activated",
                      "mute",
                      "markers",
                      "buffer"
                    ], [
                      true,
                      state[/* mute */1],
                      state[/* markers */2],
                      state[/* buffer */3]
                    ])]);
      }
    } else {
      var match$1 = state[/* activated */0];
      if (match$1) {
        return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                      "activated",
                      "mute",
                      "markers",
                      "buffer"
                    ], [
                      false,
                      state[/* mute */1],
                      state[/* markers */2],
                      initial
                    ])]);
      } else {
        return /* NoUpdate */0;
      }
    }
  } else {
    switch (action.tag | 0) {
      case 0 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "activated",
                        "mute",
                        "markers",
                        "buffer"
                      ], [
                        state[/* activated */0],
                        state[/* mute */1],
                        action[0],
                        state[/* buffer */3]
                      ])]);
      case 1 : 
          var match$2 = next(state[/* buffer */3], action[1]);
          if (typeof match$2 === "number") {
            return /* SideEffects */Block.variant("SideEffects", 2, [(function (param) {
                          Curry._1(param[/* send */0], /* Deactivate */1);
                          return undefined;
                        })]);
          } else if (match$2.tag) {
            var keepGoing = match$2[1];
            var buffer = match$2[0];
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "mute",
                          "markers",
                          "buffer"
                        ], [
                          state[/* activated */0],
                          state[/* mute */1],
                          state[/* markers */2],
                          buffer
                        ]),
                      (function (param) {
                          var send = param[/* send */0];
                          var surface = toSurface(buffer);
                          Curry._1(send, /* Rewrite */Block.variant("Rewrite", 3, [surface]));
                          if (!keepGoing) {
                            Curry._1(send, /* Deactivate */1);
                          }
                          return undefined;
                        })
                    ]);
          } else {
            return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                          "activated",
                          "mute",
                          "markers",
                          "buffer"
                        ], [
                          state[/* activated */0],
                          state[/* mute */1],
                          state[/* markers */2],
                          match$2[0]
                        ])]);
          }
      case 2 : 
          var $$char = action[0];
          return /* SideEffects */Block.variant("SideEffects", 2, [(function (param) {
                        insertTextBuffer(editor, $$char);
                        return undefined;
                      })]);
      case 3 : 
          var string = action[0];
          return /* SideEffects */Block.variant("SideEffects", 2, [(function (param) {
                        rewriteTextBuffer(editor, state[/* markers */2], string);
                        return undefined;
                      })]);
      
    }
  }
}

function InputMethod(Props) {
  var editors = Props.editors;
  var interceptAndInsertKey = Props.interceptAndInsertKey;
  var activateInputMethod = Props.activateInputMethod;
  var onActivationChange = Props.onActivationChange;
  var isActive = Props.isActive;
  var editor = Editors$AgdaMode.Focus[/* get */0](editors);
  var match = ReactUpdate.useReducer(initialState, (function (param, param$1) {
          return reducer(editor, param, param$1);
        }));
  var send = match[1];
  var state = match[0];
  React.useEffect((function () {
          return Rebase.$$Option[/* some */11](Event$AgdaMode.onOk((function (shouldActivate) {
                              return Curry._1(send, shouldActivate ? /* Activate */0 : /* Deactivate */1);
                            }))(activateInputMethod));
        }), /* array */[]);
  React.useEffect((function () {
          Curry._1(onActivationChange, state[/* activated */0]);
          return undefined;
        }), /* array */[state[/* activated */0]]);
  React.useEffect((function () {
          return Rebase.$$Option[/* some */11](Event$AgdaMode.onOk((function ($$char) {
                              return Curry._1(send, /* Insert */Block.variant("Insert", 2, [$$char]));
                            }))(interceptAndInsertKey));
        }), /* array */[]);
  Hook$AgdaMode.useListenWhen((function (param) {
          return monitor(editor, send);
        }), state[/* activated */0]);
  var translation = Translator$AgdaMode.translate(state[/* buffer */3][/* underlying */2]);
  var className = Curry._1(Util$AgdaMode.ClassName[/* serialize */2], Util$AgdaMode.ClassName[/* addWhen */1]("hidden", !state[/* activated */0], /* :: */Block.simpleVariant("::", [
              "input-method",
              /* [] */0
            ])));
  var bufferClassName = Curry._1(Util$AgdaMode.ClassName[/* serialize */2], Util$AgdaMode.ClassName[/* addWhen */1]("hidden", Rebase.$$String[/* isEmpty */5](state[/* buffer */3][/* underlying */2]), /* :: */Block.simpleVariant("::", [
              "inline-block",
              /* :: */Block.simpleVariant("::", [
                  "buffer",
                  /* [] */0
                ])
            ])));
  return React.createElement("section", {
              className: className
            }, React.createElement("div", {
                  className: "keyboard"
                }, React.createElement("div", {
                      className: bufferClassName
                    }, state[/* buffer */3][/* underlying */2]), Block.spliceApply(React.createElement, [
                      "div",
                      {
                        className: "keys btn-group btn-group-sm"
                      },
                      Rebase.$$Array[/* map */0]((function (key) {
                              return React.createElement("button", {
                                          key: key,
                                          className: "btn",
                                          onClick: (function (param) {
                                              return Curry._1(send, /* Insert */Block.variant("Insert", 2, [key]));
                                            })
                                        }, key);
                            }), translation[/* keySuggestions */2])
                    ])), React.createElement(CandidateSymbols$AgdaMode.make, {
                  isActive: isActive && state[/* activated */0],
                  candidateSymbols: translation[/* candidateSymbols */3],
                  updateTranslation: (function (replace) {
                      if (replace !== undefined) {
                        return Curry._1(send, /* Rewrite */Block.variant("Rewrite", 3, [replace]));
                      } else {
                        return /* () */0;
                      }
                    }),
                  chooseSymbol: (function (symbol) {
                      Curry._1(send, /* Insert */Block.variant("Insert", 2, [symbol]));
                      return Curry._1(send, /* Deactivate */1);
                    })
                }));
}

var component = ReasonReact.statelessComponent("InputMethod");

function make(editors, interceptAndInsertKey, activateInputMethod, onActivationChange, isActive, children) {
  return ReasonReactCompat.wrapReactForReasonReact(InputMethod, {
              editors: editors,
              interceptAndInsertKey: interceptAndInsertKey,
              activateInputMethod: activateInputMethod,
              onActivationChange: onActivationChange,
              isActive: isActive
            }, children);
}

var Jsx2 = /* module */Block.localModule([
    "component",
    "make"
  ], [
    component,
    make
  ]);

var sort = $$Array.sort;

var make$1 = InputMethod;

exports.sort = sort;
exports.$$Buffer = $$Buffer;
exports.initialState = initialState;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.clearAndMarkSelectedAreas = clearAndMarkSelectedAreas;
exports.markerOnDidChange = markerOnDidChange;
exports.monitor = monitor;
exports.insertTextBuffer = insertTextBuffer;
exports.rewriteTextBuffer = rewriteTextBuffer;
exports.reducer = reducer;
exports.make = make$1;
exports.Jsx2 = Jsx2;
/* component Not a pure module */
