// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Log$AgdaMode = require("./Log.bs.js");
var Util$AgdaMode = require("./Util/Util.bs.js");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Process$AgdaMode = require("./Process.bs.js");
var Response$AgdaMode = require("./Response.bs.js");

function toString(e) {
  switch (e.TAG | 0) {
    case /* PathSearch */0 :
        return Curry._1(Process$AgdaMode.PathSearch.$$Error.toString, e._0);
    case /* Validation */1 :
        return Curry._1(Process$AgdaMode.Validation.$$Error.toString, e._0);
    case /* Process */2 :
        return Process$AgdaMode.$$Error.toString(e._0);
    
  }
}

var $$Error = {
  toString: toString
};

function toString$1(param) {
  if (param) {
    return "Emacs / JSON";
  } else {
    return "Emacs";
  }
}

var Protocol = {
  toString: toString$1
};

function serialize(self) {
  var path = "* path: " + self.path;
  var args = "* args: " + Util$AgdaMode.Pretty.array(self.args);
  var version = "* version: " + self.version;
  var protocol = "* protocol: " + (
    self.protocol ? "Emacs / JSON" : "Emacs"
  );
  var os = "* platform: " + Os.type();
  return "## Parse Log\n" + path + "\n" + args + "\n" + version + "\n" + protocol + "\n" + os + "\n  ";
}

var Metadata = {
  Protocol: Protocol,
  serialize: serialize
};

function disconnect(error, self) {
  Curry._1(self.process.disconnect, undefined);
  Belt_List.forEach(self.queue, (function (ev) {
          return Curry._1(ev.emit, {
                      TAG: 1,
                      _0: error,
                      [Symbol.for("name")]: "Error"
                    });
        }));
  self.queue = /* [] */0;
  self.encountedFirstPrompt = false;
  self.log = [];
  
}

function autoSearch(name) {
  return $$Promise.mapError(Process$AgdaMode.PathSearch.run(name), (function (e) {
                return {
                        TAG: 0,
                        _0: e,
                        [Symbol.for("name")]: "PathSearch"
                      };
              }));
}

function validateAndMake(path, args) {
  var validator = function (output) {
    var match_ = output.match(/Agda version (.*)/);
    if (match_ === null) {
      return {
              TAG: 1,
              _0: "Cannot read Agda version",
              [Symbol.for("name")]: "Error"
            };
    }
    var version = Belt_Array.get(match_, 1);
    if (version !== undefined) {
      return {
              TAG: 0,
              _0: [
                version,
                /--interaction-json/.test(output) ? /* EmacsAndJSON */1 : /* EmacsOnly */0
              ],
              [Symbol.for("name")]: "Ok"
            };
    } else {
      return {
              TAG: 1,
              _0: "Cannot read Agda version",
              [Symbol.for("name")]: "Error"
            };
    }
  };
  return $$Promise.mapError($$Promise.mapOk(Process$AgdaMode.Validation.run(path + " -V", validator), (function (param) {
                    return {
                            path: path,
                            args: args,
                            version: param[0],
                            protocol: param[1]
                          };
                  })), (function (e) {
                return {
                        TAG: 1,
                        _0: e,
                        [Symbol.for("name")]: "Validation"
                      };
              }));
}

function connect(metadata) {
  var args = Belt_Array.concat(metadata.args, ["--interaction"]);
  var $$process = Process$AgdaMode.make(metadata.path, args);
  return {
          metadata: metadata,
          process: $$process,
          queue: /* [] */0,
          resetLogOnLoad: true,
          encountedFirstPrompt: false,
          log: []
        };
}

function wire(self) {
  var logSExpression = Curry._1(Parser$AgdaMode.Incr.$$Event.tap, (function (expr) {
          if (expr.TAG) {
            return ;
          } else {
            return Log$AgdaMode.logSExpression(expr._0)(self.log);
          }
        }));
  var toResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.flatMap, (function (parseError) {
          if (parseError.TAG) {
            return {
                    _0: {
                      TAG: 1,
                      _0: parseError._0,
                      [Symbol.for("name")]: "Error"
                    },
                    [Symbol.for("name")]: "Yield"
                  };
          }
          var tokens = parseError._0;
          if (tokens.TAG || tokens._0 !== "Agda2>") {
            return {
                    _0: Response$AgdaMode.parse(tokens),
                    [Symbol.for("name")]: "Yield"
                  };
          } else {
            return /* Stop */0;
          }
        }));
  var logResponse = Curry._1(Parser$AgdaMode.Incr.$$Event.tap, (function (expr) {
          if (expr.TAG) {
            return ;
          } else {
            return Log$AgdaMode.logResponse(expr._0)(self.log);
          }
        }));
  var pipeline = Parser$AgdaMode.SExpression.makeIncr(function (x) {
        var res = Curry._1(logResponse, Curry._1(toResponse, Curry._1(logSExpression, x)));
        var match = self.queue;
        if (!match) {
          return ;
        }
        var req = match.hd;
        if (res) {
          return Curry._1(req.emit, {
                      TAG: 0,
                      _0: {
                        _0: res._0,
                        [Symbol.for("name")]: "Yield"
                      },
                      [Symbol.for("name")]: "Ok"
                    });
        } else {
          if (self.encountedFirstPrompt) {
            Curry._1(req.emit, {
                  TAG: 0,
                  _0: /* Stop */0,
                  [Symbol.for("name")]: "Ok"
                });
            self.queue = match.tl;
            Curry._1(req.destroy, undefined);
          } else {
            self.encountedFirstPrompt = true;
          }
          return ;
        }
      });
  var onData = function (rawText) {
    if (rawText.TAG) {
      var e = rawText._0;
      Belt_List.forEach(self.queue, (function (req) {
              Curry._1(req.emit, {
                    TAG: 1,
                    _0: e,
                    [Symbol.for("name")]: "Error"
                  });
              return Curry._1(req.destroy, undefined);
            }));
      self.queue = /* [] */0;
      return ;
    }
    var rawText$1 = rawText._0;
    Log$AgdaMode.logRawText(rawText$1)(self.log);
    return Belt_Array.forEach(Parser$AgdaMode.split(rawText$1), (function (param) {
                  return Parser$AgdaMode.Incr.feed(pipeline, param);
                }));
  };
  Curry._1(self.process.emitter.on, onData);
  return self;
}

function send(request, self) {
  var reqEvent = Event$AgdaMode.make(undefined);
  self.queue = {
    hd: reqEvent,
    tl: self.queue
  };
  Curry._1(self.process.send, request);
  return reqEvent;
}

function resetLog(self) {
  self.log = [];
  
}

function dump(self) {
  var serialize$1 = function (self) {
    var metadata = serialize(self.metadata);
    var log = Log$AgdaMode.serialize(self.log);
    return metadata + ("\n" + (log + "\n"));
  };
  var text = serialize$1(self);
  var itemOptions = {
    initialLine: 0,
    initialColumn: 0,
    split: "left",
    activatePane: true,
    activateItem: true,
    pending: false,
    searchAllPanes: true,
    location: undefined
  };
  $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(atom.workspace.open("agda-mode://log.md", itemOptions))), (function (newItem) {
          if (newItem.TAG) {
            return ;
          }
          newItem._0.insertText(text);
          
        }));
  
}

exports.$$Error = $$Error;
exports.Metadata = Metadata;
exports.disconnect = disconnect;
exports.autoSearch = autoSearch;
exports.validateAndMake = validateAndMake;
exports.connect = connect;
exports.wire = wire;
exports.send = send;
exports.resetLog = resetLog;
exports.dump = dump;
/* os Not a pure module */
