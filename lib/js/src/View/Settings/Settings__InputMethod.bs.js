// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Hook$AgdaMode = require("../Hook.bs.js");
var Util$AgdaMode = require("../../Util/Util.bs.js");
var Extension$AgdaMode = require("../Panel/InputMethod/Extension.bs.js");
var MiniEditor$AgdaMode = require("../MiniEditor.bs.js");
var Translator$AgdaMode = require("../Panel/InputMethod/Translator.bs.js");

function Settings__InputMethod$SymbolLookup(Props) {
  var match = Hook$AgdaMode.useState("");
  var setInput = match[1];
  var translation = Translator$AgdaMode.translate(match[0]);
  var editorRef = React.useRef(undefined);
  var onChange = function (param) {
    var match = editorRef.current;
    if (match !== undefined) {
      return Curry._1(setInput, Caml_option.valFromOption(match).getText());
    } else {
      return /* () */0;
    }
  };
  var candidateSymbols = Rebase.$$Array.mapi((function (symbol, i) {
          return React.createElement("kbd", {
                      key: String(i),
                      className: "inline-block highlight"
                    }, symbol);
        }), translation.candidateSymbols);
  return React.createElement("section", undefined, React.createElement("h2", undefined, "Symbol lookup"), React.createElement("p", undefined, "Enter a key sequence and get corresponding symbols"), React.createElement(MiniEditor$AgdaMode.make, {
                  value: "",
                  placeholder: "enter some key sequence here, e.g 'lambda'",
                  hidden: false,
                  onChange: onChange,
                  onEditorRef: (function (ref) {
                      editorRef.current = Caml_option.some(ref);
                      return /* () */0;
                    })
                }), React.createElement("div", {
                  className: "native-key-bindings",
                  id: "candidate-symbols",
                  tabIndex: -1
                }, React.createElement("div", undefined, candidateSymbols)));
}

var SymbolLookup = {
  make: Settings__InputMethod$SymbolLookup
};

function Settings__InputMethod$KeySequenceLookup(Props) {
  var match = Hook$AgdaMode.useState([]);
  var setInput = match[1];
  var editorRef = React.useRef(undefined);
  var onChange = function (param) {
    return Rebase.$$Option.forEach(setInput, Rebase.$$Option.flatMap(Translator$AgdaMode.lookup, Rebase.$$Option.map((function (prim) {
                          return prim.getText();
                        }), editorRef.current)));
  };
  var results = Rebase.$$Array.mapi((function (sequence, i) {
          return React.createElement("kbd", {
                      key: String(i),
                      className: "inline-block highlight"
                    }, sequence);
        }), match[0]);
  return React.createElement("section", undefined, React.createElement("h2", undefined, "Key sequences lookup"), React.createElement("p", undefined, "Enter a symbol and get corresponding key sequences"), React.createElement(MiniEditor$AgdaMode.make, {
                  value: "",
                  placeholder: "enter some symbol here, e.g \'Î»\'",
                  hidden: false,
                  onChange: onChange,
                  onEditorRef: (function (ref) {
                      editorRef.current = Caml_option.some(ref);
                      return /* () */0;
                    })
                }), React.createElement("p", {
                  className: "native-key-bindings",
                  id: "key-sequences",
                  tabIndex: -1
                }, React.createElement("span", undefined, results)));
}

var KeySequenceLookup = {
  make: Settings__InputMethod$KeySequenceLookup
};

function Settings__InputMethod$ExtendKeymap$AddEntry(Props) {
  var onChange = Props.onChange;
  var keyRef = React.useRef(undefined);
  var symbolsRef = React.useRef(undefined);
  var onClick = function (param) {
    var match = keyRef.current;
    var match$1 = symbolsRef.current;
    if (match !== undefined && match$1 !== undefined) {
      var symbolsEditor = Caml_option.valFromOption(match$1);
      var keyEditor = Caml_option.valFromOption(match);
      var key = keyEditor.getText();
      var symbols = Rebase.$$Array.filter(Curry._2(Rebase.Fn.$great$great, Rebase.$$String.isEmpty, (function (prim) {
                  return !prim;
                })), symbolsEditor.getText().split(""));
      Extension$AgdaMode.add(key, symbols);
      keyEditor.setText("");
      symbolsEditor.setText("");
      return Curry._1(onChange, /* () */0);
    } else {
      return /* () */0;
    }
  };
  return React.createElement("div", {
              id: "add-entry"
            }, React.createElement("div", {
                  id: "add-entry-key-sequence"
                }, React.createElement(MiniEditor$AgdaMode.make, {
                      value: "",
                      placeholder: "key sequence",
                      hidden: false,
                      onEditorRef: (function (ref) {
                          keyRef.current = Caml_option.some(ref);
                          return /* () */0;
                        })
                    })), React.createElement("div", {
                  id: "add-entry-symbols"
                }, React.createElement(MiniEditor$AgdaMode.make, {
                      value: "",
                      placeholder: "corresponding symbols",
                      hidden: false,
                      onEditorRef: (function (ref) {
                          symbolsRef.current = Caml_option.some(ref);
                          return /* () */0;
                        })
                    })), React.createElement("div", {
                  id: "add-entry-button"
                }, React.createElement("button", {
                      className: "btn btn-primary icon icon-plus inline-block-tight",
                      onClick: onClick
                    }, "add entry")));
}

var AddEntry = {
  make: Settings__InputMethod$ExtendKeymap$AddEntry
};

function Settings__InputMethod$ExtendKeymap$ExtensionItem(Props) {
  var sequence = Props.sequence;
  var symbols = Props.symbols;
  var onChange = Props.onChange;
  var editorRef = React.useRef(undefined);
  var match = Hook$AgdaMode.useState(false);
  var setHovered = match[1];
  var onMouseOver = function (param) {
    return Curry._1(setHovered, true);
  };
  var onMouseLeave = function (param) {
    return Curry._1(setHovered, false);
  };
  var match$1 = Hook$AgdaMode.useState(false);
  var setModifying = match$1[1];
  var modifying = match$1[0];
  var symbolsString = Rebase.$$String.joinWith(" ", Rebase.List.fromArray(symbols));
  React.useEffect((function () {
          if (modifying) {
            var match = editorRef.current;
            if (match !== undefined) {
              atom.views.getView(Caml_option.valFromOption(match)).focus();
            }
            
          }
          return ;
        }), [modifying]);
  return React.createElement("li", {
              onMouseLeave: onMouseLeave,
              onMouseOver: onMouseOver
            }, React.createElement("div", {
                  className: "sequence"
                }, sequence), React.createElement("div", {
                  className: "symbols"
                }, React.createElement("div", {
                      className: Util$AgdaMode.React.showWhen(!modifying)
                    }, React.createElement(React.Fragment, undefined, Rebase.$$Array.mapi((function (symbol, i) {
                                return React.createElement("kbd", {
                                            key: String(i),
                                            className: "inline-block highlight"
                                          }, symbol);
                              }), symbols))), React.createElement(MiniEditor$AgdaMode.make, {
                      value: symbolsString,
                      placeholder: "enter symbols here, the whole entry would be deleted if left empty",
                      hidden: !modifying,
                      onConfirm: (function (value) {
                          var symbols = Rebase.$$Array.filter(Curry._2(Rebase.Fn.$great$great, Rebase.$$String.isEmpty, (function (prim) {
                                      return !prim;
                                    })), value.split(""));
                          if (Rebase.$$Array.length(symbols) === 0) {
                            Extension$AgdaMode.$$delete(sequence);
                          } else {
                            Extension$AgdaMode.modify(sequence, symbols);
                          }
                          Curry._1(setModifying, false);
                          return Curry._1(onChange, /* () */0);
                        }),
                      onCancel: (function (param) {
                          return Curry._1(setModifying, false);
                        }),
                      onEditorRef: (function (ref) {
                          editorRef.current = Caml_option.some(ref);
                          return /* () */0;
                        })
                    })), React.createElement("div", {
                  className: "buttons" + Util$AgdaMode.React.showWhen(match[0] && !modifying)
                }, React.createElement("button", {
                      className: "btn icon icon-pencil inline-block-tight",
                      onClick: (function (param) {
                          return Curry._1(setModifying, true);
                        })
                    }, "modify"), React.createElement("button", {
                      className: "btn btn-error icon icon-trashcan inline-block-tight",
                      onClick: (function (param) {
                          Extension$AgdaMode.$$delete(sequence);
                          return Curry._1(onChange, /* () */0);
                        })
                    }, "delete")));
}

var ExtensionItem = {
  make: Settings__InputMethod$ExtendKeymap$ExtensionItem
};

function Settings__InputMethod$ExtendKeymap(Props) {
  var match = Hook$AgdaMode.useState(Curry._1(Extension$AgdaMode.readKeymap, /* () */0));
  var setKeymap = match[1];
  var forceUpdate = function (param) {
    return Curry._1(setKeymap, Curry._1(Extension$AgdaMode.readKeymap, /* () */0));
  };
  var onChange = React.useCallback(forceUpdate, []);
  React.useEffect((function () {
          var destructor = atom.config.onDidChange("agda-mode.inputMethodExtension", (function (param) {
                  return Curry._1(setKeymap, Curry._1(Extension$AgdaMode.readKeymap, /* () */0));
                }));
          return (function (param) {
                    destructor.dispose();
                    return /* () */0;
                  });
        }), []);
  var resetToDefault = React.useCallback((function (param) {
          Extension$AgdaMode.resetToDefault(/* () */0);
          return Curry._1(setKeymap, Curry._1(Extension$AgdaMode.readKeymap, /* () */0));
        }), []);
  var items = React.createElement("ul", {
        id: "extensions"
      }, Rebase.$$Array.mapi((function (param, i) {
              return React.createElement(Settings__InputMethod$ExtendKeymap$ExtensionItem, {
                          sequence: param[0],
                          symbols: param[1],
                          onChange: onChange,
                          key: String(i)
                        });
            }), Js_dict.entries(match[0])));
  return React.createElement("section", undefined, React.createElement("h2", undefined, "Keymap extensions", React.createElement("div", {
                      className: "pull-right"
                    }, React.createElement("button", {
                          className: "btn icon icon-history inline-block-tight",
                          onClick: resetToDefault
                        }, "reset to default"))), React.createElement("p", undefined, "Add mappings to the keymap.\nIf the mapping already exists, it will be prioritized in case that the key sequence corresponds to multiple symbols (e.g. 'r')."), React.createElement(Settings__InputMethod$ExtendKeymap$AddEntry, {
                  onChange: onChange
                }), items);
}

var ExtendKeymap = {
  AddEntry: AddEntry,
  ExtensionItem: ExtensionItem,
  make: Settings__InputMethod$ExtendKeymap
};

function Settings__InputMethod(Props) {
  var hidden = Props.hidden;
  return React.createElement("section", {
              className: "agda-settings-input-method" + Util$AgdaMode.React.showWhen(!hidden)
            }, React.createElement("h1", undefined, React.createElement("span", {
                      className: "icon icon-keyboard"
                    }), React.createElement("span", undefined, "Input Method")), React.createElement("hr", undefined), React.createElement(Settings__InputMethod$SymbolLookup, { }), React.createElement("hr", undefined), React.createElement(Settings__InputMethod$KeySequenceLookup, { }), React.createElement("hr", undefined), React.createElement(Settings__InputMethod$ExtendKeymap, { }));
}

var make = Settings__InputMethod;

exports.SymbolLookup = SymbolLookup;
exports.KeySequenceLookup = KeySequenceLookup;
exports.ExtendKeymap = ExtendKeymap;
exports.make = make;
/* react Not a pure module */
