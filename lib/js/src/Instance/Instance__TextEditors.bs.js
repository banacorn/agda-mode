// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Goal$AgdaMode = require("../Goal.bs.js");
var Parser$AgdaMode = require("../Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Instance__Goals$AgdaMode = require("./Instance__Goals.bs.js");

function getPath(instance) {
  return Parser$AgdaMode.filepath(Rebase.$$Option.getOr("untitled", instance[/* editors */0][/* source */1].getPath()));
}

function pointingAt(cursor, instance) {
  var cursor_ = cursor !== undefined ? Caml_option.valFromOption(cursor) : instance[/* editors */0][/* source */1].getCursorBufferPosition();
  var pointedGoals = Rebase.$$Array.filter((function (goal) {
          return goal[/* range */2].containsPoint(cursor_);
        }), instance[/* goals */5]);
  return Rebase.$$Array.get(pointedGoals, 0);
}

function getPointedGoal(instance) {
  var pointed = pointingAt(undefined, instance);
  if (pointed !== undefined) {
    return $$Promise.resolved(/* Ok */Caml_chrome_debugger.variant("Ok", 0, [pointed]));
  } else {
    return $$Promise.resolved(/* Error */Caml_chrome_debugger.variant("Error", 1, [/* OutOfGoal */1]));
  }
}

function restoreCursorPosition(callback, instance) {
  var originalPosition = instance[/* editors */0][/* source */1].getCursorBufferPosition();
  return $$Promise.map(Curry._1(callback, /* () */0), (function (result) {
                var pointed = pointingAt(Caml_option.some(originalPosition), instance);
                if (pointed !== undefined) {
                  var goal = pointed;
                  if (Goal$AgdaMode.isEmpty(goal)) {
                    Instance__Goals$AgdaMode.setCursor(goal, instance);
                  } else {
                    instance[/* editors */0][/* source */1].setCursorBufferPosition(originalPosition);
                  }
                } else {
                  instance[/* editors */0][/* source */1].setCursorBufferPosition(originalPosition);
                }
                return result;
              }));
}

function startCheckpoint(command, instance) {
  var checkpoint = instance[/* editors */0][/* source */1].createCheckpoint();
  instance[/* history */2][/* checkpoints */0].push(checkpoint);
  if (Rebase.$$Array.length(instance[/* history */2][/* checkpoints */0]) === 1) {
    instance[/* history */2][/* needsReloading */1] = typeof command === "number" ? (
        command >= 13 ? command < 17 : command === 6
      ) : false;
    return /* () */0;
  } else {
    return 0;
  }
}

function endCheckpoint(instance) {
  var checkpoint = instance[/* history */2][/* checkpoints */0].pop();
  if (Rebase.$$Array.length(instance[/* history */2][/* checkpoints */0]) === 0) {
    Rebase.$$Option.forEach((function (n) {
            instance[/* editors */0][/* source */1].groupChangesSinceCheckpoint(n);
            return /* () */0;
          }), checkpoint === undefined ? undefined : Caml_option.some(checkpoint));
  }
  return /* () */0;
}

exports.getPath = getPath;
exports.pointingAt = pointingAt;
exports.getPointedGoal = getPointedGoal;
exports.restoreCursorPosition = restoreCursorPosition;
exports.startCheckpoint = startCheckpoint;
exports.endCheckpoint = endCheckpoint;
/* Promise Not a pure module */
