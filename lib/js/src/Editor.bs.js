// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var View$AgdaMode = require("./View.bs.js");
var Parser$AgdaModeVscode = require("agda-mode-vscode/lib/js/src/Parser.bs.js");

function make(prim) {
  return new Atom.Disposable(prim);
}

function dispose(prim) {
  prim.dispose();
  
}

var Disposable = {
  make: make,
  dispose: dispose
};

function make$1(prim, prim$1) {
  return new Atom.Point(prim, prim$1);
}

function line(prim) {
  return prim.row;
}

function column(prim) {
  return prim.column;
}

function translate(p, x, y) {
  return p.translate(new Atom.Point(x, y));
}

function compare(x, y) {
  var match = y.compare(x);
  switch (match) {
    case -1 :
        return /* LT */2;
    case 0 :
        return /* EQ */1;
    case 1 :
        return /* GT */0;
    default:
      return /* EQ */1;
  }
}

function make$2(prim, prim$1) {
  return new Atom.Range(prim, prim$1);
}

function start(prim) {
  return prim.start;
}

function end_(prim) {
  return prim.end;
}

function contains(self, point) {
  return self.containsPoint(point);
}

function containsRange(self, others) {
  return self.containsRange(others);
}

var $$Range = {
  make: make$2,
  start: start,
  end_: end_,
  contains: contains,
  containsRange: containsRange
};

function getExtensionPath(param) {
  return Belt_Option.getWithDefault(atom.packages.resolvePackagePath("agda-mode"), "");
}

function getFileName(editor) {
  return editor.getPath();
}

function save(editor) {
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(editor.save())), (function (param) {
                if (param.tag) {
                  return false;
                } else {
                  return true;
                }
              }));
}

function addToSubscriptions(disposable, subscriptions) {
  subscriptions.add(disposable);
  
}

function onDidCloseEditor(callback) {
  return atom.workspace.observeTextEditors((function (editor) {
                var subscriptions = new Atom.CompositeDisposable();
                subscriptions.add(editor.onDidDestroy((function (param) {
                            Belt_Option.forEach(editor.getPath(), callback);
                            subscriptions.dispose();
                            
                          })));
                
              }));
}

function onDidChangeFileName(callback) {
  return atom.workspace.observeTextEditors((function (editor) {
                var subscriptions = new Atom.CompositeDisposable();
                var previous = {
                  contents: editor.getPath()
                };
                subscriptions.add(editor.onDidChangePath((function (param) {
                            var next = editor.getPath();
                            if (Caml_obj.caml_notequal(next, previous.contents)) {
                              Curry._2(callback, previous.contents, next);
                              previous.contents = next;
                              return ;
                            }
                            
                          })));
                
              }));
}

function onDidChangeActivation(callback) {
  var previous = {
    contents: atom.workspace.getActiveTextEditor()
  };
  return atom.workspace.onDidChangeActiveTextEditor((function (next) {
                var previousFileName = Belt_Option.flatMap(previous.contents, (function (prim) {
                        return prim.getPath();
                      }));
                var nextFileName = Belt_Option.flatMap(next, (function (prim) {
                        return prim.getPath();
                      }));
                if (Caml_obj.caml_notequal(previousFileName, nextFileName)) {
                  Curry._2(callback, previousFileName, nextFileName);
                  previous.contents = next;
                  return ;
                }
                
              }));
}

function isAgda(filepath) {
  var filepath$1 = Parser$AgdaModeVscode.filepath(filepath);
  return /\.agda$|\.lagda$/i.test(filepath$1);
}

function registerCommand(name, callback) {
  var eventTargetEditor = function ($$event) {
    var targetSubElement = $$event.target;
    var targetedEditors = Belt_Array.keep(atom.workspace.getTextEditors(), (function (x) {
            return atom.views.getView(x).contains(targetSubElement);
          }));
    return Belt_Array.get(targetedEditors, 0);
  };
  return atom.commands.add("atom-text-editor", "agda-mode:" + name, (function ($$event) {
                return Belt_Option.forEach(eventTargetEditor($$event), callback);
              }));
}

function setContext(param, param$1) {
  return $$Promise.resolved(undefined);
}

function setAgdaPath(value) {
  atom.config.set("agda-mode.path", value);
  return $$Promise.resolved(undefined);
}

function getAgdaPath(param) {
  return atom.config.get("agda-mode.path");
}

function getLibraryPath(param) {
  var raw = Belt_Option.getWithDefault(atom.config.get("agda-mode.libraryPath"), "");
  return Belt_Array.map(Belt_Array.keep(raw.split(","), (function (x) {
                    return x !== "";
                  })), Parser$AgdaModeVscode.filepath);
}

function getHighlightingMethod(param) {
  var raw = atom.config.get("agda-mode.highlightingMethod");
  if (raw === "Direct") {
    return true;
  } else {
    return false;
  }
}

function highlightBackground(editor, kind, range) {
  var createMarker = function (class_, range) {
    var marker = editor.markBufferRange(range);
    var option = {
      type: "highlight",
      class: class_
    };
    return editor.decorateMarker(marker, option);
  };
  switch (kind) {
    case "Error" :
        return [createMarker("highlight-error", range)];
    case "Highlight" :
        return [createMarker("highlight-link", range)];
    default:
      return [createMarker("highlight-spec", range)];
  }
}

function overlayText(editor, kind, text, range) {
  var createOverlay = function (text, class_, tail, translation, range) {
    var element = document.createElement("div");
    element.innerHTML = text;
    element.classList.add(class_);
    var top = (translation[0] - 1 | 0) * 1.5;
    element.setAttribute("style", "left: " + (String(translation[1]) + ("ex; top: " + (top.toString() + "em"))));
    var marker = editor.markBufferRange(range);
    var option = {
      type: "overlay",
      item: element,
      position: tail ? "tail" : "head"
    };
    return editor.decorateMarker(marker, option);
  };
  switch (kind) {
    case "Error" :
        return [createOverlay(text, "overlay-error", true, /* tuple */[
                      0,
                      0
                    ], range)];
    case "Highlight" :
        return [createOverlay(text, "overlay-link", false, /* tuple */[
                      0,
                      1
                    ], range)];
    default:
      return [createOverlay(text, "overlay-spec", false, /* tuple */[
                    0,
                    1
                  ], range)];
  }
}

function destroy(prim) {
  prim.destroy();
  
}

function focus(editor) {
  atom.views.getView(editor).focus();
  
}

function getCursorPosition(editor) {
  return editor.getCursorBufferPosition();
}

function setCursorPosition(editor, point) {
  editor.setCursorBufferPosition(point);
  
}

function rangeForLine(editor, line) {
  return editor.getBuffer().rangeForRow(line, true);
}

function pointAtOffset(editor, offset) {
  return editor.getBuffer().positionForCharacterIndex(offset);
}

function offsetAtPoint(editor, point) {
  return editor.getBuffer().characterIndexForPosition(point);
}

function getText(editor) {
  return editor.getBuffer().getText();
}

function getTextInRange(editor, range) {
  return editor.getTextInBufferRange(range);
}

function selectText(editor, range) {
  editor.setSelectedScreenRange(range);
  
}

function setText(editor, range, text) {
  editor.setTextInBufferRange(range, text);
  return $$Promise.resolved(true);
}

function insertText(editor, point, text) {
  editor.getBuffer().insert(point, text);
  return $$Promise.resolved(true);
}

function deleteText(editor, range) {
  editor.getBuffer().delete(range);
  return $$Promise.resolved(true);
}

var Impl_Point = {
  line: line,
  column: column,
  make: make$1,
  translate: translate,
  compare: compare
};

var Impl_Config = {
  getAgdaPath: getAgdaPath,
  setAgdaPath: setAgdaPath,
  getLibraryPath: getLibraryPath,
  getHighlightingMethod: getHighlightingMethod
};

var Impl_View = {
  make: View$AgdaMode.make,
  destroy: View$AgdaMode.destroy,
  show: View$AgdaMode.show,
  hide: View$AgdaMode.hide,
  focus: View$AgdaMode.focus,
  send: View$AgdaMode.send,
  on: View$AgdaMode.on
};

var Impl_Decoration = {
  highlightBackground: highlightBackground,
  overlayText: overlayText,
  destroy: destroy
};

var Impl = {
  Disposable: Disposable,
  Point: Impl_Point,
  $$Range: $$Range,
  editorType: /* Atom */0,
  getExtensionPath: getExtensionPath,
  getFileName: getFileName,
  save: save,
  isAgda: isAgda,
  onDidChangeFileName: onDidChangeFileName,
  onDidChangeActivation: onDidChangeActivation,
  onDidCloseEditor: onDidCloseEditor,
  registerCommand: registerCommand,
  setContext: setContext,
  addToSubscriptions: addToSubscriptions,
  Config: Impl_Config,
  View: Impl_View,
  Decoration: Impl_Decoration,
  focus: focus,
  getCursorPosition: getCursorPosition,
  setCursorPosition: setCursorPosition,
  rangeForLine: rangeForLine,
  pointAtOffset: pointAtOffset,
  offsetAtPoint: offsetAtPoint,
  getText: getText,
  getTextInRange: getTextInRange,
  selectText: selectText,
  setText: setText,
  insertText: insertText,
  deleteText: deleteText
};

exports.Impl = Impl;
/* atom Not a pure module */
