// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Atom = require("atom");
var Util = require("util");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Parser$AgdaMode = require("../Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Highlighting$AgdaMode = require("../Highlighting.bs.js");

function add(annotation, instance) {
  var textEditor = instance[/* editors */0][/* source */1];
  var textBuffer = textEditor.getBuffer();
  var startPoint = textBuffer.positionForCharacterIndex(annotation[/* start */0] - 1 | 0);
  var endPoint = textBuffer.positionForCharacterIndex(annotation[/* end_ */1] - 1 | 0);
  var range = new Atom.Range(startPoint, endPoint);
  var marker = textEditor.markBufferRange(range);
  instance[/* highlightings */4].push(marker);
  var types = annotation[/* types */2].join(" ");
  textEditor.decorateMarker(marker, {
        type: "highlight",
        class: "highlight-decoration " + types
      });
  return /* () */0;
}

function addMany(annotations, instance) {
  return Rebase.$$Array.forEach((function (annotation) {
                return add(annotation, instance);
              }), Rebase.$$Array.filter(Highlighting$AgdaMode.Annotation.shouldHighlight, annotations));
}

function addFromFile(filepath, instance) {
  var readFile = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          return /* () */0;
        }));
  return $$Promise.map($$Promise.Js.toResult($$Promise.Js.fromBsPromise(readFile(filepath))), (function (param) {
                if (param.tag) {
                  console.log(param[0]);
                  console.log("cannot read the indirect highlighting file: " + filepath);
                  return /* () */0;
                } else {
                  Rebase.$$Array.forEach((function (annotation) {
                          return add(annotation, instance);
                        }), Rebase.$$Array.filter(Highlighting$AgdaMode.Annotation.shouldHighlight, Rebase.$$Array.flatMap((function (x) {
                                  return x;
                                }), Rebase.$$Array.map((function (tokens) {
                                      if (tokens.tag) {
                                        return Highlighting$AgdaMode.Annotation.parseIndirectHighlightings(tokens[0]);
                                      } else {
                                        return /* array */[];
                                      }
                                    }), Rebase.$$Array.filterMap(Rebase.$$Option.fromResult, Parser$AgdaMode.SExpression.parse(param[0].toString()))))));
                  return /* () */0;
                }
              }));
}

function destroyAll(instance) {
  Rebase.$$Array.forEach((function (prim) {
          prim.destroy();
          return /* () */0;
        }), instance[/* highlightings */4]);
  instance[/* highlightings */4] = /* array */[];
  return /* () */0;
}

function execute(instance, param) {
  if (param.tag) {
    var filepath = param[0];
    return $$Promise.map($$Promise.map(addFromFile(filepath, instance), (function (param) {
                      return /* Ok */Caml_chrome_debugger.variant("Ok", 0, [(Fs.unlink(filepath, (function (param) {
                                          return /* () */0;
                                        })), /* () */0)]);
                    })), (function (param) {
                  return /* array */[];
                }));
  } else {
    addMany(param[0], instance);
    return $$Promise.resolved(/* array */[]);
  }
}

exports.add = add;
exports.addMany = addMany;
exports.addFromFile = addFromFile;
exports.destroyAll = destroyAll;
exports.execute = execute;
/* fs Not a pure module */
