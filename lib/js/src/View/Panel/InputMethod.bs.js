// Generated by BUCKLESCRIPT VERSION 5.0.3, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var ReactUpdate = require("reason-react-update/lib/js/src/ReactUpdate.bs.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Hook$AgdaMode = require("../Hook.bs.js");
var Util$AgdaMode = require("../../Util.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Event$AgdaMode = require("../../Util/Event.bs.js");
var Editors$AgdaMode = require("../../Editors.bs.js");
var ReasonReactCompat = require("reason-react/lib/js/src/ReasonReactCompat.js");
var CandidateSymbols$AgdaMode = require("./CandidateSymbols.bs.js");
var KeymapJs = require("./../../../../../asset/keymap.js");

var rawKeymap = KeymapJs.default;

function toTrie(obj) {
  var symbol = (
  obj[">>"] || ""
);
  var subTrie = Js_dict.fromArray(Rebase.$$Array[/* map */0]((function (key) {
              return /* tuple */[
                      key,
                      toTrie((
    obj[key]
  ))
                    ];
            }), Rebase.$$Array[/* filter */10]((function (key) {
                  return key !== ">>";
                }), Object.keys(obj))));
  return /* record */Block.record([
            "symbol",
            "subTrie"
          ], [
            symbol,
            subTrie
          ]);
}

var keymap = toTrie(rawKeymap);

function toKeySuggestions(trie) {
  return Object.keys(trie[/* subTrie */1]);
}

function toCandidateSymbols(trie) {
  return trie[/* symbol */0];
}

function isInKeymap(input) {
  var _input = input;
  var _trie = keymap;
  while(true) {
    var trie = _trie;
    var input$1 = _input;
    var n = Rebase.$$String[/* length */1](input$1);
    if (n !== 0) {
      var key = Rebase.$$String[/* sub */9](0, 1, input$1);
      var rest = Rebase.$$String[/* sub */9](1, n - 1 | 0, input$1);
      var match = Js_dict.get(trie[/* subTrie */1], key);
      if (match !== undefined) {
        _trie = match;
        _input = rest;
        continue ;
      } else {
        return undefined;
      }
    } else {
      return trie;
    }
  };
}

function translate(input) {
  var match = isInKeymap(input.substr(1));
  if (match !== undefined) {
    var trie = match;
    var keySuggestions = Object.keys(trie[/* subTrie */1]);
    var candidateSymbols = trie[/* symbol */0];
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              Rebase.$$Array[/* get */17](candidateSymbols, 0),
              Rebase.$$Array[/* length */16](keySuggestions) !== 0,
              keySuggestions,
              candidateSymbols
            ]);
  } else {
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              undefined,
              false,
              [],
              []
            ]);
  }
}

var initialBuffer = /* record */Block.record([
    "surface",
    "underlying"
  ], [
    "",
    ""
  ]);

var initialTranslation = translate("");

var initialState_001 = /* decorations : array */[];

var initialState_002 = /* markers : array */[];

var initialState = /* record */Block.record([
    "activated",
    "decorations",
    "markers",
    "markersDisposables",
    "buffer",
    "translation"
  ], [
    false,
    initialState_001,
    initialState_002,
    undefined,
    initialBuffer,
    initialTranslation
  ]);

function markerOnDidChange(editors, state, send, $$event) {
  var rangeOld = new Atom.Range($$event.oldTailBufferPosition, $$event.oldHeadBufferPosition);
  var rangeNew = new Atom.Range($$event.newTailBufferPosition, $$event.newHeadBufferPosition);
  var comparison = rangeNew.compare(rangeOld);
  var textBuffer = Editors$AgdaMode.Focus[/* get */0](editors).getBuffer();
  if (rangeNew.isEmpty()) {
    return Curry._1(send, /* Deactivate */1);
  } else {
    var surfaceBuffer = textBuffer.getTextInRange(rangeNew);
    if (surfaceBuffer !== state[/* buffer */4][/* surface */0]) {
      if (comparison === -1) {
        var insertedChar = textBuffer.getTextInRange(rangeNew).substr(-1);
        Curry._1(send, /* InsertUnderlying */Block.variant("InsertUnderlying", 0, [insertedChar]));
      }
      if (comparison === 1) {
        return Curry._1(send, /* Backspace */2);
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
}

function insertActualBuffer(editors, $$char) {
  var editor = Editors$AgdaMode.Focus[/* get */0](editors);
  var textBuffer = editor.getBuffer();
  var getCharIndex = function (selection) {
    var start = selection.getBufferRange().start;
    return textBuffer.characterIndexForPosition(start);
  };
  var compareSelection = function (a, b) {
    var indexA = getCharIndex(a);
    var indexB = getCharIndex(b);
    return Caml_primitive.caml_int_compare(indexA, indexB);
  };
  var selections = editor.getSelections();
  $$Array.sort(compareSelection, selections);
  return Rebase.$$Array[/* forEach */8]((function (selection) {
                var range = selection.getBufferRange();
                textBuffer.setTextInRange(range, $$char);
                return /* () */0;
              }), selections);
}

function reducer(editors, action, state) {
  if (typeof action === "number") {
    switch (action) {
      case 0 : 
          var match = state[/* activated */0];
          if (match) {
            return /* SideEffects */Block.variant("SideEffects", 2, [(function (param) {
                          var send = param[/* send */0];
                          if (Rebase.$$String[/* isEmpty */5](state[/* buffer */4][/* underlying */1])) {
                            Curry._1(send, /* Deactivate */1);
                            return undefined;
                          } else {
                            Curry._1(send, /* InsertSurface */Block.variant("InsertSurface", 2, ["\\"]));
                            return undefined;
                          }
                        })]);
          } else {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "decorations",
                          "markers",
                          "markersDisposables",
                          "buffer",
                          "translation"
                        ], [
                          true,
                          state[/* decorations */1],
                          state[/* markers */2],
                          state[/* markersDisposables */3],
                          state[/* buffer */4],
                          state[/* translation */5]
                        ]),
                      (function (param) {
                          var send = param[/* send */0];
                          var focusedEditor = Editors$AgdaMode.Focus[/* get */0](editors);
                          atom.views.getView(focusedEditor).classList.add("agda-mode-input-method-activated");
                          var markers = Rebase.$$Array[/* map */0]((function (range) {
                                  return focusedEditor.markBufferRange(range.copy());
                                }), focusedEditor.getSelectedBufferRanges());
                          var markersDisposables = Rebase.$$Option[/* map */0]((function (marker) {
                                  var garbages = new Atom.CompositeDisposable();
                                  garbages.add(marker.onDidChange((function (param) {
                                              return markerOnDidChange(editors, state, send, param);
                                            })));
                                  garbages.add(Editors$AgdaMode.Focus[/* get */0](editors).onDidChangeCursorPosition((function ($$event) {
                                              var point = $$event.newBufferPosition;
                                              var ranges = Rebase.$$Array[/* map */0]((function (prim) {
                                                      return prim.getBufferRange();
                                                    }), markers);
                                              var inRange = Rebase.$$Array[/* exists */9]((function (param) {
                                                      return param.containsPoint(point);
                                                    }), ranges);
                                              if (inRange) {
                                                return 0;
                                              } else {
                                                return Curry._1(send, /* Deactivate */1);
                                              }
                                            })));
                                  return garbages;
                                }), Rebase.$$Array[/* get */17](markers, 0));
                          var decorations = Rebase.$$Array[/* map */0]((function (marker) {
                                  return focusedEditor.decorateMarker(marker, {
                                              type: "highlight",
                                              class: "input-method-decoration"
                                            });
                                }), markers);
                          Curry._1(send, /* UpdateMarkers */Block.variant("UpdateMarkers", 1, [
                                  markers,
                                  decorations,
                                  markersDisposables
                                ]));
                          Curry._1(send, /* InsertSurface */Block.variant("InsertSurface", 2, ["\\"]));
                          return undefined;
                        })
                    ]);
          }
      case 1 : 
          var match$1 = state[/* activated */0];
          if (match$1) {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "decorations",
                          "markers",
                          "markersDisposables",
                          "buffer",
                          "translation"
                        ], [
                          false,
                          state[/* decorations */1],
                          state[/* markers */2],
                          state[/* markersDisposables */3],
                          initialBuffer,
                          initialTranslation
                        ]),
                      (function (param) {
                          atom.views.getView(Editors$AgdaMode.Focus[/* get */0](editors)).classList.remove("agda-mode-input-method-activated");
                          Rebase.$$Array[/* forEach */8]((function (prim) {
                                  prim.destroy();
                                  return /* () */0;
                                }), state[/* markers */2]);
                          Rebase.$$Array[/* forEach */8]((function (prim) {
                                  prim.destroy();
                                  return /* () */0;
                                }), state[/* decorations */1]);
                          Rebase.$$Option[/* map */0]((function (prim) {
                                  prim.dispose();
                                  return /* () */0;
                                }), state[/* markersDisposables */3]);
                          return undefined;
                        })
                    ]);
          } else {
            return /* NoUpdate */0;
          }
      case 2 : 
          var init = function (s) {
            return s.substring(0, Rebase.$$String[/* length */1](s) - 1 | 0);
          };
          var surface = init(state[/* buffer */4][/* surface */0]);
          var input = init(state[/* buffer */4][/* underlying */1]);
          var translation = translate(input);
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposables",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        state[/* decorations */1],
                        state[/* markers */2],
                        state[/* markersDisposables */3],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            surface,
                            input
                          ]),
                        translation
                      ])]);
      
    }
  } else {
    switch (action.tag | 0) {
      case 0 : 
          var input$1 = state[/* buffer */4][/* underlying */1] + action[0];
          var translation$1 = translate(input$1);
          var match$2 = translation$1[/* symbol */0];
          if (match$2 !== undefined) {
            var symbol = match$2;
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "decorations",
                          "markers",
                          "markersDisposables",
                          "buffer",
                          "translation"
                        ], [
                          state[/* activated */0],
                          state[/* decorations */1],
                          state[/* markers */2],
                          state[/* markersDisposables */3],
                          Block.record([
                              "surface",
                              "underlying"
                            ], [
                              symbol,
                              input$1
                            ]),
                          translation$1
                        ]),
                      (function (param) {
                          var send = param[/* send */0];
                          Curry._1(send, /* RewriteSurface */Block.variant("RewriteSurface", 4, [symbol]));
                          if (!translation$1[/* further */1]) {
                            Curry._1(send, /* Deactivate */1);
                          }
                          return undefined;
                        })
                    ]);
          } else {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "decorations",
                          "markers",
                          "markersDisposables",
                          "buffer",
                          "translation"
                        ], [
                          state[/* activated */0],
                          state[/* decorations */1],
                          state[/* markers */2],
                          state[/* markersDisposables */3],
                          Block.record([
                              "surface",
                              "underlying"
                            ], [
                              state[/* buffer */4][/* surface */0],
                              input$1
                            ]),
                          translation$1
                        ]),
                      (function (param) {
                          if (!translation$1[/* further */1]) {
                            Curry._1(param[/* send */0], /* Deactivate */1);
                          }
                          return undefined;
                        })
                    ]);
          }
      case 1 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposables",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        action[1],
                        action[0],
                        action[2],
                        state[/* buffer */4],
                        state[/* translation */5]
                      ])]);
      case 2 : 
          var $$char = action[0];
          var init$1 = state[/* buffer */4];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposables",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        state[/* decorations */1],
                        state[/* markers */2],
                        state[/* markersDisposables */3],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            state[/* buffer */4][/* surface */0] + $$char,
                            init$1[/* underlying */1]
                          ]),
                        state[/* translation */5]
                      ]),
                    (function (param) {
                        insertActualBuffer(editors, $$char);
                        return undefined;
                      })
                  ]);
      case 3 : 
          var $$char$1 = action[0];
          var init$2 = state[/* buffer */4];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposables",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        state[/* decorations */1],
                        state[/* markers */2],
                        state[/* markersDisposables */3],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            state[/* buffer */4][/* surface */0] + $$char$1,
                            init$2[/* underlying */1]
                          ]),
                        state[/* translation */5]
                      ]),
                    (function (param) {
                        insertActualBuffer(editors, $$char$1);
                        Curry._1(param[/* send */0], /* InsertUnderlying */Block.variant("InsertUnderlying", 0, [$$char$1]));
                        return undefined;
                      })
                  ]);
      case 4 : 
          var string = action[0];
          var init$3 = state[/* buffer */4];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposables",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        state[/* decorations */1],
                        state[/* markers */2],
                        state[/* markersDisposables */3],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            string,
                            init$3[/* underlying */1]
                          ]),
                        state[/* translation */5]
                      ]),
                    (function (param) {
                        Rebase.$$Array[/* forEach */8]((function (marker) {
                                Editors$AgdaMode.Focus[/* get */0](editors).getBuffer().setTextInRange(marker.getBufferRange(), string);
                                return /* () */0;
                              }), state[/* markers */2]);
                        return undefined;
                      })
                  ]);
      
    }
  }
}

function InputMethod(Props) {
  var editors = Props.editors;
  var interceptAndInsertKey = Props.interceptAndInsertKey;
  var activateInputMethod = Props.activateInputMethod;
  var onActivationChange = Props.onActivationChange;
  var isActive = Props.isActive;
  var match = ReactUpdate.useReducer(initialState, (function (param, param$1) {
          return reducer(editors, param, param$1);
        }));
  var state = match[0];
  var translation = state[/* translation */5];
  var buffer = state[/* buffer */4];
  var activated = state[/* activated */0];
  var send = match[1];
  React.useEffect((function () {
          Curry._1(onActivationChange, activated);
          return undefined;
        }), /* array */[activated]);
  React.useEffect((function () {
          return Rebase.$$Option[/* some */11](Event$AgdaMode.onOk((function (activate) {
                              return Curry._1(send, activate ? /* Activate */0 : /* Deactivate */1);
                            }))(activateInputMethod));
        }));
  React.useEffect((function () {
          return Rebase.$$Option[/* some */11](Event$AgdaMode.onOk((function ($$char) {
                              return Curry._1(send, /* InsertSurfaceAndUnderlying */Block.variant("InsertSurfaceAndUnderlying", 3, [$$char]));
                            }))(interceptAndInsertKey));
        }));
  Hook$AgdaMode.useAtomListener((function (param) {
          return atom.commands.add("atom-text-editor.agda-mode-input-method-activated", "editor:newline", (function ($$event) {
                        if (state[/* activated */0]) {
                          Curry._1(send, /* Deactivate */1);
                          $$event.stopImmediatePropagation();
                          return /* () */0;
                        } else {
                          return 0;
                        }
                      }));
        }));
  var className = Curry._1(Util$AgdaMode.ClassName[/* serialize */2], Util$AgdaMode.ClassName[/* addWhen */1]("hidden", !activated, /* :: */Block.simpleVariant("::", [
              "input-method",
              /* [] */0
            ])));
  var bufferClassName = Curry._1(Util$AgdaMode.ClassName[/* serialize */2], Util$AgdaMode.ClassName[/* addWhen */1]("hidden", Rebase.$$String[/* isEmpty */5](buffer[/* underlying */1]), /* :: */Block.simpleVariant("::", [
              "inline-block",
              /* :: */Block.simpleVariant("::", [
                  "buffer",
                  /* [] */0
                ])
            ])));
  return React.createElement("section", {
              className: className
            }, React.createElement("div", {
                  className: "keyboard"
                }, React.createElement("div", {
                      className: bufferClassName
                    }, buffer[/* underlying */1]), Block.spliceApply(React.createElement, [
                      "div",
                      {
                        className: "keys btn-group btn-group-sm"
                      },
                      Rebase.$$Array[/* map */0]((function (key) {
                              return React.createElement("button", {
                                          key: key,
                                          className: "btn",
                                          onClick: (function (param) {
                                              return Curry._1(send, /* InsertSurfaceAndUnderlying */Block.variant("InsertSurfaceAndUnderlying", 3, [key]));
                                            })
                                        }, key);
                            }), translation[/* keySuggestions */2])
                    ])), React.createElement(CandidateSymbols$AgdaMode.make, {
                  isActive: isActive,
                  candidateSymbols: translation[/* candidateSymbols */3],
                  updateTranslation: (function (replace) {
                      if (replace !== undefined) {
                        return Curry._1(send, /* RewriteSurface */Block.variant("RewriteSurface", 4, [replace]));
                      } else {
                        return /* () */0;
                      }
                    }),
                  chooseSymbol: (function (symbol) {
                      Curry._1(send, /* InsertSurfaceAndUnderlying */Block.variant("InsertSurfaceAndUnderlying", 3, [symbol]));
                      return Curry._1(send, /* Deactivate */1);
                    })
                }));
}

var component = ReasonReact.statelessComponent("InputMethod");

function make(editors, interceptAndInsertKey, activateInputMethod, onActivationChange, isActive, children) {
  return ReasonReactCompat.wrapReactForReasonReact(InputMethod, {
              editors: editors,
              interceptAndInsertKey: interceptAndInsertKey,
              activateInputMethod: activateInputMethod,
              onActivationChange: onActivationChange,
              isActive: isActive
            }, children);
}

var Jsx2 = /* module */Block.localModule([
    "component",
    "make"
  ], [
    component,
    make
  ]);

var sort = $$Array.sort;

var Garbages = 0;

var make$1 = InputMethod;

exports.sort = sort;
exports.rawKeymap = rawKeymap;
exports.toTrie = toTrie;
exports.keymap = keymap;
exports.toKeySuggestions = toKeySuggestions;
exports.toCandidateSymbols = toCandidateSymbols;
exports.isInKeymap = isInKeymap;
exports.translate = translate;
exports.Garbages = Garbages;
exports.initialBuffer = initialBuffer;
exports.initialTranslation = initialTranslation;
exports.initialState = initialState;
exports.markerOnDidChange = markerOnDidChange;
exports.insertActualBuffer = insertActualBuffer;
exports.reducer = reducer;
exports.make = make$1;
exports.Jsx2 = Jsx2;
/* rawKeymap Not a pure module */
