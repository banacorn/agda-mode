// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Util$AgdaMode = require("./Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Webapi__Dom__Element = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__Element.js");
var Webapi__Dom__Document = require("bs-webapi/lib/js/src/Webapi/Webapi__Dom/Webapi__Dom__Document.js");

function textEditor(param) {
  return param[/* textEditor */0];
}

function index(param) {
  return param[/* index */1];
}

function range(param) {
  return param[/* range */2];
}

function marker(param) {
  return param[/* marker */3];
}

function content(param) {
  return param[/* content */4];
}

function disposables(param) {
  return param[/* disposables */5];
}

function parse(filepath) {
  if ((/\.lagda.rst$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateReStructuredText */2;
  } else if ((/\.lagda.md$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateMarkdown */3;
  } else if ((/\.lagda.tex$|\.lagda$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateTeX */1;
  } else {
    return /* Agda */0;
  }
}

var FileType = /* module */Caml_chrome_debugger.localModule(["parse"], [parse]);

function restoreBoundary(self, range) {
  self[/* textEditor */0].setTextInBufferRange(range, self[/* content */4]);
  return /* () */0;
}

function string_of_index(param) {
  if (param !== undefined) {
    return String(param);
  } else {
    return "*";
  }
}

function removeBoundary(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var content = Rebase.$$String[/* trim */8](self[/* textEditor */0].getTextInBufferRange(range));
  self[/* textEditor */0].setTextInBufferRange(self[/* range */2], content);
  return /* () */0;
}

function writeLines(contents, self) {
  var textBuffer = self[/* textEditor */0].getBuffer();
  var rowNumbers = self[/* range */2].getRows();
  var match = Rebase.$$Array[/* get */17](rowNumbers, 0);
  if (match !== undefined) {
    var firstRowNumber = match;
    var firstRowRange = textBuffer.rangeForRow(firstRowNumber, false);
    var firstRow = self[/* textEditor */0].getTextInBufferRange(firstRowRange);
    var indentSpaces = " ".repeat(Util$AgdaMode.$$String[/* indentedBy */3](firstRow));
    var indentedContents = Rebase.$$String[/* concat */0]("\n", Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* map */0]((function (line) {
                        return indentSpaces + line;
                      }), contents))));
    var match$1 = Rebase.$$Array[/* get */17](rowNumbers, Rebase.$$Array[/* length */16](rowNumbers) - 1 | 0);
    if (match$1 !== undefined) {
      textBuffer.deleteRows(firstRowNumber, match$1);
    }
    var position = firstRowRange.start;
    textBuffer.insert(position, indentedContents);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function writeLambda(contents, self) {
  var scanRow = self[/* range */2].start.row;
  var scanRowText = self[/* textEditor */0].getTextInBufferRange(new Atom.Range(new Atom.Point(scanRow, 0), self[/* range */2].start));
  var indent = Util$AgdaMode.$$String[/* indentedBy */3](scanRowText);
  var match = Util$AgdaMode.$$String[/* lastIndexOf */2](";", scanRowText);
  var scanColStart = match !== undefined ? match + 1 | 0 : indent;
  var scanColEnd = self[/* range */2].start.column;
  var bracketCount = 0;
  var i = scanColEnd - 1 | 0;
  while(i >= scanColStart && bracketCount >= 0) {
    var i$prime = i;
    if (i$prime !== 0) {
      var match$1 = scanRowText.charAt(i$prime - 1 | 0);
      switch (match$1) {
        case "{" : 
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" : 
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var rewriteRangeStart = new Atom.Point(scanRow, i + 1 | 0);
  var rewriteRangeEnd = self[/* range */2].end;
  var rewriteRange = new Atom.Range(rewriteRangeStart, rewriteRangeEnd);
  var isLambdaWhere = (i + 1 | 0) === indent;
  if (isLambdaWhere) {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, Rebase.$$String[/* joinWith */11]("\n" + " ".repeat(indent), Rebase.List[/* fromArray */12](contents)));
    return /* () */0;
  } else {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, " " + Rebase.$$String[/* joinWith */11](" ; ", Rebase.List[/* fromArray */12](contents)));
    return /* () */0;
  }
}

function destroy(self) {
  self[/* marker */3].destroy();
  self[/* disposables */5].dispose();
  return /* () */0;
}

function make(textEditor, index, range) {
  var textBuffer = textEditor.getBuffer();
  var startPoint = textBuffer.positionForCharacterIndex(range[0]);
  var endPoint = textBuffer.positionForCharacterIndex(range[1]);
  var range$1 = new Atom.Range(startPoint, endPoint);
  var content = textBuffer.getTextInRange(range$1);
  var marker = textEditor.markBufferRange(range$1);
  var disposables = new Atom.CompositeDisposable();
  var t = /* record */Caml_chrome_debugger.record([
      "textEditor",
      "index",
      "range",
      "marker",
      "content",
      "disposables"
    ], [
      textEditor,
      index,
      range$1,
      marker,
      content,
      disposables
    ]);
  var match;
  if (index !== undefined) {
    var i = index;
    match = /* tuple */[
      Rebase.$$String[/* length */1](String(i)),
      String(i)
    ];
  } else {
    match = /* tuple */[
      1,
      "*"
    ];
  }
  var element = document.createElement("div");
  element.innerHTML = match[1];
  element.classList.add("goal-index");
  element.setAttribute("style", "left: " + (String((-match[0] | 0) - 2 | 0) + "ex ; top: -1.5em"));
  textEditor.decorateMarker(marker, {
        type: "highlight",
        class: "goal",
        style: { }
      });
  textEditor.decorateMarker(marker, {
        type: "overlay",
        class: "",
        style: { },
        item: element,
        onlyHead: false,
        onlyEmpty: false,
        onlyNonEmpty: false,
        omitEmptyLastRow: true,
        position: "head",
        order: undefined,
        avoidOverflow: true
      });
  disposables.add(marker.onDidChange((function (_event) {
              var newRange = marker.getBufferRange();
              var newContent = textBuffer.getTextInRange(newRange);
              var deltaLeft = Util$AgdaMode.$$String[/* indexOf */1]("{!", newContent);
              var deltaRight = Util$AgdaMode.$$String[/* lastIndexOf */2]("!}", newContent);
              if (deltaLeft !== undefined) {
                var left = deltaLeft;
                var exit = 0;
                if (left !== 0 || !(deltaRight !== undefined && deltaRight === 1)) {
                  exit = 1;
                } else {
                  return restoreBoundary(t, newRange);
                }
                if (exit === 1) {
                  if (deltaRight !== undefined) {
                    var right$prime = (deltaRight - Rebase.$$String[/* length */1](newContent) | 0) + 2 | 0;
                    t[/* range */2] = newRange.translate(new Atom.Point(0, left), new Atom.Point(0, right$prime));
                    t[/* content */4] = textBuffer.getTextInRange(t[/* range */2]);
                    t[/* marker */3].setBufferRange(t[/* range */2], {
                          reversed: false
                        });
                    return /* () */0;
                  } else {
                    return restoreBoundary(t, newRange);
                  }
                }
                
              } else if (deltaRight !== undefined) {
                return restoreBoundary(t, newRange);
              } else {
                return destroy(t);
              }
            })));
  return t;
}

function getContent(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  return Parser$AgdaMode.userInput(self[/* textEditor */0].getTextInBufferRange(range));
}

function setContent(text, self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var match = self[/* index */1];
  var paddingSpaces = match !== undefined ? " ".repeat(Rebase.$$String[/* length */1](String(match))) : " ";
  return self[/* textEditor */0].setTextInBufferRange(range, " " + (text + (" " + paddingSpaces)));
}

function selectContent(self) {
  var match = self[/* index */1];
  var indexWidth = match !== undefined ? Rebase.$$String[/* length */1](String(match)) : 1;
  var range = self[/* range */2].translate(new Atom.Point(0, 3), new Atom.Point(0, -(3 + indexWidth | 0) | 0));
  self[/* textEditor */0].setSelectedBufferRange(range, {
        reversed: false,
        preserveFolds: true
      });
  return /* () */0;
}

function isEmpty(self) {
  return Rebase.$$String[/* isEmpty */5](getContent(self).replace((/(\s|\\n)*/), ""));
}

function buildHaskellRange(old, filepath, self) {
  var start = self[/* range */2].start;
  var startIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(start);
  var end_ = self[/* range */2].end;
  var endIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(end_);
  var startIndex$prime = String(startIndex + 3 | 0);
  var startRow = String(start.row + 1 | 0);
  var startColumn = String(start.column + 3 | 0);
  var startPart = "" + (String(startIndex$prime) + (" " + (String(startRow) + (" " + (String(startColumn) + "")))));
  var endIndex$prime = String(endIndex - 3 | 0);
  var endRow = String(end_.row + 1 | 0);
  var endColumn = String(end_.column - 1 | 0);
  var endPart = "" + (String(endIndex$prime) + (" " + (String(endRow) + (" " + (String(endColumn) + "")))));
  if (old) {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(startPart) + (") (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(endPart) + ")])")))))));
  } else {
    return "(intervalsToRange (Just (mkAbsolute \"" + (String(filepath) + ("\")) [Interval (Pn () " + (String(startPart) + (") (Pn () " + (String(endPart) + ")])")))));
  }
}

exports.textEditor = textEditor;
exports.index = index;
exports.range = range;
exports.marker = marker;
exports.content = content;
exports.disposables = disposables;
exports.FileType = FileType;
exports.restoreBoundary = restoreBoundary;
exports.string_of_index = string_of_index;
exports.removeBoundary = removeBoundary;
exports.writeLines = writeLines;
exports.writeLambda = writeLambda;
exports.destroy = destroy;
exports.make = make;
exports.getContent = getContent;
exports.setContent = setContent;
exports.selectContent = selectContent;
exports.isEmpty = isEmpty;
exports.buildHaskellRange = buildHaskellRange;
/* atom Not a pure module */
