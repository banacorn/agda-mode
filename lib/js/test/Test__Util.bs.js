// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Diff = require("diff");
var Path = require("path");
var Util = require("util");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Assert$BsMocha = require("bs-mocha/lib/js/src/Assert.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Parser$AgdaMode = require("../src/Parser.bs.js");
var Response$AgdaMode = require("../src/Response.bs.js");
var Connection$AgdaMode = require("../src/Connection.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

var base = Path.join(__dirname, "../../../");

function file(path) {
  return Path.join(base, path);
}

function asset(path) {
  return Path.join(Path.join(base, "test/asset"), path);
}

function openFile(uri) {
  return atom.workspace.open(uri);
}

function closeFile(uri) {
  var pane = atom.workspace.paneForURI(uri);
  if (pane !== undefined) {
    var p = Caml_option.valFromOption(pane);
    var item = p.itemForURI(uri);
    if (item !== undefined) {
      return p.destroyItem(Caml_option.valFromOption(item), true);
    } else {
      return Promise.resolve(false);
    }
  } else {
    return Promise.resolve(false);
  }
}

function getActivePackageNames(param) {
  return Rebase.$$Array[/* map */0]((function (o) {
                return o.name;
              }), atom.packages.getActivePackages());
}

function getLoadedPackageNames(param) {
  return Rebase.$$Array[/* map */0]((function (o) {
                return o.name;
              }), atom.packages.getLoadedPackages());
}

var DispatchFailure = Caml_exceptions.create("Test__Util-AgdaMode.DispatchFailure");

function dispatch(editor, $$event) {
  var element = atom.views.getView(editor);
  var result = atom.commands.dispatch(element, $$event);
  if (result !== undefined) {
    return Promise.resolve(/* () */0);
  } else {
    return Promise.reject([
                DispatchFailure,
                $$event
              ]);
  }
}

function getGoldenFilepaths(dirname) {
  var readdir = Util.promisify((function (prim, prim$1) {
          Fs.readdir(prim, prim$1);
          return /* () */0;
        }));
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return readdir(dirname).then((function (paths) {
                return Promise.resolve(Rebase.$$Array[/* map */0](toBasename, Rebase.$$Array[/* filter */10](isInFile, paths)));
              }));
}

function getGoldenFilepathsSync(dirname) {
  var isInFile = function (param) {
    return param.endsWith(".in");
  };
  var toBasename = function (path) {
    return Path.join(dirname, Path.basename(path, ".in"));
  };
  return Rebase.$$Array[/* map */0](toBasename, Rebase.$$Array[/* filter */10](isInFile, Fs.readdirSync(dirname)));
}

var GoldenFileMissing = Caml_exceptions.create("Test__Util-AgdaMode.GoldenFileMissing");

function readGoldenFile(filepath) {
  var readFile = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          return /* () */0;
        }));
  return Promise.all(/* array */[
                readFile(filepath + ".in"),
                readFile(filepath + ".out")
              ]).then((function (param) {
                if (param.length !== 2) {
                  return Promise.reject([
                              GoldenFileMissing,
                              filepath
                            ]);
                } else {
                  var input = param[0];
                  var output = param[1];
                  return Promise.resolve(/* tuple */[
                              filepath,
                              input.toString(),
                              output.toString()
                            ]);
                }
              }));
}

function parseAsResponse(input) {
  var partial_arg = Rebase.Result[/* flatMap */6];
  var toResponse = Curry._1(Parser$AgdaMode.Incr[/* Event */0][/* map */1], (function (param) {
          return partial_arg(Response$AgdaMode.parse, param);
        }));
  var output = /* record */Caml_chrome_debugger.record(["contents"], [""]);
  var parser = Parser$AgdaMode.SExpression[/* makeIncr */5]((function (x) {
          var param = Curry._1(toResponse, x);
          if (param) {
            var match = param[0];
            if (match.tag) {
              return Assert$BsMocha.fail("Parsing failed");
            } else {
              output[0] = output[0] + (Response$AgdaMode.toString(match[0]) + "\n");
              return /* () */0;
            }
          } else {
            return /* () */0;
          }
        }));
  Connection$AgdaMode.parseAgdaOutput(parser, input);
  return output[0];
}

function parseAsResponseAndCompare(param) {
  var actual = parseAsResponse(param[1]);
  Rebase.$$Array[/* forEach */8]((function (diff) {
          if (diff.added) {
            Assert$BsMocha.fail("Unexpected string added: " + diff.value);
          }
          if (diff.removed) {
            return Assert$BsMocha.fail("Unexpected string missing: " + diff.value);
          } else {
            return 0;
          }
        }), Rebase.$$Array[/* filter */10]((function (diff) {
              if (diff.added) {
                return true;
              } else {
                return diff.removed;
              }
            }), Diff.diffLines(param[2], actual)));
  return Promise.resolve(/* () */0);
}

exports.base = base;
exports.file = file;
exports.asset = asset;
exports.openFile = openFile;
exports.closeFile = closeFile;
exports.getActivePackageNames = getActivePackageNames;
exports.getLoadedPackageNames = getLoadedPackageNames;
exports.DispatchFailure = DispatchFailure;
exports.dispatch = dispatch;
exports.getGoldenFilepaths = getGoldenFilepaths;
exports.getGoldenFilepathsSync = getGoldenFilepathsSync;
exports.GoldenFileMissing = GoldenFileMissing;
exports.readGoldenFile = readGoldenFile;
exports.parseAsResponse = parseAsResponse;
exports.parseAsResponseAndCompare = parseAsResponseAndCompare;
/* base Not a pure module */
