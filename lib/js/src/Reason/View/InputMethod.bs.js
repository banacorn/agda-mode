// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Editors$AgdaMode = require("./Editors.bs.js");
var Keymap = require("./../../asset/keymap");

function toTrie(obj) {
  var symbol = (
  obj[">>"]
);
  var subTrie = Js_dict.fromArray(Rebase.$$Array[/* map */0]((function (key) {
              return /* tuple */[
                      key,
                      toTrie((
    obj[key]
  ))
                    ];
            }), Rebase.$$Array[/* filter */10]((function (key) {
                  return key !== ">>";
                }), Object.keys(obj))));
  return /* record */Block.record([
            "symbol",
            "subTrie"
          ], [
            symbol,
            subTrie
          ]);
}

var keymap = toTrie(Keymap.default);

function toKeySuggestions(trie) {
  return Object.keys(trie[/* subTrie */1]);
}

function toCandidateSymbols(trie) {
  return trie[/* symbol */0];
}

function isInKeymap(input) {
  var _input = input;
  var _trie = keymap;
  while(true) {
    var trie = _trie;
    var input$1 = _input;
    var n = Rebase.$$String[/* length */1](input$1);
    if (n !== 0) {
      var key = Rebase.$$String[/* sub */9](0, 1, input$1);
      var rest = Rebase.$$String[/* sub */9](1, n - 1 | 0, input$1);
      var match = trie[/* subTrie */1][key];
      if (match !== undefined) {
        _trie = match;
        _input = rest;
        continue ;
      } else {
        return undefined;
      }
    } else {
      return trie;
    }
  };
}

function translate(input) {
  var match = isInKeymap(input);
  if (match !== undefined) {
    var trie = match;
    var keySuggestions = Object.keys(trie[/* subTrie */1]);
    var candidateSymbols = trie[/* symbol */0];
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              Rebase.$$Array[/* get */17](candidateSymbols, 0),
              Rebase.$$Array[/* length */16](keySuggestions) !== 0,
              keySuggestions,
              candidateSymbols
            ]);
  } else {
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              undefined,
              false,
              [],
              []
            ]);
  }
}

var mute = /* record */Block.record(["contents"], [false]);

function muteEvent(callback) {
  mute[0] = true;
  console.log("mute!!");
  Curry._1(callback, /* () */0);
  mute[0] = false;
  console.log("unmute");
  return /* () */0;
}

function initialState(editors, param) {
  return /* record */Block.record([
            "editors",
            "activated",
            "decorations",
            "markers",
            "markersDisposable",
            "translation"
          ], [
            editors,
            false,
            [],
            [],
            undefined,
            Block.record([
                "symbol",
                "further",
                "keySuggestions",
                "candidateSymbols"
              ], [
                undefined,
                false,
                [],
                []
              ])
          ]);
}

function reducer(action, state) {
  if (typeof action === "number") {
    switch (action) {
      case 0 : 
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 2, [
                    /* record */Block.record([
                        "editors",
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposable",
                        "translation"
                      ], [
                        state[/* editors */0],
                        true,
                        state[/* decorations */2],
                        state[/* markers */3],
                        state[/* markersDisposable */4],
                        state[/* translation */5]
                      ]),
                    (function (_self) {
                        if (state[/* activated */1]) {
                          console.log("already activated");
                          return /* () */0;
                        } else {
                          console.log("activating!");
                          var editor = Editors$AgdaMode.getFocusedEditor(state[/* editors */0]);
                          atom.views.getView(editor).classList.add("agda-mode-input-method-activated");
                          var markers = Rebase.$$Array[/* map */0]((function (range) {
                                  return editor.markBufferRange(range.copy());
                                }), editor.getSelectedBufferRanges());
                          var match = Rebase.$$Array[/* get */17](markers, 0);
                          var markersDisposable = match !== undefined ? Rebase.Option[/* some */11](Js_primitive.valFromOption(match).onDidChange((function ($$event) {
                                        console.log("sending");
                                        console.log(mute);
                                        return Curry._1(_self[/* send */3], /* MarkerDidChange */Block.variant("MarkerDidChange", 0, [$$event]));
                                      }))) : undefined;
                          var decorations = Rebase.$$Array[/* map */0]((function (marker) {
                                  return editor.decorateMarker(marker, {
                                              type: /* highlight */-318745036,
                                              class: "input-method-decoration"
                                            });
                                }), markers);
                          Curry._1(_self[/* send */3], /* UpdateDecorations */Block.variant("UpdateDecorations", 1, [
                                  markers,
                                  decorations,
                                  markersDisposable
                                ]));
                          return muteEvent((function (param) {
                                        return Curry._1(_self[/* send */3], /* InsertCharToBuffer */Block.variant("InsertCharToBuffer", 3, ["\\"]));
                                      }));
                        }
                      })
                  ]);
      case 1 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "editors",
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposable",
                        "translation"
                      ], [
                        state[/* editors */0],
                        false,
                        state[/* decorations */2],
                        state[/* markers */3],
                        state[/* markersDisposable */4],
                        state[/* translation */5]
                      ])]);
      case 2 : 
          return /* SideEffects */Block.variant("SideEffects", 1, [(function (_self) {
                        console.log("disposing bodies");
                        return /* () */0;
                      })]);
      
    }
  } else {
    switch (action.tag | 0) {
      case 0 : 
          var $$event = action[0];
          return /* SideEffects */Block.variant("SideEffects", 1, [(function (self) {
                        console.log("MarkerDidChange!");
                        console.log(mute[0]);
                        if (mute[0]) {
                          return 0;
                        } else {
                          var rangeOld = new Atom.Range($$event.oldTailBufferPosition, $$event.oldHeadBufferPosition);
                          var rangeNew = new Atom.Range($$event.newTailBufferPosition, $$event.newHeadBufferPosition);
                          var textBuffer = Editors$AgdaMode.getFocusedEditor(state[/* editors */0]).getBuffer();
                          var text = textBuffer.getTextInRange(rangeNew);
                          var lengthOld = textBuffer.characterIndexForPosition(rangeOld.end) - textBuffer.characterIndexForPosition(rangeOld.start) | 0;
                          var lengthNew = textBuffer.characterIndexForPosition(rangeNew.end) - textBuffer.characterIndexForPosition(rangeNew.start) | 0;
                          if (rangeNew.isEmpty()) {
                            return Curry._1(self[/* send */3], /* Deactivate */1);
                          } else {
                            if (lengthNew > lengthOld) {
                              var translation = translate(text);
                              Curry._1(self[/* send */3], /* UpdateTranslation */Block.variant("UpdateTranslation", 2, [translation]));
                              var match = translation[/* symbol */0];
                              if (match !== undefined) {
                                var s = match;
                                muteEvent((function (param) {
                                        var textBuffer = Editors$AgdaMode.getFocusedEditor(state[/* editors */0]).getBuffer();
                                        return Rebase.$$Array[/* forEach */8]((function (marker) {
                                                      var range = marker.getBufferRange();
                                                      textBuffer.setTextInRange(range, s);
                                                      return /* () */0;
                                                    }), self[/* state */1][/* markers */3]);
                                      }));
                              }
                              
                            }
                            if (lengthOld > lengthNew) {
                              var translation$1 = translate(text);
                              return Curry._1(self[/* send */3], /* UpdateTranslation */Block.variant("UpdateTranslation", 2, [translation$1]));
                            } else {
                              return 0;
                            }
                          }
                        }
                      })]);
      case 1 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "editors",
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposable",
                        "translation"
                      ], [
                        state[/* editors */0],
                        state[/* activated */1],
                        action[1],
                        action[0],
                        action[2],
                        state[/* translation */5]
                      ])]);
      case 2 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "editors",
                        "activated",
                        "decorations",
                        "markers",
                        "markersDisposable",
                        "translation"
                      ], [
                        state[/* editors */0],
                        state[/* activated */1],
                        state[/* decorations */2],
                        state[/* markers */3],
                        state[/* markersDisposable */4],
                        action[0]
                      ])]);
      case 3 : 
          var $$char = action[0];
          return /* SideEffects */Block.variant("SideEffects", 1, [(function (_self) {
                        console.log("inserting " + $$char);
                        var editor = Editors$AgdaMode.getFocusedEditor(state[/* editors */0]);
                        var textBuffer = editor.getBuffer();
                        var getCharIndex = function (selection) {
                          var start = selection.getBufferRange().start;
                          return textBuffer.characterIndexForPosition(start);
                        };
                        var compareSelection = function (a, b) {
                          var indexA = getCharIndex(a);
                          var indexB = getCharIndex(b);
                          return Caml_primitive.caml_int_compare(indexA, indexB);
                        };
                        var selections = editor.getSelections();
                        $$Array.sort(compareSelection, selections);
                        return Rebase.$$Array[/* forEach */8]((function (selection) {
                                      var range = selection.getBufferRange();
                                      textBuffer.delete(range);
                                      textBuffer.insert(range.start, $$char);
                                      if (textBuffer.getTextInRange(range) === "\\") {
                                        selection.clear();
                                        editor.addCursorAtBufferPosition(range.end);
                                        return /* () */0;
                                      } else {
                                        return 0;
                                      }
                                    }), selections);
                      })]);
      
    }
  }
}

var component = ReasonReact.reducerComponent("InputMethod");

function make(editors, interceptAndInsertKey, activate, _children) {
  return /* record */Block.record([
            "debugName",
            "reactClassInternal",
            "handedOffState",
            "willReceiveProps",
            "didMount",
            "didUpdate",
            "willUnmount",
            "willUpdate",
            "shouldUpdate",
            "render",
            "initialState",
            "retainedProps",
            "reducer",
            "jsElementWrapped"
          ], [
            component[/* debugName */0],
            component[/* reactClassInternal */1],
            component[/* handedOffState */2],
            component[/* willReceiveProps */3],
            (function (self) {
                Curry._1(interceptAndInsertKey, (function ($$char) {
                        return Curry._1(self[/* send */3], /* InsertCharToBuffer */Block.variant("InsertCharToBuffer", 3, [$$char]));
                      }));
                Curry._1(activate, (function (param) {
                        return Curry._1(self[/* send */3], /* Activate */0);
                      }));
                var garbages = new Atom.CompositeDisposable();
                garbages.add(atom.commands.add("atom-text-editor.agda-mode-input-method-activated", "editor:newline", (function ($$event) {
                            if (self[/* state */1][/* activated */1]) {
                              Curry._1(self[/* send */3], /* Deactivate */1);
                              $$event.stopImmediatePropagation();
                              return /* () */0;
                            } else {
                              return 0;
                            }
                          })));
                return Curry._1(self[/* onUnmount */4], (function (param) {
                              garbages.dispose();
                              return /* () */0;
                            }));
              }),
            component[/* didUpdate */5],
            component[/* willUnmount */6],
            component[/* willUpdate */7],
            component[/* shouldUpdate */8],
            (function (_self) {
                return null;
              }),
            (function (param) {
                return initialState(editors, param);
              }),
            component[/* retainedProps */11],
            reducer,
            component[/* jsElementWrapped */13]
          ]);
}

var sort = $$Array.sort;

var Garbages = 0;

exports.sort = sort;
exports.toTrie = toTrie;
exports.keymap = keymap;
exports.toKeySuggestions = toKeySuggestions;
exports.toCandidateSymbols = toCandidateSymbols;
exports.isInKeymap = isInKeymap;
exports.translate = translate;
exports.Garbages = Garbages;
exports.mute = mute;
exports.muteEvent = muteEvent;
exports.initialState = initialState;
exports.reducer = reducer;
exports.component = component;
exports.make = make;
/* keymap Not a pure module */
