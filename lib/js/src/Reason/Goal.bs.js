// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var ElementRe = require("bs-webapi/lib/js/src/dom/nodes/ElementRe.js");
var DocumentRe = require("bs-webapi/lib/js/src/dom/nodes/DocumentRe.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Util$AgdaMode = require("./Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");

function textEditor(param) {
  return param[/* textEditor */0];
}

function index(param) {
  return param[/* index */1];
}

function range(param) {
  return param[/* range */2];
}

function marker(param) {
  return param[/* marker */3];
}

function content(param) {
  return param[/* content */4];
}

function disposables(param) {
  return param[/* disposables */5];
}

function parse(filepath) {
  if ((/\.lagda.rst$/i).test(filepath)) {
    return /* LiterateReStructuredText */2;
  } else if ((/\.lagda.md$/i).test(filepath)) {
    return /* LiterateMarkdown */3;
  } else if ((/\.lagda.tex$|\.lagda$/i).test(filepath)) {
    return /* LiterateTeX */1;
  } else {
    return /* Agda */0;
  }
}

var FileType = /* module */Block.localModule(["parse"], [parse]);

function restoreBoundary(self, range) {
  self[/* textEditor */0].setTextInBufferRange(range, self[/* content */4]);
  return /* () */0;
}

function string_of_index(param) {
  if (param !== undefined) {
    return String(param);
  } else {
    return "*";
  }
}

function removeBoundary(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var content = Rebase.$$String[/* trim */8](self[/* textEditor */0].getTextInBufferRange(range));
  self[/* textEditor */0].setTextInBufferRange(self[/* range */2], content);
  return /* () */0;
}

function writeLines(self, contents) {
  var textBuffer = self[/* textEditor */0].getBuffer();
  var rowNumbers = self[/* range */2].getRows();
  var match = Rebase.$$Array[/* get */17](rowNumbers, 0);
  if (match !== undefined) {
    var firstRowNumber = match;
    var firstRowRange = textBuffer.rangeForRow(firstRowNumber, false);
    var firstRow = self[/* textEditor */0].getTextInBufferRange(firstRowRange);
    var indentSpaces = " ".repeat(Util$AgdaMode.$$String[/* indentedBy */3](firstRow));
    var indentedContents = Rebase.$$String[/* concat */0]("\n", Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* map */0]((function (line) {
                        return indentSpaces + line;
                      }), contents))));
    var match$1 = Rebase.$$Array[/* get */17](rowNumbers, Rebase.$$Array[/* length */16](rowNumbers) - 1 | 0);
    if (match$1 !== undefined) {
      textBuffer.deleteRows(firstRowNumber, match$1);
    }
    var position = firstRowRange.start;
    textBuffer.insert(position, indentedContents);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function writeLambda(self, contents) {
  var scanRow = self[/* range */2].start.row;
  var scanRowText = self[/* textEditor */0].getTextInBufferRange(new Atom.Range(new Atom.Point(scanRow, 0), self[/* range */2].start));
  var indent = Util$AgdaMode.$$String[/* indentedBy */3](scanRowText);
  var match = Util$AgdaMode.$$String[/* lastIndexOf */2](";", scanRowText);
  var scanColStart = match !== undefined ? match + 1 | 0 : indent;
  var scanColEnd = self[/* range */2].start.column;
  var bracketCount = 0;
  var i = scanColEnd - 1 | 0;
  while(i >= scanColStart && bracketCount >= 0) {
    var i$prime = i;
    if (i$prime !== 0) {
      var match$1 = scanRowText.charAt(i$prime - 1 | 0);
      switch (match$1) {
        case "{" : 
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" : 
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var rewriteRangeStart = new Atom.Point(scanRow, i + 1 | 0);
  var rewriteRangeEnd = self[/* range */2].end;
  var rewriteRange = new Atom.Range(rewriteRangeStart, rewriteRangeEnd);
  var isLambdaWhere = (i + 1 | 0) === indent;
  if (isLambdaWhere) {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, Rebase.$$String[/* joinWith */11]("\n" + " ".repeat(indent), Rebase.List[/* fromArray */12](contents)));
    return /* () */0;
  } else {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, " " + Rebase.$$String[/* joinWith */11](" ; ", Rebase.List[/* fromArray */12](contents)));
    return /* () */0;
  }
}

function destroy(self) {
  self[/* marker */3].destroy();
  self[/* disposables */5].dispose();
  return /* () */0;
}

function make(textEditor, index, range) {
  var textBuffer = textEditor.getBuffer();
  var startPoint = textBuffer.positionForCharacterIndex(range[0]);
  var endPoint = textBuffer.positionForCharacterIndex(range[1]);
  var range$1 = new Atom.Range(startPoint, endPoint);
  var content = textBuffer.getTextInRange(range$1);
  var marker = textEditor.markBufferRange(range$1);
  var disposables = new Atom.CompositeDisposable();
  var t = /* record */Block.record([
      "textEditor",
      "index",
      "range",
      "marker",
      "content",
      "disposables"
    ], [
      textEditor,
      index,
      range$1,
      marker,
      content,
      disposables
    ]);
  var match;
  if (index !== undefined) {
    var i = index;
    match = /* tuple */[
      Rebase.$$String[/* length */1](String(i)),
      String(i)
    ];
  } else {
    match = /* tuple */[
      1,
      "*"
    ];
  }
  var element = document.createElement("div");
  element.innerHTML = match[1];
  element.classList.add("goal-index");
  element.setAttribute("style", "left: " + (String((-match[0] | 0) - 2 | 0) + "ex ; top: -1.5em"));
  textEditor.decorateMarker(marker, {
        type: "highlight",
        class: "goal"
      });
  textEditor.decorateMarker(marker, {
        type: "overlay",
        item: element,
        position: "head"
      });
  disposables.add(marker.onDidChange((function (_event) {
              var newRange = marker.getBufferRange();
              var newContent = textBuffer.getTextInRange(newRange);
              var deltaLeft = Util$AgdaMode.$$String[/* indexOf */1]("{!", newContent);
              var deltaRight = Util$AgdaMode.$$String[/* lastIndexOf */2]("!}", newContent);
              if (deltaLeft !== undefined) {
                var left = deltaLeft;
                var exit = 0;
                if (left !== 0 || !(deltaRight !== undefined && deltaRight === 1)) {
                  exit = 1;
                } else {
                  return restoreBoundary(t, newRange);
                }
                if (exit === 1) {
                  if (deltaRight !== undefined) {
                    var right$prime = (deltaRight - Rebase.$$String[/* length */1](newContent) | 0) + 2 | 0;
                    t[/* range */2] = newRange.translate(new Atom.Point(0, left), new Atom.Point(0, right$prime));
                    t[/* content */4] = textBuffer.getTextInRange(t[/* range */2]);
                    t[/* marker */3].setBufferRange(t[/* range */2], {
                          reversed: false
                        });
                    return /* () */0;
                  } else {
                    return restoreBoundary(t, newRange);
                  }
                }
                
              } else if (deltaRight !== undefined) {
                return restoreBoundary(t, newRange);
              } else {
                return destroy(t);
              }
            })));
  return t;
}

function getContent(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  return Parser$AgdaMode.userInput(self[/* textEditor */0].getTextInBufferRange(range));
}

function setContent(self, text) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var match = self[/* index */1];
  var paddingSpaces = match !== undefined ? " ".repeat(Rebase.$$String[/* length */1](String(match))) : " ";
  return self[/* textEditor */0].setTextInBufferRange(range, " " + (text + (" " + paddingSpaces)));
}

function selectContent(self) {
  var match = self[/* index */1];
  var indexWidth = match !== undefined ? Rebase.$$String[/* length */1](String(match)) : 1;
  var range = self[/* range */2].translate(new Atom.Point(0, 3), new Atom.Point(0, -(3 + indexWidth | 0) | 0));
  self[/* textEditor */0].setSelectedBufferRange(range, {
        reversed: false,
        preserveFolds: true
      });
  return /* () */0;
}

function isEmpty(self) {
  return Rebase.$$String[/* isEmpty */5](getContent(self).replace((/(\s|\\n)*/), ""));
}

function buildHaskellRange(old, filepath, self) {
  var start = self[/* range */2].start;
  var startIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(start);
  var end_ = self[/* range */2].end;
  var endIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(end_);
  var startIndex$prime = String(startIndex + 3 | 0);
  var startRow = String(start.row + 1 | 0);
  var startColumn = String(start.column + 3 | 0);
  var startPart = "" + (String(startIndex$prime) + (" " + (String(startRow) + (" " + (String(startColumn) + "")))));
  var endIndex$prime = String(endIndex - 3 | 0);
  var endRow = String(end_.row + 1 | 0);
  var endColumn = String(end_.column - 1 | 0);
  var endPart = "" + (String(endIndex$prime) + (" " + (String(endRow) + (" " + (String(endColumn) + "")))));
  if (old) {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(startPart) + (") (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(endPart) + ")])")))))));
  } else {
    return "(intervalsToRange (Just (mkAbsolute \"" + (String(filepath) + ("\")) [Interval (Pn () " + (String(startPart) + (") (Pn () " + (String(endPart) + ")])")))));
  }
}

function make$1(raw) {
  return /* array */[/* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              raw,
              [
                0,
                Rebase.$$String[/* length */1](raw)
              ],
              0
            ])];
}

function lex(regex, source, target, self) {
  var f = function (token) {
    if (token[/* type_ */2] === source) {
      var cursor = /* record */Block.record(["contents"], [token[/* range */1][0]]);
      return Rebase.$$Array[/* map */0]((function (content) {
                    var match = regex.test(content);
                    var type_ = match ? target : source;
                    var cursorOld = cursor[0];
                    cursor[0] = cursor[0] + Rebase.$$String[/* length */1](content) | 0;
                    return /* record */Block.record([
                              "content",
                              "range",
                              "type_"
                            ], [
                              content,
                              [
                                cursorOld,
                                cursor[0]
                              ],
                              type_
                            ]);
                  }), Rebase.$$Array[/* filterMap */23]((function (x) {
                        return x;
                      }), token[/* content */0].split(regex)));
    } else {
      return /* array */[token];
    }
  };
  return Rebase.$$Array[/* flatMap */5](f, self);
}

function map(f, self) {
  var delta = /* record */Block.record(["contents"], [0]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var match = Curry._1(f, token);
                var content = match[/* content */0];
                var match$1 = token[/* range */1];
                var lengthDiff = Rebase.$$String[/* length */1](content) - Rebase.$$String[/* length */1](token[/* content */0]) | 0;
                var result_001 = /* range : tuple */[
                  match$1[0] + delta[0] | 0,
                  (match$1[1] + delta[0] | 0) + lengthDiff | 0
                ];
                var result_002 = /* type_ */match[/* type_ */2];
                var result = /* record */Block.record([
                    "content",
                    "range",
                    "type_"
                  ], [
                    content,
                    result_001,
                    result_002
                  ]);
                delta[0] = delta[0] + lengthDiff | 0;
                return result;
              }), self);
}

function mapOnly(type_, f, self) {
  return map((function (token) {
                var match = token[/* type_ */2] === type_;
                if (match) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = /* module */Block.localModule([
    "make",
    "lex",
    "map",
    "mapOnly"
  ], [
    make$1,
    lex,
    map,
    mapOnly
  ]);

var texBegin = (/\\begin\{code\}.*/);

var texEnd = (/\\end\{code\}.*/);

var markdown = (/\`\`\`(agda)?/);

var comment = (/(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/);

var goalBracket = (/(\{\!(?:(?!\!\})(?:.|\s))*\!\})/);

var goalQuestionMarkRaw = (/([\s\(\{\_\;\.\"@]\?)/);

var goalQuestionMark = (/(\?)/);

var goalBracketContent = (/\{\!((?:(?!\!\})(?:.|\s))*)\!\}/);

var Regex = /* module */Block.localModule([
    "texBegin",
    "texEnd",
    "markdown",
    "comment",
    "goalBracket",
    "goalQuestionMarkRaw",
    "goalQuestionMark",
    "goalBracketContent"
  ], [
    texBegin,
    texEnd,
    markdown,
    comment,
    goalBracket,
    goalQuestionMarkRaw,
    goalQuestionMark,
    goalBracketContent
  ]);

function isHole(token) {
  var match = token[/* type_ */2];
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

function toLines(raw) {
  var cursor = /* record */Block.record(["contents"], [0]);
  return Rebase.Option[/* mapOr */18]((function (lines) {
                return Rebase.$$Array[/* map */0]((function (line) {
                              var cursorOld = cursor[0];
                              cursor[0] = cursor[0] + Rebase.$$String[/* length */1](line) | 0;
                              return /* record */Block.record([
                                        "content",
                                        "range",
                                        "type_"
                                      ], [
                                        raw.substring(cursorOld, cursor[0]),
                                        [
                                          cursorOld,
                                          cursor[0]
                                        ],
                                        1
                                      ]);
                            }), Rebase.$$Array[/* filter */10]((function (x) {
                                  return !Rebase.$$String[/* isEmpty */5](x);
                                }), lines));
              }), /* array */[], Caml_option.null_to_opt(raw.match((/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g))));
}

function filterOutTex(raw) {
  var insideAgda = /* record */Block.record(["contents"], [false]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var content = token[/* content */0];
                if (texEnd.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (texBegin.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Block.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function filterOutMarkdown(raw) {
  var insideAgda = /* record */Block.record(["contents"], [false]);
  return Rebase.$$Array[/* map */0]((function (token) {
                var content = token[/* content */0];
                if (insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = false;
                }
                var match = insideAgda[0];
                var type_ = match ? /* AgdaRaw */0 : /* Literate */1;
                if (!insideAgda[0] && markdown.test(content)) {
                  insideAgda[0] = true;
                }
                return /* record */Block.record([
                          "content",
                          "range",
                          "type_"
                        ], [
                          content,
                          token[/* range */1],
                          type_
                        ]);
              }), toLines(raw));
}

function parse$1(raw, indices, fileType) {
  var i = /* record */Block.record(["contents"], [0]);
  var preprocessed;
  if (fileType !== 0) {
    switch (fileType - 1 | 0) {
      case 0 : 
          preprocessed = filterOutTex(raw);
          break;
      case 1 : 
          preprocessed = make$1(raw);
          break;
      case 2 : 
          preprocessed = filterOutMarkdown(raw);
          break;
      
    }
  } else {
    preprocessed = make$1(raw);
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return /* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              "{!   !}",
              token[/* range */1],
              3
            ]);
  };
  var adjustGoalBracket = function (token) {
    var match = Rebase.$$Array[/* get */17](indices, i[0]);
    var goalIndex = match !== undefined ? String(match) : "*";
    var requiredSpaces = Rebase.$$String[/* length */1](goalIndex);
    var content = Rebase.Option[/* getOr */16]("", Rebase.Option[/* flatMap */5]((function (result) {
                return Rebase.Option[/* flatten */20](Rebase.Option[/* map */0]((function (prim) {
                                  if (prim == null) {
                                    return undefined;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), Rebase.$$Array[/* get */17](result, 1)));
              }), Caml_option.null_to_opt(goalBracketContent.exec(token[/* content */0]))));
    var actualSpaces = Rebase.Option[/* getOr */16](0, Rebase.Option[/* flatMap */5]((function (matches) {
                return Rebase.Option[/* map */0](Rebase.$$String[/* length */1], Rebase.$$Array[/* get */17](matches, 0));
              }), Caml_option.null_to_opt(content.match((/\s*$/)))));
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token[/* content */0].replace((/\{!.*!\}/), "{!" + (content + (padding + "!}")));
    } else {
      newContent = token[/* content */0];
    }
    i[0] = i[0] + 1 | 0;
    return /* record */Block.record([
              "content",
              "range",
              "type_"
            ], [
              newContent,
              [
                1,
                2
              ],
              3
            ]);
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Rebase.$$Array[/* filter */10](isHole, original);
  var modifiedHoles = Rebase.$$Array[/* filter */10](isHole, modified);
  return Rebase.$$Array[/* filterMap */23]((function (x) {
                return x;
              }), Rebase.$$Array[/* mapi */27]((function (token, idx) {
                    var match = Rebase.$$Array[/* get */17](modifiedHoles, idx);
                    var match$1 = Rebase.$$Array[/* get */17](indices, idx);
                    if (match !== undefined && match$1 !== undefined) {
                      var modifiedHole = match;
                      var match$2 = modifiedHole[/* range */1];
                      var start = match$2[0];
                      return /* record */Block.record([
                                "index",
                                "modifiedRange",
                                "originalRange",
                                "content"
                              ], [
                                match$1,
                                modifiedHole[/* range */1],
                                [
                                  start,
                                  start + Rebase.$$String[/* length */1](token[/* content */0]) | 0
                                ],
                                modifiedHole[/* content */0]
                              ]);
                    }
                    
                  }), originalHoles));
}

var Hole = /* module */Block.localModule([
    "Lexer",
    "Regex",
    "isHole",
    "toLines",
    "filterOutTex",
    "filterOutMarkdown",
    "parse"
  ], [
    Lexer,
    Regex,
    isHole,
    toLines,
    filterOutTex,
    filterOutMarkdown,
    parse$1
  ]);

exports.textEditor = textEditor;
exports.index = index;
exports.range = range;
exports.marker = marker;
exports.content = content;
exports.disposables = disposables;
exports.FileType = FileType;
exports.restoreBoundary = restoreBoundary;
exports.string_of_index = string_of_index;
exports.removeBoundary = removeBoundary;
exports.writeLines = writeLines;
exports.writeLambda = writeLambda;
exports.destroy = destroy;
exports.make = make;
exports.getContent = getContent;
exports.setContent = setContent;
exports.selectContent = selectContent;
exports.isEmpty = isEmpty;
exports.buildHaskellRange = buildHaskellRange;
exports.Hole = Hole;
/* texBegin Not a pure module */
