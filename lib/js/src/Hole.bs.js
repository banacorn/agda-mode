// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

function make(raw) {
  return [{
            content: raw,
            range: /* tuple */[
              0,
              Rebase.$$String.length(raw)
            ],
            type_: /* AgdaRaw */0
          }];
}

function lex(regex, source, target, self) {
  var f = function (token) {
    if (token.type_ === source) {
      var cursor = {
        contents: token.range[0]
      };
      return Rebase.$$Array.map((function (content) {
                    var type_ = regex.test(content) ? target : source;
                    var cursorOld = cursor.contents;
                    cursor.contents = cursor.contents + Rebase.$$String.length(content) | 0;
                    return {
                            content: content,
                            range: /* tuple */[
                              cursorOld,
                              cursor.contents
                            ],
                            type_: type_
                          };
                  }), Rebase.$$Array.filterMap((function (x) {
                        return x;
                      }), token.content.split(regex)));
    } else {
      return [token];
    }
  };
  return Rebase.$$Array.flatMap(f, self);
}

function map(f, self) {
  var delta = {
    contents: 0
  };
  return Rebase.$$Array.map((function (token) {
                var match = Curry._1(f, token);
                var content = match.content;
                var match$1 = token.range;
                var lengthDiff = Rebase.$$String.length(content) - Rebase.$$String.length(token.content) | 0;
                var result_range = /* tuple */[
                  match$1[0] + delta.contents | 0,
                  (match$1[1] + delta.contents | 0) + lengthDiff | 0
                ];
                var result_type_ = match.type_;
                var result = {
                  content: content,
                  range: result_range,
                  type_: result_type_
                };
                delta.contents = delta.contents + lengthDiff | 0;
                return result;
              }), self);
}

function mapOnly(type_, f, self) {
  return map((function (token) {
                if (token.type_ === type_) {
                  return Curry._1(f, token);
                } else {
                  return token;
                }
              }), self);
}

var Lexer = {
  make: make,
  lex: lex,
  map: map,
  mapOnly: mapOnly
};

var texBegin = /\\begin\{code\}.*/;

var texEnd = /\\end\{code\}.*/;

var markdown = /\`\`\`(agda)?/;

var comment = /(--[^\r\n]*[\r\n])|(\{-(?:[^-]|[\r\n]|(?:-+(?:[^-\}]|[\r\n])))*-+\})/;

var goalBracket = /(\{\!(?:(?!\!\})(?:.|\s))*\!\})/;

var goalQuestionMarkRaw = /([\s\(\{\_\;\.\"@]\?)/;

var goalQuestionMark = /(\?)/;

var goalBracketContent = /\{\!((?:(?!\!\})(?:.|\s))*)\!\}/;

var Regex = {
  texBegin: texBegin,
  texEnd: texEnd,
  markdown: markdown,
  comment: comment,
  goalBracket: goalBracket,
  goalQuestionMarkRaw: goalQuestionMarkRaw,
  goalQuestionMark: goalQuestionMark,
  goalBracketContent: goalBracketContent
};

function isHole(token) {
  var match = token.type_;
  if (match !== 3) {
    return match >= 5;
  } else {
    return true;
  }
}

function toLines(raw) {
  var cursor = {
    contents: 0
  };
  return Rebase.$$Option.mapOr((function (lines) {
                return Rebase.$$Array.map((function (line) {
                              var cursorOld = cursor.contents;
                              cursor.contents = cursor.contents + Rebase.$$String.length(line) | 0;
                              return {
                                      content: raw.substring(cursorOld, cursor.contents),
                                      range: /* tuple */[
                                        cursorOld,
                                        cursor.contents
                                      ],
                                      type_: /* Literate */1
                                    };
                            }), Rebase.$$Array.filter((function (x) {
                                  return !Rebase.$$String.isEmpty(x);
                                }), lines));
              }), [], Caml_option.null_to_opt(raw.match(/(.*(?:\r\n|[\n\v\f\r\x85\u2028\u2029])?)/g)));
}

function filterOutTex(raw) {
  var insideAgda = {
    contents: false
  };
  return Rebase.$$Array.map((function (token) {
                var content = token.content;
                if (texEnd.test(content)) {
                  insideAgda.contents = false;
                }
                var type_ = insideAgda.contents ? /* AgdaRaw */0 : /* Literate */1;
                if (texBegin.test(content)) {
                  insideAgda.contents = true;
                }
                return {
                        content: content,
                        range: token.range,
                        type_: type_
                      };
              }), toLines(raw));
}

function filterOutMarkdown(raw) {
  var insideAgda = {
    contents: false
  };
  return Rebase.$$Array.map((function (token) {
                var content = token.content;
                if (insideAgda.contents && markdown.test(content)) {
                  insideAgda.contents = false;
                }
                var type_ = insideAgda.contents ? /* AgdaRaw */0 : /* Literate */1;
                if (!insideAgda.contents && markdown.test(content)) {
                  insideAgda.contents = true;
                }
                return {
                        content: content,
                        range: token.range,
                        type_: type_
                      };
              }), toLines(raw));
}

function parse(raw, indices, fileType) {
  var i = {
    contents: 0
  };
  var preprocessed;
  if (fileType !== 0) {
    switch (fileType - 1 | 0) {
      case /* Agda */0 :
          preprocessed = filterOutTex(raw);
          break;
      case /* LiterateTeX */1 :
          preprocessed = make(raw);
          break;
      case /* LiterateReStructuredText */2 :
          preprocessed = filterOutMarkdown(raw);
          break;
      
    }
  } else {
    preprocessed = make(raw);
  }
  var original = lex(goalQuestionMark, /* GoalQMRaw */4, /* GoalQM */5, lex(goalQuestionMarkRaw, /* AgdaRaw */0, /* GoalQMRaw */4, lex(goalBracket, /* AgdaRaw */0, /* GoalBracket */3, lex(comment, /* AgdaRaw */0, /* Comment */2, preprocessed))));
  var questionMark2GoalBracket = function (token) {
    return {
            content: "{!   !}",
            range: token.range,
            type_: /* GoalBracket */3
          };
  };
  var adjustGoalBracket = function (token) {
    var match = Rebase.$$Array.get(indices, i.contents);
    var goalIndex = match !== undefined ? String(match) : "*";
    var requiredSpaces = Rebase.$$String.length(goalIndex);
    var content = Rebase.$$Option.getOr("", Rebase.$$Option.flatMap((function (result) {
                return Rebase.$$Option.flatten(Rebase.$$Option.map((function (prim) {
                                  if (prim == null) {
                                    return ;
                                  } else {
                                    return Caml_option.some(prim);
                                  }
                                }), Rebase.$$Array.get(result, 1)));
              }), Caml_option.null_to_opt(goalBracketContent.exec(token.content))));
    var actualSpaces = Rebase.$$Option.getOr(0, Rebase.$$Option.flatMap((function (matches) {
                return Rebase.$$Option.map(Rebase.$$String.length, Rebase.$$Array.get(matches, 0));
              }), Caml_option.null_to_opt(content.match(/\s*$/))));
    var newContent;
    if (actualSpaces < requiredSpaces) {
      var padding = "".repeat(requiredSpaces - actualSpaces | 0);
      newContent = token.content.replace(/\{!.*!\}/, "{!" + (content + (padding + "!}")));
    } else {
      newContent = token.content;
    }
    i.contents = i.contents + 1 | 0;
    return {
            content: newContent,
            range: /* tuple */[
              1,
              2
            ],
            type_: /* GoalBracket */3
          };
  };
  var modified = mapOnly(/* GoalBracket */3, adjustGoalBracket, mapOnly(/* GoalQM */5, questionMark2GoalBracket, original));
  var originalHoles = Rebase.$$Array.filter(isHole, original);
  var modifiedHoles = Rebase.$$Array.filter(isHole, modified);
  return Rebase.$$Array.filterMap((function (x) {
                return x;
              }), Rebase.$$Array.mapi((function (token, idx) {
                    var match = Rebase.$$Array.get(modifiedHoles, idx);
                    var match$1 = Rebase.$$Array.get(indices, idx);
                    if (match !== undefined && match$1 !== undefined) {
                      var modifiedHole = match;
                      var match$2 = modifiedHole.range;
                      var start = match$2[0];
                      return {
                              index: match$1,
                              modifiedRange: modifiedHole.range,
                              originalRange: /* tuple */[
                                start,
                                start + Rebase.$$String.length(token.content) | 0
                              ],
                              content: modifiedHole.content
                            };
                    }
                    
                  }), originalHoles));
}

exports.Lexer = Lexer;
exports.Regex = Regex;
exports.isHole = isHole;
exports.toLines = toLines;
exports.filterOutTex = filterOutTex;
exports.filterOutMarkdown = filterOutMarkdown;
exports.parse = parse;
/* No side effect */
