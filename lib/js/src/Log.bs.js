// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Command$AgdaMode = require("./Command.bs.js");
var Response$AgdaMode = require("./Response.bs.js");

function serialize(self, i) {
  var fold = function (title, text) {
    return "<details><summary> " + (String(title) + (" </summary>\n<p>\n\n" + (String(text) + "\n\n</p>\n</details>\n")));
  };
  var quote = function (title, xs) {
    var xs$1 = fold(title, Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* map */0]((function (x) {
                        return "```\n" + (String(x) + "\n```\n");
                      }), xs))));
    var partial_arg = Rebase.$$Option[/* mapOr */18];
    return Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* map */0]((function (param) {
                          return partial_arg((function (x) {
                                        return "    " + x;
                                      }), "", param);
                        }), xs$1.split((/\n/)))));
  };
  var request = Command$AgdaMode.Remote[/* toString */2](self[/* request */0]);
  var rawText = quote("raw text", self[/* response */1][/* rawText */0]);
  var sexpression = quote("s-expression", Rebase.$$Array[/* map */0](Parser$AgdaMode.SExpression[/* toString */0], self[/* response */1][/* sexpression */1]));
  var response = quote("response", Rebase.$$Array[/* map */0](Response$AgdaMode.toString, self[/* response */1][/* response */2]));
  return "" + (String(i) + (". **" + (String(request) + ("**\n" + (String(rawText) + ("\n" + (String(sexpression) + ("\n" + (String(response) + "\n")))))))));
}

var Entry = /* module */Block.localModule(["serialize"], [serialize]);

var empty = /* array */[];

function createEntry(cmd, log) {
  var entry_001 = /* response : record */Block.record([
      "rawText",
      "sexpression",
      "response"
    ], [
      [],
      [],
      []
    ]);
  var entry = /* record */Block.record([
      "request",
      "response"
    ], [
      cmd,
      entry_001
    ]);
  log.push(entry);
  return /* () */0;
}

function updateLatestEntry(f, log) {
  var n = Rebase.$$Array[/* length */16](log);
  return Rebase.$$Option[/* forEach */8](f, Rebase.$$Array[/* get */17](log, n - 1 | 0));
}

function logRawText(text) {
  return (function (param) {
      return updateLatestEntry((function (log) {
                    log[/* response */1][/* rawText */0].push(text);
                    return /* () */0;
                  }), param);
    });
}

function logSExpression(text) {
  return (function (param) {
      return updateLatestEntry((function (log) {
                    log[/* response */1][/* sexpression */1].push(text);
                    return /* () */0;
                  }), param);
    });
}

function logResponse(text) {
  return (function (param) {
      return updateLatestEntry((function (log) {
                    log[/* response */1][/* response */2].push(text);
                    return /* () */0;
                  }), param);
    });
}

function serialize$1(log) {
  var entries = Rebase.$$String[/* joinWith */11]("\n", Rebase.List[/* fromArray */12](Rebase.$$Array[/* mapi */27](serialize, log)));
  return "## Parse Log\n" + (String(entries) + "\n");
}

exports.Entry = Entry;
exports.empty = empty;
exports.createEntry = createEntry;
exports.updateLatestEntry = updateLatestEntry;
exports.logRawText = logRawText;
exports.logSExpression = logSExpression;
exports.logResponse = logResponse;
exports.serialize = serialize$1;
/* Parser-AgdaMode Not a pure module */
