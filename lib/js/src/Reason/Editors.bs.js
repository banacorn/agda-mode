// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Hole$AgdaMode = require("./Hole.bs.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var MiniEditor$AgdaMode = require("./View/MiniEditor.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var QueryCancelled = Caml_exceptions.create("Editors-AgdaMode.QueryCancelled");

function make(editor) {
  return /* record */Block.record([
            "focused",
            "source",
            "query"
          ], [
            0,
            editor,
            MiniEditor$AgdaMode.Model[/* make */0](/* () */0)
          ]);
}

function get(editors) {
  var match = editors[/* focused */0];
  switch (match) {
    case 0 : 
        return editors[/* source */1];
    case 1 : 
        var match$1 = editors[/* query */2][/* ref */2];
        if (match$1 !== undefined) {
          return Caml_option.valFromOption(match$1);
        } else {
          return editors[/* source */1];
        }
    case 2 : 
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "Editors.re",
                37,
                4
              ]
            ];
    
  }
}

function on(sort, editors) {
  switch (sort) {
    case 0 : 
        if (editors[/* focused */0] !== /* Source */0) {
          atom.views.getView(editors[/* source */1]).focus();
          return /* () */0;
        } else {
          return 0;
        }
    case 1 : 
        if (editors[/* focused */0] !== /* Query */1) {
          return MiniEditor$AgdaMode.Model[/* focus */4](editors[/* query */2]);
        } else {
          return 0;
        }
    case 2 : 
        throw [
              Caml_builtin_exceptions.match_failure,
              /* tuple */[
                "Editors.re",
                52,
                4
              ]
            ];
    
  }
}

var Focus = /* module */Block.localModule([
    "get",
    "on"
  ], [
    get,
    on
  ]);

function destroy(index, self) {
  Rebase.$$Array[/* forEach */8](Hole$AgdaMode.destroy, Rebase.$$Array[/* filter */10]((function (x) {
              return Caml_obj.caml_equal(x[/* index */1], index);
            }), self));
  return Rebase.$$Array[/* filter */10]((function (x) {
                return Caml_obj.caml_notequal(x[/* index */1], index);
              }), self);
}

function destroyAll(self) {
  Rebase.$$Array[/* forEach */8](Hole$AgdaMode.destroy, self);
  return /* [] */0;
}

function find(index, self) {
  var result = Rebase.$$Array[/* filter */10]((function (x) {
          return Caml_obj.caml_equal(x[/* index */1], index);
        }), self);
  return Rebase.$$Array[/* get */17](result, 0);
}

function pointingAt(cursor, self) {
  var result = Rebase.$$Array[/* filter */10]((function (x) {
          return x[/* range */2].containsPoint(cursor, false);
        }), self);
  return Rebase.$$Array[/* get */17](result, 0);
}

var Goals = /* module */Block.localModule([
    "destroy",
    "destroyAll",
    "find",
    "pointingAt"
  ], [
    destroy,
    destroyAll,
    find,
    pointingAt
  ]);

var jsGoalsDestroy = destroy;

var jsGoalsDestroyAll = destroyAll;

var jsGoalsFind = find;

var jsGoalsPointingAt = pointingAt;

exports.QueryCancelled = QueryCancelled;
exports.make = make;
exports.Focus = Focus;
exports.Goals = Goals;
exports.jsGoalsDestroy = jsGoalsDestroy;
exports.jsGoalsDestroyAll = jsGoalsDestroyAll;
exports.jsGoalsFind = jsGoalsFind;
exports.jsGoalsPointingAt = jsGoalsPointingAt;
/* Hole-AgdaMode Not a pure module */
