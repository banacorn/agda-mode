// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Translator$AgdaMode = require("./Translator.bs.js");

function init(string) {
  return string.substring(0, Rebase.$$String.length(string) - 1 | 0);
}

function isEmpty(self) {
  if (self.symbol === undefined) {
    return Rebase.$$String.isEmpty(self.tail);
  } else {
    return false;
  }
}

function toSequence(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[1] + self.tail;
  } else {
    return self.tail;
  }
}

function toSurface(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[0] + self.tail;
  } else {
    return self.tail;
  }
}

function toString(self) {
  return "\"" + (toSurface(self) + ("\"[" + (toSequence(self) + "]")));
}

function next(self, reality) {
  var surface = toSurface(self);
  var sequence = toSequence(self);
  if (reality === surface) {
    if (Translator$AgdaMode.translate(sequence).further && reality !== "\\") {
      return /* Noop */0;
    } else {
      return /* Complete */1;
    }
  }
  if (init(reality) !== surface) {
    if (reality === init(surface) || reality === init(sequence)) {
      if (Rebase.$$String.isEmpty(reality)) {
        if (Rebase.$$Option.isSome(self.symbol)) {
          return {
                  TAG: 2,
                  _0: {
                    symbol: undefined,
                    tail: init(sequence)
                  },
                  [Symbol.for("name")]: "Rewrite"
                };
        } else {
          return {
                  TAG: 3,
                  _0: 2,
                  [Symbol.for("name")]: "Stuck"
                };
        }
      } else {
        return {
                TAG: 1,
                _0: {
                  symbol: self.symbol,
                  tail: init(self.tail)
                },
                [Symbol.for("name")]: "Backspace"
              };
      }
    } else {
      return {
              TAG: 3,
              _0: 3,
              [Symbol.for("name")]: "Stuck"
            };
    }
  }
  var insertedChar = reality.substr(-1);
  var sequence$prime = sequence + insertedChar;
  var translation = Translator$AgdaMode.translate(sequence$prime);
  var symbol = translation.symbol;
  if (symbol !== undefined) {
    if (insertedChar === symbol && insertedChar === "\\") {
      return {
              TAG: 3,
              _0: 0,
              [Symbol.for("name")]: "Stuck"
            };
    } else {
      return {
              TAG: 2,
              _0: {
                symbol: [
                  symbol,
                  sequence$prime
                ],
                tail: ""
              },
              [Symbol.for("name")]: "Rewrite"
            };
    }
  } else if (translation.further) {
    return {
            TAG: 0,
            _0: {
              symbol: self.symbol,
              tail: self.tail + insertedChar
            },
            [Symbol.for("name")]: "Insert"
          };
  } else {
    return {
            TAG: 3,
            _0: 1,
            [Symbol.for("name")]: "Stuck"
          };
  }
}

var initial = {
  symbol: undefined,
  tail: ""
};

exports.init = init;
exports.initial = initial;
exports.isEmpty = isEmpty;
exports.toSequence = toSequence;
exports.toSurface = toSurface;
exports.toString = toString;
exports.next = next;
/* Translator-AgdaMode Not a pure module */
