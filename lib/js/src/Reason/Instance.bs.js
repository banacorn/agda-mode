// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Atom = require("atom");
var Util = require("util");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Goal$AgdaMode = require("./Goal.bs.js");
var Hole$AgdaMode = require("./Hole.bs.js");
var View$AgdaMode = require("./View.bs.js");
var Async$AgdaMode = require("./Util/Async.bs.js");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Command$AgdaMode = require("./Command.bs.js");
var Editors$AgdaMode = require("./Editors.bs.js");
var Response$AgdaMode = require("./Response.bs.js");
var Connection$AgdaMode = require("./Connection.bs.js");
var Highlighting$AgdaMode = require("./Highlighting.bs.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function make(textEditor) {
  atom.views.getView(textEditor).classList.add("agda");
  var editors = Editors$AgdaMode.make(textEditor);
  return /* record */Block.record([
            "editors",
            "view",
            "highlightings",
            "goals",
            "connection"
          ], [
            editors,
            View$AgdaMode.initialize(editors),
            [],
            [],
            undefined
          ]);
}

function activate(instance) {
  return Event$AgdaMode.resolve(true, instance[/* view */1][/* activatePanel */4]);
}

function deactivate(instance) {
  return Event$AgdaMode.resolve(false, instance[/* view */1][/* activatePanel */4]);
}

function destroy(instance) {
  deactivate(instance);
  return Event$AgdaMode.resolve(/* () */0, instance[/* view */1][/* destroy */13]);
}

function destroyAll(instance) {
  Rebase.$$Array[/* forEach */8](Goal$AgdaMode.destroy, instance[/* goals */3]);
  instance[/* goals */3] = /* array */[];
  return /* () */0;
}

function find(index, instance) {
  return Rebase.$$Array[/* get */17](instance[/* goals */3], index);
}

function instantiateAll(indices, instance) {
  destroyAll(instance);
  var textEditor = instance[/* editors */0][/* source */1];
  var filePath = textEditor.getPath();
  var textBuffer = textEditor.getBuffer();
  var source = textEditor.getText();
  var fileType = Goal$AgdaMode.FileType[/* parse */0](filePath);
  var result = Hole$AgdaMode.parse(source, indices, fileType);
  instance[/* goals */3] = Rebase.$$Array[/* map */0]((function (result) {
          var start = textBuffer.positionForCharacterIndex(result[/* originalRange */2][0]);
          var end_ = textBuffer.positionForCharacterIndex(result[/* originalRange */2][1]);
          var range = new Atom.Range(start, end_);
          textEditor.setTextInBufferRange(range, result[/* content */3]);
          return Goal$AgdaMode.make(instance[/* editors */0][/* source */1], result[/* index */0], result[/* modifiedRange */1]);
        }), result);
  return /* () */0;
}

var Goals = /* module */Block.localModule([
    "destroyAll",
    "find",
    "instantiateAll"
  ], [
    destroyAll,
    find,
    instantiateAll
  ]);

function add(annotation, instance) {
  var textEditor = instance[/* editors */0][/* source */1];
  var textBuffer = textEditor.getBuffer();
  var startPoint = textBuffer.positionForCharacterIndex(annotation[/* start */0] - 1 | 0);
  var endPoint = textBuffer.positionForCharacterIndex(annotation[/* end_ */1] - 1 | 0);
  var range = new Atom.Range(startPoint, endPoint);
  var marker = textEditor.markBufferRange(range);
  instance[/* highlightings */2].push(marker);
  var types = annotation[/* types */2].join(" ");
  textEditor.decorateMarker(marker, {
        type: "highlight",
        class: "highlight-decoration " + types
      });
  return /* () */0;
}

function addFromFile(filepath, instance) {
  var readFile = Util.promisify((function (prim, prim$1) {
          Fs.readFile(prim, prim$1);
          return /* () */0;
        }));
  return Async$AgdaMode.mapError((function (err) {
                  console.log(err);
                  console.log("cannot read the indirect highlighting file: " + filepath);
                  return /* () */0;
                }))(Async$AgdaMode.thenOk((function (content) {
                      Rebase.Result[/* forEach */9]((function (annotations) {
                              return Rebase.$$Array[/* forEach */8]((function (annotation) {
                                            return add(annotation, instance);
                                          }), Rebase.$$Array[/* filter */10](Highlighting$AgdaMode.Annotation[/* shouldHighlight */3], annotations));
                            }), Rebase.Result[/* map */0]((function (tokens) {
                                  if (tokens.tag) {
                                    return Highlighting$AgdaMode.Annotation[/* parseIndirectHighlighting */2](tokens[0]);
                                  } else {
                                    return /* array */[];
                                  }
                                }), Emacs__Parser$AgdaMode.SExpression[/* parse */4](content.toString())));
                      return Async$AgdaMode.resolve(/* () */0);
                    }))(Async$AgdaMode.fromPromise(readFile(filepath))));
}

function destroyAll$1(instance) {
  Rebase.$$Array[/* forEach */8]((function (prim) {
          prim.destroy();
          return /* () */0;
        }), instance[/* highlightings */2]);
  instance[/* highlightings */2] = /* array */[];
  return /* () */0;
}

var Highlightings = /* module */Block.localModule([
    "add",
    "addFromFile",
    "destroyAll"
  ], [
    add,
    addFromFile,
    destroyAll$1
  ]);

function connect(instance) {
  var inquireConnection = function (error, instance) {
    activate(instance);
    var promise = Async$AgdaMode.thenOk((function (param) {
              Event$AgdaMode.resolve(/* Connection */1, instance[/* view */1][/* navigateSettingsView */12]);
              var promise = Event$AgdaMode.once(instance[/* view */1][/* onInquireConnection */7]);
              Event$AgdaMode.resolve(/* tuple */[
                    error,
                    ""
                  ], instance[/* view */1][/* inquireConnection */6]);
              return promise;
            }))(Async$AgdaMode.mapError((function (param) {
                  return /* Cancelled */0;
                }))(Event$AgdaMode.once(instance[/* view */1][/* onSettingsView */11])));
    Event$AgdaMode.resolve(true, instance[/* view */1][/* activateSettingsView */10]);
    return promise;
  };
  var getAgdaPath = function (param) {
    var storedPath = Parser$AgdaMode.filepath(atom.config.get("agda-mode.agdaPath"));
    if (Rebase.$$String[/* isEmpty */5](storedPath)) {
      return Connection$AgdaMode.autoSearch("agda");
    } else {
      return Async$AgdaMode.resolve(storedPath);
    }
  };
  var getMetadata = function (instance, path) {
    return Async$AgdaMode.thenError((function (err) {
                    return Async$AgdaMode.thenOk((function (param) {
                                    return getMetadata(instance, param);
                                  }))(inquireConnection(/* Validation */Block.variant("Validation", 1, [
                                      path,
                                      err
                                    ]), instance));
                  }))(Connection$AgdaMode.validateAndMake(path));
  };
  var getConnection = function (instance, metadata) {
    return Async$AgdaMode.thenError((function (err) {
                    return Async$AgdaMode.thenOk((function (param) {
                                    return getConnection(instance, param);
                                  }))(Async$AgdaMode.thenOk((function (param) {
                                        return getMetadata(instance, param);
                                      }))(inquireConnection(/* Connection */Block.variant("Connection", 2, [err]), instance)));
                  }))(Connection$AgdaMode.connect(metadata));
  };
  var match = instance[/* connection */4];
  if (match !== undefined) {
    return Async$AgdaMode.resolve(match);
  } else {
    return Async$AgdaMode.mapOk(Connection$AgdaMode.wire)(Async$AgdaMode.mapOk((function (param) {
                        var instance$1 = instance;
                        var connection = param;
                        instance$1[/* connection */4] = connection;
                        atom.config.set("agda-mode.agdaPath", connection[/* metadata */0][/* path */0]);
                        Event$AgdaMode.resolve(connection, instance$1[/* view */1][/* updateConnection */5]);
                        return connection;
                      }))(Async$AgdaMode.thenOk((function (param) {
                            return getConnection(instance, param);
                          }))(Async$AgdaMode.thenOk((function (param) {
                                return getMetadata(instance, param);
                              }))(Async$AgdaMode.thenError((function (err) {
                                    return inquireConnection(/* AutoSearch */Block.variant("AutoSearch", 0, [err]), instance);
                                  }))(getAgdaPath(/* () */0))))));
  }
}

function disconnect(instance) {
  var match = instance[/* connection */4];
  if (match !== undefined) {
    Connection$AgdaMode.disconnect(match);
    instance[/* connection */4] = undefined;
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function get(instance) {
  var match = instance[/* connection */4];
  if (match !== undefined) {
    return Async$AgdaMode.resolve(match);
  } else {
    return connect(instance);
  }
}

var Connections = /* module */Block.localModule([
    "connect",
    "disconnect",
    "get"
  ], [
    connect,
    disconnect,
    get
  ]);

function handleLocalCommand(command, instance) {
  var buff = function (command, instance) {
    return Async$AgdaMode.mapError((function (param) {
                    return /* Cancelled */0;
                  }))(Async$AgdaMode.mapOk((function (connection) {
                        return /* record */Block.record([
                                  "connection",
                                  "filepath",
                                  "command"
                                ], [
                                  connection,
                                  instance[/* editors */0][/* source */1].getPath(),
                                  command
                                ]);
                      }))(get(instance)));
  };
  if (typeof command === "number") {
    switch (command) {
      case 0 : 
          return Async$AgdaMode.thenOk((function (param) {
                          return buff(/* Load */0, instance);
                        }))(Async$AgdaMode.mapError((function (param) {
                              return /* Cancelled */0;
                            }))(Async$AgdaMode.fromPromise(instance[/* editors */0][/* source */1].save())));
      case 1 : 
          disconnect(instance);
          destroyAll(instance);
          destroyAll$1(instance);
          return Async$AgdaMode.resolve(undefined);
      case 2 : 
          disconnect(instance);
          return buff(/* Load */0, instance);
      case 4 : 
          return buff(/* Compile */1, instance);
      case 5 : 
          return buff(/* ToggleDisplayOfImplicitArguments */2, instance);
      case 6 : 
          return buff(/* SolveConstraints */3, instance);
      case 13 : 
          var pointed = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */3], instance[/* editors */0]);
          if (pointed !== undefined) {
            var goal = pointed;
            var match = goal[/* index */1];
            if (match !== undefined) {
              var index = match;
              if (Goal$AgdaMode.isEmpty(goal)) {
                return Async$AgdaMode.thenOk((function (result) {
                                Goal$AgdaMode.setContent(result, goal);
                                return buff(/* Give */Block.variant("Give", 0, [
                                              goal,
                                              index
                                            ]), instance);
                              }))(Async$AgdaMode.mapError((function (param) {
                                    return /* Cancelled */0;
                                  }))(View$AgdaMode.inquire("expression to give:", "", instance[/* view */1])));
              } else {
                return buff(/* Give */Block.variant("Give", 0, [
                              goal,
                              index
                            ]), instance);
              }
            } else {
              return Async$AgdaMode.reject(/* GoalNotIndexed */1);
            }
          } else {
            return Async$AgdaMode.reject(/* OutOfGoal */2);
          }
      case 14 : 
          var pointed$1 = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */3], instance[/* editors */0]);
          if (pointed$1 !== undefined) {
            var goal$1 = pointed$1;
            var match$1 = goal$1[/* index */1];
            if (match$1 !== undefined) {
              return buff(/* Refine */Block.variant("Refine", 1, [
                            goal$1,
                            match$1
                          ]), instance);
            } else {
              return Async$AgdaMode.reject(/* GoalNotIndexed */1);
            }
          } else {
            return Async$AgdaMode.reject(/* OutOfGoal */2);
          }
      case 15 : 
          var pointed$2 = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */3], instance[/* editors */0]);
          if (pointed$2 !== undefined) {
            var goal$2 = pointed$2;
            var match$2 = goal$2[/* index */1];
            if (match$2 !== undefined) {
              return buff(/* Auto */Block.variant("Auto", 2, [
                            goal$2,
                            match$2
                          ]), instance);
            } else {
              return Async$AgdaMode.reject(/* GoalNotIndexed */1);
            }
          } else {
            return Async$AgdaMode.reject(/* OutOfGoal */2);
          }
      case 16 : 
          var pointed$3 = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */3], instance[/* editors */0]);
          if (pointed$3 !== undefined) {
            var goal$3 = pointed$3;
            var match$3 = goal$3[/* index */1];
            if (match$3 !== undefined) {
              var index$1 = match$3;
              if (Goal$AgdaMode.isEmpty(goal$3)) {
                return Async$AgdaMode.thenOk((function (result) {
                                Goal$AgdaMode.setContent(result, goal$3);
                                return buff(/* Case */Block.variant("Case", 3, [
                                              goal$3,
                                              index$1
                                            ]), instance);
                              }))(Async$AgdaMode.mapError((function (param) {
                                    return /* Cancelled */0;
                                  }))(View$AgdaMode.inquire("expression to case:", "", instance[/* view */1])));
              } else {
                return buff(/* Case */Block.variant("Case", 3, [
                              goal$3,
                              index$1
                            ]), instance);
              }
            } else {
              return Async$AgdaMode.reject(/* GoalNotIndexed */1);
            }
          } else {
            return Async$AgdaMode.reject(/* OutOfGoal */2);
          }
      default:
        return buff(/* Load */0, instance);
    }
  } else if (command.tag === 8) {
    var enabled = atom.config.get("agda-mode.inputMethod");
    if (enabled) {
      switch (command[0]) {
        case 0 : 
            Event$AgdaMode.resolve(true, instance[/* view */1][/* activatePanel */4]);
            Event$AgdaMode.resolve(true, instance[/* view */1][/* activateInputMethod */14]);
            break;
        case 1 : 
            Event$AgdaMode.resolve("{", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        case 2 : 
            Event$AgdaMode.resolve("[", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        case 3 : 
            Event$AgdaMode.resolve("(", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        case 4 : 
            Event$AgdaMode.resolve("\"", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        case 5 : 
            Event$AgdaMode.resolve("'", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        case 6 : 
            Event$AgdaMode.resolve("`", instance[/* view */1][/* interceptAndInsertKey */15]);
            break;
        
      }
    } else {
      Editors$AgdaMode.Focus[/* get */0](instance[/* editors */0]).insertText("\\");
    }
    return Async$AgdaMode.resolve(undefined);
  } else {
    return buff(/* Load */0, instance);
  }
}

function recoverCursor(callback, instance) {
  var cursor = instance[/* editors */0][/* source */1].getCursorBufferPosition();
  var result = Curry._1(callback, /* () */0);
  var pointed = Editors$AgdaMode.pointingAt(Caml_option.some(cursor), instance[/* goals */3], instance[/* editors */0]);
  if (pointed !== undefined) {
    var goal = pointed;
    var fresh = Goal$AgdaMode.isEmpty(goal);
    if (fresh) {
      var delta = new Atom.Point(0, 3);
      var newPosition = goal[/* range */2].start.translate(delta);
      setTimeout((function (param) {
              instance[/* editors */0][/* source */1].setCursorBufferPosition(newPosition);
              return /* () */0;
            }), 0);
    } else {
      instance[/* editors */0][/* source */1].setCursorBufferPosition(cursor);
    }
  } else {
    instance[/* editors */0][/* source */1].setCursorBufferPosition(cursor);
  }
  return result;
}

function handleResponse(instance, response) {
  var textEditor = instance[/* editors */0][/* source */1];
  var filePath = textEditor.getPath();
  var textBuffer = textEditor.getBuffer();
  if (typeof response === "number") {
    if (response === 1) {
      destroyAll$1(instance);
      return Async$AgdaMode.resolve(/* () */0);
    } else {
      console.log(response);
      return Async$AgdaMode.resolve(/* () */0);
    }
  } else {
    switch (response.tag | 0) {
      case 0 : 
          Rebase.$$Array[/* forEach */8]((function (annotation) {
                  return add(annotation, instance);
                }), Rebase.$$Array[/* filter */10](Highlighting$AgdaMode.Annotation[/* shouldHighlight */3], response[1]));
          return Async$AgdaMode.resolve(/* () */0);
      case 1 : 
          var filepath = response[0];
          return Async$AgdaMode.mapError((function (param) {
                          return /* Cancelled */0;
                        }))(Async$AgdaMode.mapOk((function (param) {
                              Fs.unlink(filepath, (function (param) {
                                      return /* () */0;
                                    }));
                              return /* () */0;
                            }))(addFromFile(filepath, instance)));
      case 2 : 
          var checked = response[1];
          var displayImplicit = response[0];
          if (displayImplicit || checked) {
            View$AgdaMode.update("Status", /* PlainText */0, /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, ["Typechecked: " + (Pervasives.string_of_bool(checked) + ("\nDisplay implicit arguments: " + Pervasives.string_of_bool(displayImplicit)))])]), instance[/* view */1]);
          }
          return Async$AgdaMode.resolve(/* () */0);
      case 3 : 
          if (response[0] === filePath) {
            var point = textBuffer.positionForCharacterIndex(response[1] - 1 | 0);
            textEditor.setCursorBufferPosition(point);
          }
          return Async$AgdaMode.resolve(/* () */0);
      case 4 : 
          instantiateAll(response[0], instance);
          return Async$AgdaMode.resolve(/* () */0);
      case 5 : 
          var give = response[1];
          var match = find(response[0], instance);
          if (match !== undefined) {
            var goal = match;
            if (typeof give === "number") {
              if (give === 0) {
                var content = Goal$AgdaMode.getContent(goal);
                Goal$AgdaMode.setContent("(" + (content + ")"), goal);
              }
              
            } else {
              Goal$AgdaMode.setContent(give[0].replace((/\\n/g), "\n"), goal);
            }
            Goal$AgdaMode.removeBoundary(goal);
            Goal$AgdaMode.destroy(goal);
            return Async$AgdaMode.resolve(/* () */0);
          } else {
            return Async$AgdaMode.resolve(/* () */0);
          }
      case 6 : 
          var lines = response[1];
          var pointed = Editors$AgdaMode.pointingAt(undefined, instance[/* goals */3], instance[/* editors */0]);
          if (pointed !== undefined) {
            var goal$1 = pointed;
            if (response[0]) {
              Goal$AgdaMode.writeLambda(lines, goal$1);
            } else {
              Goal$AgdaMode.writeLines(lines, goal$1);
            }
            return dispatch(/* Load */0, instance);
          } else {
            return Async$AgdaMode.reject(/* OutOfGoal */2);
          }
      case 8 : 
          Event$AgdaMode.resolve(true, instance[/* view */1][/* activatePanel */4]);
          return Response$AgdaMode.Info[/* handle */1](response[0], (function (x, y, z) {
                        return View$AgdaMode.update(x, y, z, instance[/* view */1]);
                      }));
      default:
        console.log(response);
        return Async$AgdaMode.resolve(/* () */0);
    }
  }
}

function dispatch(command, instance) {
  return Async$AgdaMode.thenOk((function (result) {
                  var responses = Rebase.$$Array[/* filterMap */23](Rebase.Option[/* fromResult */12], result);
                  return Async$AgdaMode.mapOk((function (param) {
                                  return /* () */0;
                                }))(Async$AgdaMode.all(recoverCursor((function (param) {
                                        return Rebase.$$Array[/* map */0]((function (param) {
                                                      return handleResponse(instance, param);
                                                    }), responses);
                                      }), instance)));
                }))(Async$AgdaMode.thenOk((function (remote) {
                      if (remote !== undefined) {
                        var cmd = remote;
                        var serialized = Command$AgdaMode.Remote[/* serialize */0](cmd);
                        var partial_arg = Rebase.Result[/* flatMap */6];
                        var partial_arg$1 = function (param) {
                          return partial_arg(Response$AgdaMode.parse, param);
                        };
                        var partial_arg$2 = Rebase.$$Array[/* map */0];
                        return Async$AgdaMode.mapError((function (param) {
                                        return /* Cancelled */0;
                                      }))(Async$AgdaMode.mapOk((function (param) {
                                            return partial_arg$2(partial_arg$1, param);
                                          }))(Async$AgdaMode.mapOk(Emacs__Parser$AgdaMode.SExpression[/* parseFile */5])(Connection$AgdaMode.send(serialized, cmd[/* connection */0]))));
                      } else {
                        return Async$AgdaMode.resolve(/* array */[]);
                      }
                    }))(handleLocalCommand(command, instance)));
}

function dispatchUndo(_instance) {
  console.log("Undo");
  return /* () */0;
}

var Event = 0;

exports.Event = Event;
exports.make = make;
exports.activate = activate;
exports.deactivate = deactivate;
exports.destroy = destroy;
exports.Goals = Goals;
exports.Highlightings = Highlightings;
exports.Connections = Connections;
exports.handleLocalCommand = handleLocalCommand;
exports.recoverCursor = recoverCursor;
exports.handleResponse = handleResponse;
exports.dispatch = dispatch;
exports.dispatchUndo = dispatchUndo;
/* fs Not a pure module */
