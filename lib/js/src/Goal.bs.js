// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Util$AgdaMode = require("./Util/Util.bs.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function parse(filepath) {
  if ((/\.lagda.rst$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateReStructuredText */2;
  } else if ((/\.lagda.md$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateMarkdown */3;
  } else if ((/\.lagda.tex$|\.lagda$/i).test(Parser$AgdaMode.filepath(filepath))) {
    return /* LiterateTeX */1;
  } else {
    return /* Agda */0;
  }
}

var FileType = {
  parse: parse
};

function restoreBoundary(self, range) {
  self[/* textEditor */0].setTextInBufferRange(range, self[/* content */4]);
  return /* () */0;
}

function removeBoundary(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var content = Rebase.$$String.trim(self[/* textEditor */0].getTextInBufferRange(range));
  self[/* textEditor */0].setTextInBufferRange(self[/* range */2], content);
  return /* () */0;
}

function writeLines(contents, self) {
  var textBuffer = self[/* textEditor */0].getBuffer();
  var rowNumbers = self[/* range */2].getRows();
  var match = Rebase.$$Array.get(rowNumbers, 0);
  if (match !== undefined) {
    var firstRowNumber = match;
    var firstRowRange = textBuffer.rangeForRow(firstRowNumber, false);
    var firstRow = self[/* textEditor */0].getTextInBufferRange(firstRowRange);
    var indentSpaces = " ".repeat(Util$AgdaMode.$$String.indentedBy(firstRow));
    var indentedContents = Rebase.$$String.concat("\n", Rebase.$$String.joinWith("\n", Rebase.List.fromArray(Rebase.$$Array.map((function (line) {
                        return indentSpaces + line;
                      }), contents))));
    var match$1 = Rebase.$$Array.get(rowNumbers, Rebase.$$Array.length(rowNumbers) - 1 | 0);
    if (match$1 !== undefined) {
      textBuffer.deleteRows(firstRowNumber, match$1);
    }
    var position = firstRowRange.start;
    textBuffer.insert(position, indentedContents);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function writeLambda(contents, self) {
  var scanRow = self[/* range */2].start.row;
  var scanRowText = self[/* textEditor */0].getTextInBufferRange(new Atom.Range(new Atom.Point(scanRow, 0), self[/* range */2].start));
  var indent = Util$AgdaMode.$$String.indentedBy(scanRowText);
  var match = Util$AgdaMode.$$String.lastIndexOf(";", scanRowText);
  var scanColStart = match !== undefined ? match + 1 | 0 : indent;
  var scanColEnd = self[/* range */2].start.column;
  var bracketCount = 0;
  var i = scanColEnd - 1 | 0;
  while(i >= scanColStart && bracketCount >= 0) {
    var i$prime = i;
    if (i$prime !== 0) {
      var match$1 = scanRowText.charAt(i$prime - 1 | 0);
      switch (match$1) {
        case "{" :
            bracketCount = bracketCount - 1 | 0;
            break;
        case "}" :
            bracketCount = bracketCount + 1 | 0;
            break;
        default:
          
      }
    }
    i = i - 1 | 0;
  };
  var rewriteRangeStart = new Atom.Point(scanRow, i + 1 | 0);
  var rewriteRangeEnd = self[/* range */2].end;
  var rewriteRange = new Atom.Range(rewriteRangeStart, rewriteRangeEnd);
  var isLambdaWhere = (i + 1 | 0) === indent;
  if (isLambdaWhere) {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, Rebase.$$String.joinWith("\n" + " ".repeat(indent), Rebase.List.fromArray(contents)));
    return /* () */0;
  } else {
    self[/* textEditor */0].setTextInBufferRange(rewriteRange, " " + Rebase.$$String.joinWith(" ; ", Rebase.List.fromArray(contents)));
    return /* () */0;
  }
}

function destroy(self) {
  self[/* marker */3].destroy();
  self[/* disposables */5].dispose();
  return /* () */0;
}

function make(textEditor, index, range) {
  var textBuffer = textEditor.getBuffer();
  var startPoint = textBuffer.positionForCharacterIndex(range[0]);
  var endPoint = textBuffer.positionForCharacterIndex(range[1]);
  var range$1 = new Atom.Range(startPoint, endPoint);
  var content = textBuffer.getTextInRange(range$1);
  var marker = textEditor.markBufferRange(range$1);
  var disposables = new Atom.CompositeDisposable();
  var t = /* record */Caml_chrome_debugger.record([
      "textEditor",
      "index",
      "range",
      "marker",
      "content",
      "disposables"
    ], [
      textEditor,
      index,
      range$1,
      marker,
      content,
      disposables
    ]);
  var indexWidth = Rebase.$$String.length(String(index));
  var indexText = String(index);
  var element = document.createElement("div");
  element.innerHTML = indexText;
  element.classList.add("goal-index");
  element.setAttribute("style", "left: " + (String((-indexWidth | 0) - 2 | 0) + "ex ; top: -1.5em"));
  textEditor.decorateMarker(marker, {
        type: "highlight",
        class: "goal"
      });
  textEditor.decorateMarker(marker, {
        type: "overlay",
        item: element,
        position: "head"
      });
  disposables.add(marker.onDidChange((function (_event) {
              var newRange = marker.getBufferRange();
              var newContent = textBuffer.getTextInRange(newRange);
              var deltaLeft = Util$AgdaMode.$$String.indexOf("{!", newContent);
              var deltaRight = Util$AgdaMode.$$String.lastIndexOf("!}", newContent);
              if (deltaLeft !== undefined) {
                var left = deltaLeft;
                if (left === 0 && deltaRight === 1) {
                  return restoreBoundary(t, newRange);
                }
                if (deltaRight !== undefined) {
                  var right$prime = (deltaRight - Rebase.$$String.length(newContent) | 0) + 2 | 0;
                  t[/* range */2] = newRange.translate(new Atom.Point(0, left), new Atom.Point(0, right$prime));
                  t[/* content */4] = textBuffer.getTextInRange(t[/* range */2]);
                  t[/* marker */3].setBufferRange(t[/* range */2], {
                        reversed: false
                      });
                  return /* () */0;
                } else {
                  return restoreBoundary(t, newRange);
                }
              } else if (deltaRight !== undefined) {
                return restoreBoundary(t, newRange);
              } else {
                return destroy(t);
              }
            })));
  return t;
}

function getContent(self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  return Parser$AgdaMode.userInput(self[/* textEditor */0].getTextInBufferRange(range));
}

function setContent(text, self) {
  var range = self[/* range */2].translate(new Atom.Point(0, 2), new Atom.Point(0, -2));
  var paddingSpaces = " ".repeat(Rebase.$$String.length(String(self[/* index */1])));
  return self[/* textEditor */0].setTextInBufferRange(range, " " + (text + (" " + paddingSpaces)));
}

function selectContent(self) {
  var indexWidth = Rebase.$$String.length(String(self[/* index */1]));
  var range = self[/* range */2].translate(new Atom.Point(0, 3), new Atom.Point(0, -(3 + indexWidth | 0) | 0));
  self[/* textEditor */0].setSelectedBufferRange(range, {
        reversed: false,
        preserveFolds: true
      });
  return /* () */0;
}

function isEmpty(self) {
  return Rebase.$$String.isEmpty(getContent(self).replace((/(\s|\\n)*/), ""));
}

function buildHaskellRange(old, filepath, self) {
  var start = self[/* range */2].start;
  var startIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(start);
  var end_ = self[/* range */2].end;
  var endIndex = self[/* textEditor */0].getBuffer().characterIndexForPosition(end_);
  var startIndex$prime = String(startIndex + 3 | 0);
  var startRow = String(start.row + 1 | 0);
  var startColumn = String(start.column + 3 | 0);
  var startPart = "" + (String(startIndex$prime) + (" " + (String(startRow) + (" " + (String(startColumn) + "")))));
  var endIndex$prime = String(endIndex - 3 | 0);
  var endRow = String(end_.row + 1 | 0);
  var endColumn = String(end_.column - 1 | 0);
  var endPart = "" + (String(endIndex$prime) + (" " + (String(endRow) + (" " + (String(endColumn) + "")))));
  if (old) {
    return "(Range [Interval (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(startPart) + (") (Pn (Just (mkAbsolute \"" + (String(filepath) + ("\")) " + (String(endPart) + ")])")))))));
  } else {
    return "(intervalsToRange (Just (mkAbsolute \"" + (String(filepath) + ("\")) [Interval (Pn () " + (String(startPart) + (") (Pn () " + (String(endPart) + ")])")))));
  }
}

exports.FileType = FileType;
exports.restoreBoundary = restoreBoundary;
exports.removeBoundary = removeBoundary;
exports.writeLines = writeLines;
exports.writeLambda = writeLambda;
exports.destroy = destroy;
exports.make = make;
exports.getContent = getContent;
exports.setContent = setContent;
exports.selectContent = selectContent;
exports.isEmpty = isEmpty;
exports.buildHaskellRange = buildHaskellRange;
/* atom Not a pure module */
