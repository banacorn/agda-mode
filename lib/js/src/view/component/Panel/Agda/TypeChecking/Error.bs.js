// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Belt_Debug = require("bs-platform/lib/js/belt_Debug.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Json_decode = require("@glennsl/bs-json/lib/js/src/Json_decode.bs.js");

Belt_Debug.setupChromeDebugger(/* () */0);

function position(param) {
  return Json_decode.andThen((function (tup, _) {
                return /* record */Block.record([
                          "pos",
                          "line",
                          "col"
                        ], [
                          Caml_array.caml_array_get(tup, 2),
                          Caml_array.caml_array_get(tup, 0),
                          Caml_array.caml_array_get(tup, 1)
                        ]);
              }), (function (param) {
                return Json_decode.array(Json_decode.$$int, param);
              }), param);
}

function interval(json) {
  return /* record */Block.record([
            "start",
            "end_"
          ], [
            Json_decode.field("start", position, json),
            Json_decode.field("end", position, json)
          ]);
}

function range(param) {
  return Json_decode.withDefault(/* NoRange */0, (function (json) {
                return /* Range */Block.simpleVariant("Range", [
                          Json_decode.field("source", (function (param) {
                                  return Json_decode.optional(Json_decode.string, param);
                                }), json),
                          Json_decode.field("intervals", (function (param) {
                                  return Json_decode.list(interval, param);
                                }), json)
                        ]);
              }), param);
}

var Position = /* module */Block.localModule([
    "position",
    "interval",
    "range"
  ], [
    position,
    interval,
    range
  ]);

function nameId(json) {
  return /* NameId */Block.simpleVariant("NameId", [
            Json_decode.field("name", Json_decode.$$int, json),
            Json_decode.field("module", Json_decode.$$int, json)
          ]);
}

function namePart(param) {
  return Json_decode.withDefault(/* Hole */0, (function (json) {
                return /* Id */Block.simpleVariant("Id", [Json_decode.string(json)]);
              }), param);
}

function name(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "Name" : 
                      return /* Name */Block.variant("Name", 0, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("parts", (function (param) {
                                        return Json_decode.list(namePart, param);
                                      }), json)
                              ]);
                  case "NoName" : 
                      return /* NoName */Block.variant("NoName", 1, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("name", nameId, json)
                              ]);
                  default:
                    return Pervasives.failwith("unknown kind of Name");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

function qName(json) {
  return Json_decode.list(name, json);
}

var Concrete = /* module */Block.localModule([
    "nameId",
    "namePart",
    "name",
    "qName"
  ], [
    nameId,
    namePart,
    name,
    qName
  ]);

function overlappable(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "NoOverlap" : 
                      return /* NoOverlap */1;
                  case "YesOverlap" : 
                      return /* YesOverlap */0;
                  default:
                    return Pervasives.failwith("unknown kind of Overlappable");
                }
              }), Json_decode.string, param);
}

function relevance(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "Irrelevant" : 
                      return /* Irrelevant */2;
                  case "NonStrict" : 
                      return /* NonStrict */1;
                  case "Relevant" : 
                      return /* Relevant */0;
                  default:
                    return Pervasives.failwith("unknown kind of Relevance");
                }
              }), Json_decode.string, param);
}

function quantity(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "Quantity0" : 
                      return /* Quantity0 */0;
                  case "QuantityOmega" : 
                      return /* QuantityOmega */1;
                  default:
                    return Pervasives.failwith("unknown kind of Quantity");
                }
              }), Json_decode.string, param);
}

function modality(json) {
  return /* record */Block.record([
            "relevance",
            "quantity"
          ], [
            Json_decode.field("relevance", relevance, json),
            Json_decode.field("quantity", quantity, json)
          ]);
}

function origin(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "CaseSplit" : 
                      return /* CaseSplit */3;
                  case "Inserted" : 
                      return /* Inserted */1;
                  case "Reflected" : 
                      return /* Reflected */2;
                  case "Substitution" : 
                      return /* Substitution */4;
                  case "UserWritten" : 
                      return /* UserWritten */0;
                  default:
                    return Pervasives.failwith("unknown kind of Origon");
                }
              }), Json_decode.string, param);
}

function hiding(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "Hidden" : 
                      return /* Hidden */0;
                  case "Instance" : 
                      return /* Instance */Block.simpleVariant("Instance", [Json_decode.field("overlappable", overlappable, json)]);
                  case "NotHidden" : 
                      return /* NotHidden */1;
                  default:
                    return Pervasives.failwith("unknown kind of Hiding");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

function freeVariables(param) {
  return Json_decode.withDefault(/* UnknownFVs */0, (function (json) {
                return /* KnownFVs */Block.simpleVariant("KnownFVs", [Json_decode.array(Json_decode.$$int, json)]);
              }), param);
}

function argInfo(json) {
  return /* record */Block.record([
            "hiding",
            "modality",
            "origin",
            "freeVariables"
          ], [
            Json_decode.field("hiding", hiding, json),
            Json_decode.field("modality", modality, json),
            Json_decode.field("origin", origin, json),
            Json_decode.field("freeVars", freeVariables, json)
          ]);
}

function arg(decoder, json) {
  return /* record */Block.record([
            "argInfo",
            "value"
          ], [
            Json_decode.field("argInfo", argInfo, json),
            Json_decode.field("value", decoder, json)
          ]);
}

function ranged(decoder, json) {
  return /* record */Block.record([
            "range",
            "value"
          ], [
            Json_decode.field("range", range, json),
            Json_decode.field("value", decoder, json)
          ]);
}

function named(nameDecoder, valueDecoder, json) {
  return /* record */Block.record([
            "name",
            "value"
          ], [
            Json_decode.field("name", (function (param) {
                    return Json_decode.optional(nameDecoder, param);
                  }), json),
            Json_decode.field("value", valueDecoder, json)
          ]);
}

function namedArg(decoder) {
  return (function (param) {
      return arg((function (param) {
                    return named((function (param) {
                                  return ranged(Json_decode.string, param);
                                }), decoder, param);
                  }), param);
    });
}

var CommonPrim = /* module */Block.localModule([
    "overlappable",
    "relevance",
    "quantity",
    "modality",
    "origin",
    "hiding",
    "freeVariables",
    "argInfo",
    "arg",
    "ranged",
    "named",
    "namedArg"
  ], [
    overlappable,
    relevance,
    quantity,
    modality,
    origin,
    hiding,
    freeVariables,
    argInfo,
    arg,
    ranged,
    named,
    namedArg
  ]);

function genPart(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "BindHole" : 
                      return /* BindHole */Block.variant("BindHole", 0, [Json_decode.field("position", Json_decode.$$int, json)]);
                  case "IdPart" : 
                      return /* IdPart */Block.variant("IdPart", 3, [Json_decode.field("rawName", Json_decode.string, json)]);
                  case "NormalHole" : 
                      return /* NormalHole */Block.variant("NormalHole", 1, [Json_decode.field("position", namedArg(Json_decode.$$int), json)]);
                  case "WildHole" : 
                      return /* WildHole */Block.variant("WildHole", 2, [Json_decode.field("position", Json_decode.$$int, json)]);
                  default:
                    return Pervasives.failwith("unknown kind of GenPart");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

function notation(param) {
  return Json_decode.list(genPart, param);
}

var Notation = /* module */Block.localModule([
    "genPart",
    "notation"
  ], [
    genPart,
    notation
  ]);

function precedenceLevel(param) {
  return Json_decode.withDefault(/* Unrelated */0, (function (json) {
                return /* Related */Block.simpleVariant("Related", [Json_decode.$$int(json)]);
              }), param);
}

function associativity(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "LeftAssoc" : 
                      return /* LeftAssoc */1;
                  case "NonAssoc" : 
                      return /* NonAssoc */0;
                  case "RightAssoc" : 
                      return /* RightAssoc */2;
                  default:
                    return Pervasives.failwith("unknown kind of Sssociativity");
                }
              }), Json_decode.string, param);
}

function fixity(json) {
  return /* record */Block.record([
            "range",
            "level",
            "assoc"
          ], [
            Json_decode.field("range", range, json),
            Json_decode.field("level", precedenceLevel, json),
            Json_decode.field("assoc", associativity, json)
          ]);
}

function fixity$prime(json) {
  return /* record */Block.record([
            "fixity",
            "notation",
            "range"
          ], [
            Json_decode.field("fixity", fixity, json),
            Json_decode.field("notation", notation, json),
            Json_decode.field("range", range, json)
          ]);
}

var Fixity = /* module */Block.localModule([
    "precedenceLevel",
    "associativity",
    "fixity",
    "fixity'"
  ], [
    precedenceLevel,
    associativity,
    fixity,
    fixity$prime
  ]);

function name$1(json) {
  return /* record */Block.record([
            "nameId",
            "concrete",
            "bindingSite",
            "fixity"
          ], [
            Json_decode.field("id", nameId, json),
            Json_decode.field("concrete", name, json),
            Json_decode.field("bindingSite", range, json),
            Json_decode.field("fixity", fixity$prime, json)
          ]);
}

function moduleName(json) {
  return /* MName */Block.simpleVariant("MName", [Json_decode.list(name$1, json)]);
}

function qName$1(json) {
  return /* record */Block.record([
            "module_",
            "name"
          ], [
            Json_decode.field("module", moduleName, json),
            Json_decode.field("name", name$1, json)
          ]);
}

var Abstract = /* module */Block.localModule([
    "moduleName",
    "name",
    "qName"
  ], [
    moduleName,
    name$1,
    qName$1
  ]);

function literal(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "LitChar" : 
                      return /* LitChar */Block.variant("LitChar", 4, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.$$char, json)
                              ]);
                  case "LitFloat" : 
                      return /* LitFloat */Block.variant("LitFloat", 2, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.$$float, json)
                              ]);
                  case "LitMeta" : 
                      return /* LitMeta */Block.variant("LitMeta", 6, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.string, json),
                                Json_decode.field("value", Json_decode.$$int, json)
                              ]);
                  case "LitNat" : 
                      return /* LitNat */Block.variant("LitNat", 0, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.$$int, json)
                              ]);
                  case "LitQName" : 
                      return /* LitQName */Block.variant("LitQName", 5, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", qName$1, json)
                              ]);
                  case "LitString" : 
                      return /* LitString */Block.variant("LitString", 3, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.string, json)
                              ]);
                  case "LitWord64" : 
                      return /* LitWord64 */Block.variant("LitWord64", 1, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("value", Json_decode.$$int, json)
                              ]);
                  default:
                    return Pervasives.failwith("unknown kind of Literal");
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

var Literal = /* module */Block.localModule(["literal"], [literal]);

function conOrigin(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "ConOCon" : 
                      return /* ConOCon */1;
                  case "ConORec" : 
                      return /* ConORec */2;
                  case "ConOSplit" : 
                      return /* ConOSplit */3;
                  case "ConOSystem" : 
                      return /* ConOSystem */0;
                  default:
                    return Pervasives.failwith("unknown kind of ConOrigin");
                }
              }), Json_decode.string, param);
}

function projOrigin(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "ProjPostfix" : 
                      return /* ProjPostfix */1;
                  case "ProjPrefix" : 
                      return /* ProjPrefix */0;
                  case "ProjSystem" : 
                      return /* ProjSystem */2;
                  default:
                    return Pervasives.failwith("unknown kind of ProjOrigin");
                }
              }), Json_decode.string, param);
}

function induction(param) {
  return Json_decode.andThen((function (kind, _) {
                switch (kind) {
                  case "CoInductive" : 
                      return /* CoInductive */1;
                  case "Inductive" : 
                      return /* Inductive */0;
                  default:
                    return Pervasives.failwith("unknown kind of Induction");
                }
              }), Json_decode.string, param);
}

function dom(decoder, json) {
  return /* record */Block.record([
            "argInfo",
            "finite",
            "value"
          ], [
            Json_decode.field("argInfo", argInfo, json),
            Json_decode.field("finite", Json_decode.bool, json),
            Json_decode.field("value", decoder, json)
          ]);
}

var Common = /* module */Block.localModule([
    "conOrigin",
    "projOrigin",
    "induction",
    "dom"
  ], [
    conOrigin,
    projOrigin,
    induction,
    dom
  ]);

function conHead(json) {
  return /* record */Block.record([
            "name",
            "inductive",
            "fields"
          ], [
            qName$1(json),
            induction(json),
            Json_decode.list((function (param) {
                    return arg(qName$1, param);
                  }), json)
          ]);
}

function abs(decoder) {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "Abs" : 
                          return /* Abs */Block.variant("Abs", 0, [
                                    Json_decode.field("name", Json_decode.string, json),
                                    Json_decode.field("value", decoder, json)
                                  ]);
                      case "NoAbs" : 
                          return /* NoAbs */Block.variant("NoAbs", 1, [
                                    Json_decode.field("name", Json_decode.string, json),
                                    Json_decode.field("value", decoder, json)
                                  ]);
                      default:
                        return Pervasives.failwith("unknown kind of Abs");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function elim$prime(decoder) {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "Apply" : 
                          return /* Apply */Block.variant("Apply", 0, [Json_decode.field("arg", (function (param) {
                                            return arg(decoder, param);
                                          }), json)]);
                      case "IApply" : 
                          return /* IApply */Block.variant("IApply", 2, [
                                    Json_decode.field("endpoint1", decoder, json),
                                    Json_decode.field("endpoint2", decoder, json),
                                    Json_decode.field("endpoint3", decoder, json)
                                  ]);
                      case "Proj" : 
                          return /* Proj */Block.variant("Proj", 1, [
                                    Json_decode.field("projOrigin", projOrigin, json),
                                    Json_decode.field("name", qName$1, json)
                                  ]);
                      default:
                        return Pervasives.failwith("unknown kind of Elim");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function term() {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "Con" : 
                          var partial_arg = elim$prime(term(/* () */0));
                          return /* Con */Block.variant("Con", 4, [
                                    Json_decode.field("conHead", conHead, json),
                                    Json_decode.field("conInfo", conOrigin, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg, param);
                                          }), json)
                                  ]);
                      case "Def" : 
                          var partial_arg$1 = elim$prime(term(/* () */0));
                          return /* Def */Block.variant("Def", 3, [
                                    Json_decode.field("name", qName$1, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg$1, param);
                                          }), json)
                                  ]);
                      case "DontCare" : 
                          return /* DontCare */Block.variant("DontCare", 9, [Json_decode.field("term", term(/* () */0), json)]);
                      case "Dummy" : 
                          return /* Dummy */Block.variant("Dummy", 10, [Json_decode.field("description", Json_decode.string, json)]);
                      case "Lam" : 
                          return /* Lam */Block.variant("Lam", 1, [
                                    Json_decode.field("argInfo", argInfo, json),
                                    Json_decode.field("binder", abs(term(/* () */0)), json)
                                  ]);
                      case "Level" : 
                          return /* Level */Block.variant("Level", 7, [Json_decode.field("level", level, json)]);
                      case "Lit" : 
                          return /* Lit */Block.variant("Lit", 2, [Json_decode.field("literal", literal, json)]);
                      case "MetaV" : 
                          var partial_arg$2 = elim$prime(term(/* () */0));
                          return /* MetaV */Block.variant("MetaV", 8, [
                                    Json_decode.field("metaId", Json_decode.$$int, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg$2, param);
                                          }), json)
                                  ]);
                      case "Pi" : 
                          return /* Pi */Block.variant("Pi", 5, [
                                    Json_decode.field("domain", (function (param) {
                                            return dom(type_, param);
                                          }), json),
                                    Json_decode.field("binder", abs(type_), json)
                                  ]);
                      case "Sort" : 
                          return /* Sort */Block.variant("Sort", 6, [Json_decode.field("sort", sort(/* () */0), json)]);
                      case "Var" : 
                          var partial_arg$3 = elim$prime(term(/* () */0));
                          return /* Var */Block.variant("Var", 0, [
                                    Json_decode.field("index", Json_decode.$$int, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg$3, param);
                                          }), json)
                                  ]);
                      default:
                        return Pervasives.failwith("unknown kind of Term");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function notBlocked() {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "AbsurdMatch" : 
                          return /* AbsurdMatch */1;
                      case "MissingClauses" : 
                          return /* MissingClauses */2;
                      case "ReallyNotBlocked" : 
                          return /* ReallyNotBlocked */3;
                      case "StuckOn" : 
                          return /* StuckOn */Block.simpleVariant("StuckOn", [Json_decode.field("elim", elim$prime(term(/* () */0)), json)]);
                      case "Underapplied" : 
                          return /* Underapplied */0;
                      default:
                        return Pervasives.failwith("unknown kind of NotBlocked");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function level(json) {
  return Json_decode.list(plusLevel(/* () */0), json);
}

function type_(json) {
  return typeG(term(/* () */0), json);
}

function sort() {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "Inf" : 
                          return /* Inf */0;
                      case "MetaS" : 
                          var partial_arg = elim$prime(term(/* () */0));
                          return /* MetaS */Block.variant("MetaS", 4, [
                                    Json_decode.field("metaId", Json_decode.$$int, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg, param);
                                          }), json)
                                  ]);
                      case "PiSort" : 
                          return /* PiSort */Block.variant("PiSort", 2, [
                                    Json_decode.field("sort", sort(/* () */0), json),
                                    Json_decode.field("binder", abs(sort(/* () */0)), json)
                                  ]);
                      case "Prop" : 
                          return /* Prop */Block.variant("Prop", 1, [Json_decode.field("level", level, json)]);
                      case "SizeUniv" : 
                          return /* SizeUniv */1;
                      case "Type" : 
                          return /* Type */Block.variant("Type", 0, [Json_decode.field("level", level, json)]);
                      case "UnivSort" : 
                          return /* UnivSort */Block.variant("UnivSort", 3, [Json_decode.field("sort", sort(/* () */0), json)]);
                      default:
                        return Pervasives.failwith("unknown kind of Sort");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function plusLevel() {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "ClosedLevel" : 
                          return /* ClosedLevel */Block.variant("ClosedLevel", 0, [Json_decode.field("level", Json_decode.$$int, json)]);
                      case "Plus" : 
                          return /* Plus */Block.variant("Plus", 1, [
                                    Json_decode.field("level", Json_decode.$$int, json),
                                    Json_decode.field("levelAtom", levelAtom(/* () */0), json)
                                  ]);
                      default:
                        return Pervasives.failwith("unknown kind of PlusLevel");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function typeG(decoder, json) {
  return /* record */Block.record([
            "sort",
            "value"
          ], [
            Json_decode.field("sort", sort(/* () */0), json),
            Json_decode.field("value", decoder, json)
          ]);
}

function levelAtom() {
  return (function (param) {
      return Json_decode.andThen((function (kind, json) {
                    switch (kind) {
                      case "BlockedLevel" : 
                          return /* BlockedLevel */Block.variant("BlockedLevel", 1, [
                                    Json_decode.field("metaId", Json_decode.$$int, json),
                                    Json_decode.field("term", term(/* () */0), json)
                                  ]);
                      case "MetalLevel" : 
                          var partial_arg = elim$prime(term(/* () */0));
                          return /* MetalLevel */Block.variant("MetalLevel", 0, [
                                    Json_decode.field("metaId", Json_decode.$$int, json),
                                    Json_decode.field("elims", (function (param) {
                                            return Json_decode.list(partial_arg, param);
                                          }), json)
                                  ]);
                      case "NeutralLevel" : 
                          return /* NeutralLevel */Block.variant("NeutralLevel", 2, [
                                    Json_decode.field("notBlocked", notBlocked(/* () */0), json),
                                    Json_decode.field("term", term(/* () */0), json)
                                  ]);
                      case "UnreducedLevel" : 
                          return /* UnreducedLevel */Block.variant("UnreducedLevel", 3, [Json_decode.field("term", term(/* () */0), json)]);
                      default:
                        return Pervasives.failwith("unknown kind of LevelAtom");
                    }
                  }), (function (param) {
                    return Json_decode.field("kind", Json_decode.string, param);
                  }), param);
    });
}

function elim() {
  return elim$prime(term(/* () */0));
}

var Internal = /* module */Block.localModule([
    "conHead",
    "conInfo",
    "abs",
    "elim'",
    "elim",
    "notBlocked",
    "levelAtom",
    "plusLevel",
    "level",
    "sort",
    "typeG",
    "term",
    "type_"
  ], [
    conHead,
    conOrigin,
    abs,
    elim$prime,
    elim,
    notBlocked,
    levelAtom,
    plusLevel,
    level,
    sort,
    typeG,
    term,
    type_
  ]);

var Syntax = /* module */Block.localModule([
    "Position",
    "Concrete",
    "CommonPrim",
    "Notation",
    "Fixity",
    "Abstract",
    "Literal",
    "Common",
    "Internal"
  ], [
    Position,
    Concrete,
    CommonPrim,
    Notation,
    Fixity,
    Abstract,
    Literal,
    Common,
    Internal
  ]);

function comparison(param) {
  return Json_decode.andThen((function (kind, _) {
                if (kind === "CmpLeq") {
                  return /* CmpLeq */0;
                } else {
                  return /* CmpEq */1;
                }
              }), Json_decode.string, param);
}

function typeError(param) {
  return Json_decode.andThen((function (kind, json) {
                if (kind === "UnequalTerms") {
                  return /* UnequalTerms */Block.variant("UnequalTerms", 0, [
                            Json_decode.field("comparison", comparison, json),
                            Json_decode.field("term1", term(/* () */0), json),
                            Json_decode.field("term2", term(/* () */0), json),
                            Json_decode.field("type", type_, json),
                            Json_decode.field("reason", Json_decode.string, json)
                          ]);
                } else {
                  return /* UnregisteredTypeError */Block.variant("UnregisteredTypeError", 1, [json]);
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

function error(param) {
  return Json_decode.andThen((function (kind, json) {
                switch (kind) {
                  case "Exception" : 
                      return /* Exception */Block.variant("Exception", 1, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("message", Json_decode.string, json)
                              ]);
                  case "IOException" : 
                      return /* IOException */Block.variant("IOException", 2, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("message", Json_decode.string, json)
                              ]);
                  case "PatternError" : 
                      return /* PatternError */Block.variant("PatternError", 3, [Json_decode.field("range", range, json)]);
                  case "TypeError" : 
                      return /* TypeError */Block.variant("TypeError", 0, [
                                Json_decode.field("range", range, json),
                                Json_decode.field("typeError", typeError, json)
                              ]);
                  default:
                    return /* IOException */Block.variant("IOException", 2, [
                              Json_decode.field("range", range, json),
                              "JSON Parse Error"
                            ]);
                }
              }), (function (param) {
                return Json_decode.field("kind", Json_decode.string, param);
              }), param);
}

var TypeChecking = /* module */Block.localModule([
    "comparison",
    "typeError",
    "error"
  ], [
    comparison,
    typeError,
    error
  ]);

var Decode = /* module */Block.localModule([
    "Syntax",
    "TypeChecking"
  ], [
    Syntax,
    TypeChecking
  ]);

function parseError(json) {
  console.log(json);
  var error$1 = error(json);
  console.log(error$1);
  return /* () */0;
}

exports.Decode = Decode;
exports.parseError = parseError;
/*  Not a pure module */
