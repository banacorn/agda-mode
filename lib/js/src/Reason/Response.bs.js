// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var Block = require("bs-platform/lib/js/block.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Goal$AgdaMode = require("./Goal.bs.js");
var Hole$AgdaMode = require("./Hole.bs.js");
var Util$AgdaMode = require("./Util.bs.js");
var Emacs__Parser$AgdaMode = require("./View/Emacs/Emacs__Parser.bs.js");

function parse(param) {
  if (param.tag) {
    var xs = param[0];
    var exit = 0;
    switch (xs.length) {
      case 4 : 
          var match = xs[0];
          if (match.tag) {
            exit = 1;
          } else {
            var match$1 = xs[1];
            if (match$1.tag) {
              exit = 1;
            } else {
              var type_ = xs[2];
              return /* Ok */Block.variant("Ok", 0, [/* WithoutSource */Block.variant("WithoutSource", 1, [
                            Caml_format.caml_int_of_string(match[0]),
                            Caml_format.caml_int_of_string(match$1[0]),
                            Emacs__Parser$AgdaMode.SExpression[/* flatten */2](type_)
                          ])]);
            }
          }
          break;
      case 5 : 
          exit = 1;
          break;
      case 6 : 
          var match$2 = xs[0];
          if (match$2.tag) {
            exit = 1;
          } else {
            var match$3 = xs[1];
            if (match$3.tag) {
              exit = 1;
            } else {
              var type_$1 = xs[2];
              var match$4 = xs[5];
              if (match$4.tag) {
                var match$5 = match$4[0];
                if (match$5.length !== 3) {
                  exit = 1;
                } else {
                  var match$6 = match$5[0];
                  if (match$6.tag) {
                    exit = 1;
                  } else {
                    var match$7 = match$5[2];
                    if (match$7.tag) {
                      exit = 1;
                    } else {
                      return /* Ok */Block.variant("Ok", 0, [/* WithSource */Block.variant("WithSource", 0, [
                                    Caml_format.caml_int_of_string(match$2[0]),
                                    Caml_format.caml_int_of_string(match$3[0]),
                                    Emacs__Parser$AgdaMode.SExpression[/* flatten */2](type_$1),
                                    match$6[0],
                                    Caml_format.caml_int_of_string(match$7[0])
                                  ])]);
                    }
                  }
                }
              } else {
                exit = 1;
              }
            }
          }
          break;
      default:
        exit = 1;
    }
    if (exit === 1) {
      return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* L */Block.variant("L", 1, [xs]))]);
    }
    
  } else {
    return /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](/* A */Block.variant("A", 0, [param[0]]))]);
  }
}

var Annotation = /* module */Block.localModule(["parse"], [parse]);

var Highlighting = /* module */Block.localModule(["Annotation"], [Annotation]);

function parse$1(xs) {
  var match = Rebase.$$Array[/* get */17](xs, 1);
  if (match !== undefined) {
    var match$1 = match;
    if (match$1.tag) {
      return undefined;
    } else {
      var payload = match$1[0].replace((/\\r\\n|\\n/g), "\n");
      var match$2 = Rebase.$$Array[/* get */17](xs, 0);
      if (match$2 !== undefined) {
        var match$3 = match$2;
        if (match$3.tag) {
          return undefined;
        } else {
          var title = match$3[0];
          switch (title) {
            case "*Agda Version*" : 
                return /* Version */Block.variant("Version", 15, [payload]);
            case "*Auto*" : 
                return /* Auto */Block.variant("Auto", 5, [payload]);
            case "*Compilation result*" : 
                return /* CompilationOk */0;
            case "*Constraints*" : 
                if (payload === "nil") {
                  return /* Constraints */Block.variant("Constraints", 0, [undefined]);
                } else {
                  return /* Constraints */Block.variant("Constraints", 0, [payload]);
                }
            case "*Context*" : 
                return /* Context */Block.variant("Context", 13, [payload]);
            case "*Current Goal*" : 
                return /* CurrentGoal */Block.variant("CurrentGoal", 11, [payload]);
            case "*Error*" : 
                return /* Error */Block.variant("Error", 3, [payload]);
            case "*Goal type etc.*" : 
                return /* GoalType */Block.variant("GoalType", 10, [payload]);
            case "*Helper function*" : 
                return /* HelperFunction */Block.variant("HelperFunction", 14, [payload]);
            case "*Inferred Type*" : 
                return /* InferredType */Block.variant("InferredType", 12, [payload]);
            case "*Intro*" : 
                return /* Intro */Block.variant("Intro", 4, [payload]);
            case "*Module contents*" : 
                return /* ModuleContents */Block.variant("ModuleContents", 6, [payload]);
            case "*Normal Form*" : 
                return /* NormalForm */Block.variant("NormalForm", 9, [payload]);
            case "*Scope Info*" : 
                return /* WhyInScope */Block.variant("WhyInScope", 8, [payload]);
            case "*Search About*" : 
                return /* SearchAbout */Block.variant("SearchAbout", 7, [payload]);
            case "*Time*" : 
                return /* Time */Block.variant("Time", 2, [payload]);
            default:
              return /* AllGoalsWarnings */Block.variant("AllGoalsWarnings", 1, [Emacs__Parser$AgdaMode.Response[/* allGoalsWarnings */1](title, payload)]);
          }
        }
      } else {
        return undefined;
      }
    }
  }
  
}

function handle(instance, info) {
  var update = function (header, body) {
    Util$AgdaMode.Event[/* resolve */9](header, instance[/* view */1][/* updateHeader */0]);
    return Util$AgdaMode.Event[/* resolve */9](body, instance[/* view */1][/* updateBody */1]);
  };
  if (typeof info === "number") {
    return update(/* record */Block.record([
                  "text",
                  "style"
                ], [
                  "Compilation Done!",
                  3
                ]), /* Nothing */0);
  } else {
    switch (info.tag | 0) {
      case 0 : 
          var match = info[0];
          if (match !== undefined) {
            return update(/* record */Block.record([
                          "text",
                          "style"
                        ], [
                          "Constraints",
                          2
                        ]), /* Emacs */Block.variant("Emacs", 0, [/* Constraints */Block.variant("Constraints", 3, [match])]));
          } else {
            return update(/* record */Block.record([
                          "text",
                          "style"
                        ], [
                          "No Constraints",
                          3
                        ]), /* Nothing */0);
          }
      case 1 : 
          var payload = info[0];
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        payload[/* title */0],
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* AllGoalsWarnings */Block.variant("AllGoalsWarnings", 0, [payload])]));
      case 2 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Time",
                        0
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 3 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Error",
                        1
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* Error */Block.variant("Error", 6, [info[0]])]));
      case 4 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Intro",
                        0
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 5 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Auto",
                        0
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 6 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Module Contents",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 7 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Searching about ...",
                        0
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* SearchAbout */Block.variant("SearchAbout", 5, [info[0]])]));
      case 8 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Scope info",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* WhyInScope */Block.variant("WhyInScope", 4, [info[0]])]));
      case 9 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Normal form",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 10 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Goal type",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* GoalTypeContext */Block.variant("GoalTypeContext", 1, [info[0]])]));
      case 11 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Current goal",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 12 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Inferred type",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 13 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Context",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* Context */Block.variant("Context", 2, [info[0]])]));
      case 14 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Helper function",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      case 15 : 
          return update(/* record */Block.record([
                        "text",
                        "style"
                      ], [
                        "Version",
                        2
                      ]), /* Emacs */Block.variant("Emacs", 0, [/* PlainText */Block.variant("PlainText", 7, [info[0]])]));
      
    }
  }
}

var Info = /* module */Block.localModule([
    "parse",
    "handle"
  ], [
    parse$1,
    handle
  ]);

function parse$2(tokens) {
  var err = /* Error */Block.variant("Error", 1, [Emacs__Parser$AgdaMode.SExpression[/* toString */1](tokens)]);
  if (tokens.tag) {
    var xs = tokens[0];
    var match = Rebase.$$Array[/* get */17](xs, 0);
    var exit = 0;
    if (match !== undefined) {
      var match$1 = match;
      if (match$1.tag) {
        return err;
      } else {
        switch (match$1[0]) {
          case "agda2-abort-done" : 
              return /* Ok */Block.variant("Ok", 0, [/* DoneAborting */2]);
          case "agda2-give-action" : 
              var match$2 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$2 !== undefined) {
                var match$3 = match$2;
                if (match$3.tag) {
                  return err;
                } else {
                  var i = Caml_format.caml_int_of_string(match$3[0]);
                  var match$4 = Rebase.$$Array[/* get */17](xs, 2);
                  if (match$4 !== undefined) {
                    var match$5 = match$4;
                    if (match$5.tag) {
                      return err;
                    } else {
                      var result = match$5[0];
                      switch (result) {
                        case "no-paren" : 
                            return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                          i,
                                          /* NoParen */1
                                        ])]);
                        case "paren" : 
                            return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                          i,
                                          /* Paren */0
                                        ])]);
                        default:
                          return /* Ok */Block.variant("Ok", 0, [/* GiveAction */Block.variant("GiveAction", 5, [
                                        i,
                                        /* String */Block.simpleVariant("String", [result])
                                      ])]);
                      }
                    }
                  } else {
                    return err;
                  }
                }
              } else {
                return err;
              }
          case "agda2-goals-action" : 
              var match$6 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$6 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* InteractionPoints */Block.variant("InteractionPoints", 4, [Rebase.$$Array[/* map */0](Caml_format.caml_int_of_string, Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$6))])]);
              } else {
                return err;
              }
          case "agda2-highlight-add-annotations" : 
              var annotations = Rebase.$$Array[/* filterMap */23](Rebase.Option[/* fromResult */12], Rebase.$$Array[/* map */0](parse, xs.slice(2)));
              var match$7 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$7 !== undefined) {
                var match$8 = match$7;
                if (match$8.tag) {
                  return err;
                } else {
                  switch (match$8[0]) {
                    case "nil" : 
                        return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoDirect */Block.variant("HighlightingInfoDirect", 0, [
                                      /* Keep */1,
                                      annotations
                                    ])]);
                    case "remove" : 
                        return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoDirect */Block.variant("HighlightingInfoDirect", 0, [
                                      /* Remove */0,
                                      annotations
                                    ])]);
                    default:
                      return err;
                  }
                }
              } else {
                return err;
              }
          case "agda2-highlight-clear" : 
              return /* Ok */Block.variant("Ok", 0, [/* ClearHighlighting */1]);
          case "agda2-highlight-load-and-delete-action" : 
              var match$9 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$9 !== undefined) {
                var match$10 = match$9;
                if (match$10.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* HighlightingInfoIndirect */Block.variant("HighlightingInfoIndirect", 1, [match$10[0]])]);
                }
              } else {
                return err;
              }
          case "agda2-info-action" : 
          case "agda2-info-action-and-copy" : 
              exit = 1;
              break;
          case "agda2-make-case-action" : 
              var match$11 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$11 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* MakeCase */Block.variant("MakeCase", 6, [
                              /* Function */0,
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$11)
                            ])]);
              } else {
                return err;
              }
          case "agda2-make-case-action-extendlam" : 
              var match$12 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$12 !== undefined) {
                return /* Ok */Block.variant("Ok", 0, [/* MakeCase */Block.variant("MakeCase", 6, [
                              /* ExtendedLambda */1,
                              Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$12)
                            ])]);
              } else {
                return err;
              }
          case "agda2-maybe-goto" : 
              var match$13 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$13 !== undefined) {
                var match$14 = match$13;
                if (match$14.tag) {
                  var match$15 = match$14[0];
                  if (match$15.length !== 3) {
                    return err;
                  } else {
                    var match$16 = match$15[0];
                    if (match$16.tag) {
                      return err;
                    } else {
                      var match$17 = match$15[2];
                      if (match$17.tag) {
                        return err;
                      } else {
                        return /* Ok */Block.variant("Ok", 0, [/* JumpToError */Block.variant("JumpToError", 3, [
                                      match$16[0],
                                      Caml_format.caml_int_of_string(match$17[0])
                                    ])]);
                      }
                    }
                  }
                } else {
                  return err;
                }
              } else {
                return err;
              }
          case "agda2-solveAll-action" : 
              var match$18 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$18 !== undefined) {
                var tokens$1 = Emacs__Parser$AgdaMode.SExpression[/* flatten */2](match$18);
                var isEven = function (i) {
                  return i % 2 === 0;
                };
                var i$1 = /* record */Block.record(["contents"], [0]);
                var solutions = Rebase.$$Array[/* filterMap */23]((function (token) {
                        var solution;
                        if (isEven(i$1[0])) {
                          var index = Caml_format.caml_int_of_string(token);
                          solution = Rebase.Option[/* map */0]((function (s) {
                                  return /* tuple */[
                                          index,
                                          s
                                        ];
                                }), Rebase.$$Array[/* get */17](tokens$1, i$1[0] + 1 | 0));
                        } else {
                          solution = undefined;
                        }
                        i$1[0] = i$1[0] + 1 | 0;
                        return solution;
                      }), tokens$1);
                return /* Ok */Block.variant("Ok", 0, [/* SolveAll */Block.variant("SolveAll", 7, [solutions])]);
              } else {
                return err;
              }
          case "agda2-status-action" : 
              var match$19 = Rebase.$$Array[/* get */17](xs, 1);
              if (match$19 !== undefined) {
                var match$20 = match$19;
                if (match$20.tag) {
                  return err;
                } else {
                  var pulp = match$20[0].split(",");
                  return /* Ok */Block.variant("Ok", 0, [/* Status */Block.variant("Status", 2, [
                                pulp.includes("ShowImplicit"),
                                pulp.includes("Checked")
                              ])]);
                }
              } else {
                return err;
              }
          case "agda2-verbose" : 
              var match$21 = Rebase.$$Array[/* get */17](xs, 2);
              if (match$21 !== undefined) {
                var match$22 = match$21;
                if (match$22.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* RunningInfo */Block.variant("RunningInfo", 9, [
                                2,
                                match$22[0]
                              ])]);
                }
              } else {
                return err;
              }
          default:
            return err;
        }
      }
    } else {
      return err;
    }
    if (exit === 1) {
      var match$23 = Rebase.$$Array[/* get */17](xs, 1);
      var exit$1 = 0;
      if (match$23 !== undefined) {
        var match$24 = match$23;
        if (match$24.tag || match$24[0] !== "*Type-checking*") {
          exit$1 = 2;
        } else {
          var match$25 = Rebase.$$Array[/* get */17](xs, 3);
          if (match$25 !== undefined) {
            var match$26 = match$25;
            if (match$26.tag || match$26[0] !== "t") {
              return /* Ok */Block.variant("Ok", 0, [/* ClearRunningInfo */0]);
            } else {
              var match$27 = Rebase.$$Array[/* get */17](xs, 2);
              if (match$27 !== undefined) {
                var match$28 = match$27;
                if (match$28.tag) {
                  return err;
                } else {
                  return /* Ok */Block.variant("Ok", 0, [/* RunningInfo */Block.variant("RunningInfo", 9, [
                                1,
                                match$28[0]
                              ])]);
                }
              } else {
                return err;
              }
            }
          } else {
            return /* Ok */Block.variant("Ok", 0, [/* ClearRunningInfo */0]);
          }
        }
      } else {
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        var match$29 = parse$1(xs.slice(1));
        if (match$29 !== undefined) {
          return /* Ok */Block.variant("Ok", 0, [/* DisplayInfo */Block.variant("DisplayInfo", 8, [match$29])]);
        } else {
          return err;
        }
      }
      
    }
    
  } else {
    return err;
  }
}

function handle$1(instance, response) {
  if (typeof response === "number") {
    console.log(response);
    return /* () */0;
  } else {
    switch (response.tag | 0) {
      case 4 : 
          Rebase.$$Array[/* forEach */8](Goal$AgdaMode.destroy, instance[/* goals */2]);
          instance[/* goals */2] = /* array */[];
          var filePath = instance[/* editors */0][/* source */1].getPath();
          var source = instance[/* editors */0][/* source */1].getText();
          var textBuffer = instance[/* editors */0][/* source */1].getBuffer();
          var fileType = Goal$AgdaMode.FileType[/* parse */0](filePath);
          var result = Hole$AgdaMode.parse(source, response[0], fileType);
          instance[/* goals */2] = Rebase.$$Array[/* map */0]((function (result) {
                  var start = textBuffer.positionForCharacterIndex(result[/* originalRange */2][0]);
                  var end_ = textBuffer.positionForCharacterIndex(result[/* originalRange */2][1]);
                  var range = new Atom.Range(start, end_);
                  instance[/* editors */0][/* source */1].setTextInBufferRange(range, result[/* content */3]);
                  return Goal$AgdaMode.make(instance[/* editors */0][/* source */1], result[/* index */0], result[/* modifiedRange */1]);
                }), result);
          return /* () */0;
      case 8 : 
          Util$AgdaMode.Event[/* resolve */9](true, instance[/* view */1][/* activatePanel */4]);
          return handle(instance, response[0]);
      default:
        console.log(response);
        return /* () */0;
    }
  }
}

var Event = 0;

var Token = 0;

exports.Event = Event;
exports.Token = Token;
exports.Highlighting = Highlighting;
exports.Info = Info;
exports.parse = parse$2;
exports.handle = handle$1;
/* atom Not a pure module */
