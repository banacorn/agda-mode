// Generated by BUCKLESCRIPT VERSION 5.0.3, PLEASE EDIT WITH CARE
'use strict';

var Atom = require("atom");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var ReactUpdate = require("reason-react-update/lib/js/src/ReactUpdate.bs.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Hook$AgdaMode = require("../Hook.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Event$AgdaMode = require("../../Util/Event.bs.js");
var Editors$AgdaMode = require("../../Editors.bs.js");
var ReasonReactCompat = require("reason-react/lib/js/src/ReasonReactCompat.js");
var KeymapJs = require("./../../../../../asset/keymap.js");

var rawKeymap = KeymapJs.default;

function toTrie(obj) {
  var symbol = (
    obj[">>"] || ""
  );
  var subTrie = Js_dict.fromArray(Rebase.$$Array[/* map */0]((function (key) {
              return /* tuple */[
                      key,
                      toTrie((
      obj[key]
    ))
                    ];
            }), Rebase.$$Array[/* filter */10]((function (key) {
                  return key !== ">>";
                }), Object.keys(obj))));
  return /* record */Block.record([
            "symbol",
            "subTrie"
          ], [
            symbol,
            subTrie
          ]);
}

var keymap = toTrie(rawKeymap);

function toKeySuggestions(trie) {
  return Object.keys(trie[/* subTrie */1]);
}

function toCandidateSymbols(trie) {
  return trie[/* symbol */0];
}

function isInKeymap(input) {
  var _input = input;
  var _trie = keymap;
  while(true) {
    var trie = _trie;
    var input$1 = _input;
    var n = Rebase.$$String[/* length */1](input$1);
    if (n !== 0) {
      var key = Rebase.$$String[/* sub */9](0, 1, input$1);
      var rest = Rebase.$$String[/* sub */9](1, n - 1 | 0, input$1);
      var match = Js_dict.get(trie[/* subTrie */1], key);
      if (match !== undefined) {
        _trie = match;
        _input = rest;
        continue ;
      } else {
        return undefined;
      }
    } else {
      return trie;
    }
  };
}

function translate(input) {
  var match = isInKeymap(input.substr(1));
  if (match !== undefined) {
    var trie = match;
    var keySuggestions = Object.keys(trie[/* subTrie */1]);
    var candidateSymbols = trie[/* symbol */0];
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              Rebase.$$Array[/* get */17](candidateSymbols, 0),
              Rebase.$$Array[/* length */16](keySuggestions) !== 0,
              keySuggestions,
              candidateSymbols
            ]);
  } else {
    return /* record */Block.record([
              "symbol",
              "further",
              "keySuggestions",
              "candidateSymbols"
            ], [
              undefined,
              false,
              [],
              []
            ]);
  }
}

var initialTranslation = translate("");

var Keymap = /* module */Block.localModule([
    "rawKeymap",
    "toTrie",
    "keymap",
    "toKeySuggestions",
    "toCandidateSymbols",
    "isInKeymap",
    "translate",
    "initialTranslation"
  ], [
    rawKeymap,
    toTrie,
    keymap,
    toKeySuggestions,
    toCandidateSymbols,
    isInKeymap,
    translate,
    initialTranslation
  ]);

var initialState_001 = /* buffer : record */Block.record([
    "surface",
    "underlying"
  ], [
    "",
    ""
  ]);

var initialState = /* record */Block.record([
    "activated",
    "buffer",
    "translation"
  ], [
    false,
    initialState_001,
    initialTranslation
  ]);

function insertTextBuffer(editor, $$char) {
  var textBuffer = editor.getBuffer();
  var getCharIndex = function (selection) {
    var start = selection.getBufferRange().start;
    return textBuffer.characterIndexForPosition(start);
  };
  var compareSelection = function (a, b) {
    var indexA = getCharIndex(a);
    var indexB = getCharIndex(b);
    return Caml_primitive.caml_int_compare(indexA, indexB);
  };
  var selections = editor.getSelections();
  $$Array.sort(compareSelection, selections);
  return Rebase.$$Array[/* forEach */8]((function (selection) {
                var range = selection.getBufferRange();
                textBuffer.setTextInRange(range, $$char);
                return /* () */0;
              }), selections);
}

function rewriteTextBuffer(editor, markers, string) {
  return Rebase.$$Array[/* forEach */8]((function (marker) {
                editor.getBuffer().setTextInRange(marker.getBufferRange(), string);
                return /* () */0;
              }), markers);
}

function toString(param) {
  if (typeof param === "number") {
    switch (param) {
      case 0 : 
          return "Activate";
      case 1 : 
          return "Deactivate";
      case 2 : 
          return "Clear";
      case 3 : 
          return "Backspace";
      
    }
  } else {
    switch (param.tag | 0) {
      case 0 : 
          return "InsertUnderlying " + param[0];
      case 1 : 
          return "InsertSurface " + param[0];
      case 2 : 
          return "InsertSurfaceAndUnderlying " + param[0];
      case 3 : 
          return "RewriteSurface " + param[0];
      
    }
  }
}

function reducer(editor, markers, setTranslation, action, state) {
  console.log(toString(action));
  console.log("=-=-=-=-=-=");
  if (typeof action === "number") {
    switch (action) {
      case 0 : 
          var match = state[/* activated */0];
          if (match) {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "buffer",
                          "translation"
                        ], [
                          false,
                          state[/* buffer */1],
                          state[/* translation */2]
                        ]),
                      (function (param) {
                          var send = param[/* send */0];
                          if (Rebase.$$String[/* isEmpty */5](state[/* buffer */1][/* underlying */1])) {
                            Curry._1(send, /* Clear */2);
                          } else {
                            Curry._1(send, /* InsertSurface */Block.variant("InsertSurface", 1, ["\\"]));
                          }
                          return undefined;
                        })
                    ]);
          } else {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "buffer",
                          "translation"
                        ], [
                          true,
                          state[/* buffer */1],
                          state[/* translation */2]
                        ]),
                      (function (param) {
                          Curry._1(param[/* send */0], /* InsertSurface */Block.variant("InsertSurface", 1, ["\\"]));
                          return undefined;
                        })
                    ]);
          }
      case 1 : 
          var match$1 = state[/* activated */0];
          if (match$1) {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "buffer",
                          "translation"
                        ], [
                          false,
                          state[/* buffer */1],
                          state[/* translation */2]
                        ]),
                      (function (param) {
                          Curry._1(param[/* send */0], /* Clear */2);
                          Curry._1(setTranslation, (function (param) {
                                  return initialTranslation;
                                }));
                          return undefined;
                        })
                    ]);
          } else {
            return /* NoUpdate */0;
          }
      case 2 : 
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "activated",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            "",
                            ""
                          ]),
                        state[/* translation */2]
                      ])]);
      case 3 : 
          var init = function (s) {
            return s.substring(0, Rebase.$$String[/* length */1](s) - 1 | 0);
          };
          var surface = init(state[/* buffer */1][/* surface */0]);
          var input = init(state[/* buffer */1][/* underlying */1]);
          translate(input);
          return /* Update */Block.variant("Update", 0, [/* record */Block.record([
                        "activated",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            surface,
                            input
                          ]),
                        state[/* translation */2]
                      ])]);
      
    }
  } else {
    switch (action.tag | 0) {
      case 0 : 
          var input$1 = state[/* buffer */1][/* underlying */1] + action[0];
          var translation = translate(input$1);
          console.log(translation);
          Curry._1(setTranslation, (function (param) {
                  return translation;
                }));
          var match$2 = translation[/* symbol */0];
          if (match$2 !== undefined) {
            var symbol = match$2;
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "buffer",
                          "translation"
                        ], [
                          state[/* activated */0],
                          Block.record([
                              "surface",
                              "underlying"
                            ], [
                              symbol,
                              input$1
                            ]),
                          state[/* translation */2]
                        ]),
                      (function (param) {
                          var send = param[/* send */0];
                          Curry._1(send, /* RewriteSurface */Block.variant("RewriteSurface", 3, [symbol]));
                          if (!translation[/* further */1]) {
                            Curry._1(send, /* Deactivate */1);
                          }
                          return undefined;
                        })
                    ]);
          } else {
            return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                      /* record */Block.record([
                          "activated",
                          "buffer",
                          "translation"
                        ], [
                          state[/* activated */0],
                          Block.record([
                              "surface",
                              "underlying"
                            ], [
                              state[/* buffer */1][/* surface */0],
                              input$1
                            ]),
                          state[/* translation */2]
                        ]),
                      (function (param) {
                          if (!translation[/* further */1]) {
                            Curry._1(param[/* send */0], /* Deactivate */1);
                          }
                          return undefined;
                        })
                    ]);
          }
      case 1 : 
          var $$char = action[0];
          var init$1 = state[/* buffer */1];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            state[/* buffer */1][/* surface */0] + $$char,
                            init$1[/* underlying */1]
                          ]),
                        state[/* translation */2]
                      ]),
                    (function (param) {
                        insertTextBuffer(editor, $$char);
                        return undefined;
                      })
                  ]);
      case 2 : 
          var $$char$1 = action[0];
          var init$2 = state[/* buffer */1];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            state[/* buffer */1][/* surface */0] + $$char$1,
                            init$2[/* underlying */1]
                          ]),
                        state[/* translation */2]
                      ]),
                    (function (param) {
                        insertTextBuffer(editor, $$char$1);
                        Curry._1(param[/* send */0], /* InsertUnderlying */Block.variant("InsertUnderlying", 0, [$$char$1]));
                        return undefined;
                      })
                  ]);
      case 3 : 
          var string = action[0];
          var init$3 = state[/* buffer */1];
          return /* UpdateWithSideEffects */Block.variant("UpdateWithSideEffects", 1, [
                    /* record */Block.record([
                        "activated",
                        "buffer",
                        "translation"
                      ], [
                        state[/* activated */0],
                        Block.record([
                            "surface",
                            "underlying"
                          ], [
                            string,
                            init$3[/* underlying */1]
                          ]),
                        state[/* translation */2]
                      ]),
                    (function (param) {
                        rewriteTextBuffer(editor, markers, string);
                        return undefined;
                      })
                  ]);
      
    }
  }
}

function addClass(editor) {
  atom.views.getView(editor).classList.add("agda-mode-input-method-activated");
  return /* () */0;
}

function removeClass(editor) {
  atom.views.getView(editor).classList.remove("agda-mode-input-method-activated");
  return /* () */0;
}

function markSelectedAreas(editor) {
  return Rebase.$$Array[/* map */0]((function (range) {
                return editor.markBufferRange(range.copy());
              }), editor.getSelectedBufferRanges());
}

function markerOnDidChange(editor, buffer, send, $$event) {
  var rangeOld = new Atom.Range($$event.oldTailBufferPosition, $$event.oldHeadBufferPosition);
  var rangeNew = new Atom.Range($$event.newTailBufferPosition, $$event.newHeadBufferPosition);
  var comparison = rangeNew.compare(rangeOld);
  var textBuffer = editor.getBuffer();
  if (rangeNew.isEmpty()) {
    return Curry._1(send, /* Deactivate */1);
  } else {
    var surfaceBuffer = textBuffer.getTextInRange(rangeNew);
    if (surfaceBuffer !== buffer[/* surface */0]) {
      console.log(/* tuple */[
            surfaceBuffer,
            buffer[/* surface */0]
          ]);
      if (comparison === -1) {
        var insertedChar = textBuffer.getTextInRange(rangeNew).substr(-1);
        Curry._1(send, /* InsertUnderlying */Block.variant("InsertUnderlying", 0, [insertedChar]));
      }
      if (comparison === 1) {
        return Curry._1(send, /* Backspace */3);
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
}

function monitor(editor, buffer, send, setMarkers) {
  var disposables = new Atom.CompositeDisposable();
  addClass(editor);
  var markers = markSelectedAreas(editor);
  Curry._1(setMarkers, (function (param) {
          return markers;
        }));
  Rebase.$$Option[/* forEach */8]((function (marker) {
          disposables.add(marker.onDidChange((function (param) {
                      return markerOnDidChange(editor, buffer, send, param);
                    })));
          disposables.add(atom.commands.add("atom-text-editor.agda-mode-input-method-activated", "editor:newline", (function ($$event) {
                      Curry._1(send, /* Deactivate */1);
                      $$event.stopImmediatePropagation();
                      return /* () */0;
                    })));
          return /* () */0;
        }), Rebase.$$Array[/* get */17](markers, 0));
  disposables.add(editor.onDidChangeCursorPosition((function ($$event) {
              var point = $$event.newBufferPosition;
              var ranges = Rebase.$$Array[/* map */0]((function (prim) {
                      return prim.getBufferRange();
                    }), markers);
              var inRange = Rebase.$$Array[/* exists */9]((function (param) {
                      return param.containsPoint(point);
                    }), ranges);
              if (inRange) {
                return 0;
              } else {
                return Curry._1(send, /* Deactivate */1);
              }
            })));
  var decorations = Rebase.$$Array[/* map */0]((function (marker) {
          return editor.decorateMarker(marker, {
                      type: "highlight",
                      class: "input-method-decoration"
                    });
        }), markers);
  return (function (param) {
            Rebase.$$Array[/* forEach */8]((function (prim) {
                    prim.destroy();
                    return /* () */0;
                  }), decorations);
            Rebase.$$Array[/* forEach */8]((function (prim) {
                    prim.destroy();
                    return /* () */0;
                  }), markers);
            disposables.dispose();
            return /* () */0;
          });
}

function InputMethod2(Props) {
  var editors = Props.editors;
  Props.interceptAndInsertKey;
  var activateInputMethod = Props.activateInputMethod;
  Props.onActivationChange;
  Props.isActive;
  var editor = Editors$AgdaMode.Focus[/* get */0](editors);
  var match = React.useState((function () {
          return initialTranslation;
        }));
  var setTranslation = match[1];
  var match$1 = React.useState((function () {
          return /* array */[];
        }));
  var setMarkers = match$1[1];
  var markers = match$1[0];
  var match$2 = ReactUpdate.useReducer(initialState, (function (param, param$1) {
          return reducer(editor, markers, setTranslation, param, param$1);
        }));
  var send = match$2[1];
  var state = match$2[0];
  React.useEffect((function () {
          console.log("buffer [" + (state[/* buffer */1][/* surface */0] + ("] [" + (state[/* buffer */1][/* underlying */1] + "]"))));
          return undefined;
        }), /* array */[state[/* buffer */1]]);
  Hook$AgdaMode.useListenWhen((function (param) {
          return monitor(editor, state[/* buffer */1], send, setMarkers);
        }), state[/* activated */0]);
  React.useEffect((function () {
          console.log("REG");
          return Rebase.$$Option[/* some */11](Event$AgdaMode.onOk((function (shouldActivate) {
                              console.log("AC");
                              return Curry._1(send, shouldActivate ? /* Activate */0 : /* Deactivate */1);
                            }))(activateInputMethod));
        }), /* array */[]);
  return null;
}

var component = ReasonReact.statelessComponent("InputMethod");

function make(editors, interceptAndInsertKey, activateInputMethod, onActivationChange, isActive, children) {
  return ReasonReactCompat.wrapReactForReasonReact(InputMethod2, {
              editors: editors,
              interceptAndInsertKey: interceptAndInsertKey,
              activateInputMethod: activateInputMethod,
              onActivationChange: onActivationChange,
              isActive: isActive
            }, children);
}

var Jsx2 = /* module */Block.localModule([
    "component",
    "make"
  ], [
    component,
    make
  ]);

var sort = $$Array.sort;

var Garbages = 0;

var make$1 = InputMethod2;

exports.sort = sort;
exports.Keymap = Keymap;
exports.Garbages = Garbages;
exports.initialState = initialState;
exports.insertTextBuffer = insertTextBuffer;
exports.rewriteTextBuffer = rewriteTextBuffer;
exports.toString = toString;
exports.reducer = reducer;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.markSelectedAreas = markSelectedAreas;
exports.markerOnDidChange = markerOnDidChange;
exports.monitor = monitor;
exports.make = make$1;
exports.Jsx2 = Jsx2;
/* rawKeymap Not a pure module */
