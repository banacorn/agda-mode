// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Util$AgdaMode = require("./Util.bs.js");
var Child_process = require("child_process");
var Event$AgdaMode = require("./Util/Event.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function toString(param) {
  switch (param.tag | 0) {
    case /* ProcessHanging */0 :
        return /* tuple */[
                "Process not responding when looking for \"" + (param[0] + "\""),
                "Please restart the process"
              ];
    case /* NotSupported */1 :
        return /* tuple */[
                "Auto search failed",
                "currently auto path searching is not supported on " + (String(param[0]) + "")
              ];
    case /* NotFound */2 :
        return /* tuple */[
                "Auto search failed when looking for \"" + (param[0] + "\""),
                param[1]
              ];
    
  }
}

var $$Error = {
  toString: toString
};

function run(name) {
  var match = $$Promise.pending(/* () */0);
  var resolve = match[1];
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */Caml_chrome_debugger.variant("ProcessHanging", 0, [name])]));
        }), 1000);
  var os = Os.type();
  var commandName;
  switch (os) {
    case "Darwin" :
    case "Linux" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["which"]);
        break;
    case "Windows_NT" :
        commandName = /* Ok */Caml_chrome_debugger.variant("Ok", 0, ["where.exe"]);
        break;
    default:
      commandName = /* Error */Caml_chrome_debugger.variant("Error", 1, [os]);
  }
  if (commandName.tag) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotSupported */Caml_chrome_debugger.variant("NotSupported", 1, [commandName[0]])]));
  } else {
    Child_process.exec(commandName[0] + (" " + name), (function (error, stdout, stderr) {
            clearTimeout(hangTimeout);
            if (!(error == null)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          Rebase.$$Option.getOr("", error.message)
                        ])]));
            }
            var stderr$1 = stderr.toString();
            if (!Rebase.$$String.isEmpty(stderr$1)) {
              Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                          name,
                          stderr$1
                        ])]));
            }
            var stdout$1 = stdout.toString();
            if (Rebase.$$String.isEmpty(stdout$1)) {
              return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* NotFound */Caml_chrome_debugger.variant("NotFound", 2, [
                                name,
                                ""
                              ])]));
            } else {
              return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [stdout$1]));
            }
          }));
  }
  return match[0];
}

var SearchPath = {
  $$Error: $$Error,
  run: run
};

function toString$1(param) {
  if (typeof param === "number") {
    return /* tuple */[
            "Process hanging",
            "The program has not been responding for more than 1 sec"
          ];
  } else {
    switch (param.tag | 0) {
      case /* PathMalformed */0 :
          return /* tuple */[
                  "Path malformed",
                  param[0]
                ];
      case /* NotFound */1 :
          return /* tuple */[
                  "Command not found",
                  Util$AgdaMode.JsError.toString(param[0])
                ];
      case /* ShellError */2 :
          return /* tuple */[
                  "Error from the shell",
                  Util$AgdaMode.JsError.toString(param[0])
                ];
      case /* ProcessError */3 :
          return /* tuple */[
                  "Error from the stderr",
                  param[0]
                ];
      case /* WrongProcess */4 :
          return /* tuple */[
                  "Wrong process",
                  param[0]
                ];
      
    }
  }
}

var $$Error$1 = {
  toString: toString$1
};

function run$1(path, validator) {
  var parseError = function (error) {
    if (error == null) {
      return ;
    } else {
      var message = Rebase.$$Option.getOr("", error.message);
      if ((/No such file or directory/).test(message) || (/command not found/).test(message)) {
        return /* NotFound */Caml_chrome_debugger.variant("NotFound", 1, [error]);
      } else {
        return /* ShellError */Caml_chrome_debugger.variant("ShellError", 2, [error]);
      }
    }
  };
  var match = $$Promise.pending(/* () */0);
  var resolve = match[1];
  if (Rebase.$$String.isEmpty(path)) {
    Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* PathMalformed */Caml_chrome_debugger.variant("PathMalformed", 0, ["the path must not be empty"])]));
  }
  var hangTimeout = setTimeout((function (param) {
          return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessHanging */0]));
        }), 20000);
  Child_process.exec(path + " -V", (function (error, stdout, stderr) {
          clearTimeout(hangTimeout);
          var match = parseError(error);
          if (match !== undefined) {
            Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [match]));
          }
          var stderr$1 = stderr.toString();
          if (!Rebase.$$String.isEmpty(stderr$1)) {
            Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ProcessError */Caml_chrome_debugger.variant("ProcessError", 3, [stderr$1])]));
          }
          var match$1 = Curry._2(validator, path, stdout.toString());
          if (match$1.tag) {
            return Curry._1(resolve, /* Error */Caml_chrome_debugger.variant("Error", 1, [/* WrongProcess */Caml_chrome_debugger.variant("WrongProcess", 4, [match$1[0]])]));
          } else {
            return Curry._1(resolve, /* Ok */Caml_chrome_debugger.variant("Ok", 0, [match$1[0]]));
          }
        }));
  return match[0];
}

var Validate = {
  $$Error: $$Error$1,
  run: run$1
};

function toString$2(param) {
  if (typeof param === "number") {
    return /* tuple */[
            "Disconnected",
            "Connection disconnected by ourselves"
          ];
  } else {
    switch (param.tag | 0) {
      case /* ClosedByProcess */0 :
          return /* tuple */[
                  "Socket closed by GCL",
                  "exited with code: " + (String(param[0]) + ("\nsignal: " + (String(param[1]) + "\n")))
                ];
      case /* ShellError */1 :
          return /* tuple */[
                  "Socket error",
                  Util$AgdaMode.JsError.toString(param[0])
                ];
      case /* ExitedByProcess */2 :
          return /* tuple */[
                  "GCL has crashed",
                  "exited with code: " + (String(param[0]) + ("\n  signal: " + (String(param[1]) + "\n  ")))
                ];
      
    }
  }
}

var $$Error$2 = {
  toString: toString$2
};

function connect(path, args) {
  var emitter = Event$AgdaMode.make(/* () */0);
  var $$process = Child_process.spawn(path, args, {
        shell: true
      });
  $$process.stdout.on("data", (function (chunk) {
          Curry._1(emitter[/* emit */1], /* Ok */Caml_chrome_debugger.variant("Ok", 0, [chunk.toString()]));
          return /* () */0;
        }));
  $$process.stdin.on("close", (function (param) {
          Curry._1(emitter[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                      0,
                      ""
                    ])]));
          return /* () */0;
        }));
  $$process.on("close", (function (code, signal) {
                Curry._1(emitter[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ClosedByProcess */Caml_chrome_debugger.variant("ClosedByProcess", 0, [
                            code,
                            signal
                          ])]));
                return /* () */0;
              })).on("disconnect", (function (param) {
              Curry._1(emitter[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* DisconnectedByUser */0]));
              return /* () */0;
            })).on("error", (function (exn) {
            Curry._1(emitter[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ShellError */Caml_chrome_debugger.variant("ShellError", 1, [exn])]));
            return /* () */0;
          })).on("exit", (function (code, signal) {
          Curry._1(emitter[/* emit */1], /* Error */Caml_chrome_debugger.variant("Error", 1, [/* ExitedByProcess */Caml_chrome_debugger.variant("ExitedByProcess", 2, [
                      code,
                      signal
                    ])]));
          return /* () */0;
        }));
  return emitter;
}

var Process = {
  $$Error: $$Error$2,
  connect: connect
};

exports.SearchPath = SearchPath;
exports.Validate = Validate;
exports.Process = Process;
/* os Not a pure module */
