// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Async$AgdaMode = require("./Async.bs.js");

function make(resolve, id) {
  return /* record */Block.record([
            "resolve",
            "id"
          ], [
            resolve,
            id
          ]);
}

function map(f, g, listener) {
  return /* record */Block.record([
            "resolve",
            "id"
          ], [
            (function (x) {
                return Curry._1(listener[/* resolve */0], Rebase.Result[/* map2 */1](f, g, x));
              }),
            listener[/* id */1]
          ]);
}

var Listener = /* module */Block.localModule([
    "make",
    "map"
  ], [
    make,
    map
  ]);

function make$1(param) {
  return /* record */Block.record([
            "counter",
            "listeners"
          ], [
            Block.record(["contents"], [0]),
            { }
          ]);
}

function removeListener(_id, _self) {
  return (delete _self[1][String(_id)]);
}

function removeListener$prime(_id, _self) {
  return (delete _self[1][_id]);
}

function removeAllListeners(self) {
  Rebase.$$Array[/* forEach */8]((function (id) {
          return removeListener$prime(id, self);
        }), Object.keys(self[/* listeners */1]));
  return /* () */0;
}

function listen(callback, self) {
  var id = self[/* counter */0][0] + 1 | 0;
  self[/* counter */0][0] = id;
  var listener = /* record */Block.record([
      "resolve",
      "id"
    ], [
      callback,
      id
    ]);
  self[/* listeners */1][String(id)] = listener;
  return (function (param) {
      return removeListener(id, self);
    });
}

function destroyWhen(trigger, destructor) {
  return Curry._1(trigger, destructor);
}

function map$1(f, g, x) {
  return /* record */Block.record([
            "counter",
            "listeners"
          ], [
            x[/* counter */0],
            Js_dict.map((function (l) {
                    return map(f, g, l);
                  }), x[/* listeners */1])
          ]);
}

function onOk(callback) {
  return (function (param) {
      return listen((function (param) {
                    if (param.tag) {
                      return /* () */0;
                    } else {
                      return Curry._1(callback, param[0]);
                    }
                  }), param);
    });
}

function onError(callback) {
  return (function (param) {
      return listen((function (param) {
                    if (param.tag) {
                      return Curry._1(callback, param[0]);
                    } else {
                      return /* () */0;
                    }
                  }), param);
    });
}

function once(self) {
  var id = self[/* counter */0][0] + 1 | 0;
  self[/* counter */0][0] = id;
  return Async$AgdaMode.make((function (resolve, reject) {
                var callback = function (param) {
                  if (param.tag) {
                    Curry._1(reject, param[0]);
                    return removeListener(id, self);
                  } else {
                    Curry._1(resolve, param[0]);
                    return removeListener(id, self);
                  }
                };
                var listener = /* record */Block.record([
                    "resolve",
                    "id"
                  ], [
                    callback,
                    id
                  ]);
                self[/* listeners */1][String(id)] = listener;
                return /* () */0;
              }));
}

function emitOk(x, self) {
  return Rebase.$$Array[/* forEach */8]((function (listener) {
                return Curry._1(listener[/* resolve */0], /* Ok */Block.variant("Ok", 0, [x]));
              }), Js_dict.values(self[/* listeners */1]));
}

function emitError(x, self) {
  return Rebase.$$Array[/* forEach */8]((function (listener) {
                return Curry._1(listener[/* resolve */0], /* Error */Block.variant("Error", 1, [x]));
              }), Js_dict.values(self[/* listeners */1]));
}

function pipe(to_, from) {
  return listen((function (param) {
                if (param.tag) {
                  return emitError(param[0], to_);
                } else {
                  return emitOk(param[0], to_);
                }
              }), from);
}

function pipeMap(to_, f, from) {
  return listen((function (param) {
                if (param.tag) {
                  return emitError(param[0], to_);
                } else {
                  return emitOk(Curry._1(f, param[0]), to_);
                }
              }), from);
}

var destroy = removeAllListeners;

var on = listen;

exports.Listener = Listener;
exports.make = make$1;
exports.removeListener = removeListener;
exports.removeListener$prime = removeListener$prime;
exports.removeAllListeners = removeAllListeners;
exports.destroy = destroy;
exports.listen = listen;
exports.destroyWhen = destroyWhen;
exports.on = on;
exports.map = map$1;
exports.onOk = onOk;
exports.onError = onError;
exports.once = once;
exports.emitOk = emitOk;
exports.emitError = emitError;
exports.pipe = pipe;
exports.pipeMap = pipeMap;
/* Async-AgdaMode Not a pure module */
