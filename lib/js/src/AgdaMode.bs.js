// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Atom = require("atom");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Parser$AgdaMode = require("./Parser.bs.js");
var Command$AgdaMode = require("./Command.bs.js");
var Instance$AgdaMode = require("./Instance.bs.js");
var TaskRunner$AgdaMode = require("./Task/TaskRunner.bs.js");

var activated = {
  contents: false
};

var instances = { };

function textEditorID(editor) {
  return String(editor.id);
}

function get(textEditor) {
  return Js_dict.get(instances, String(textEditor.id));
}

function add(textEditor) {
  var _instance = Js_dict.get(instances, String(textEditor.id));
  if (_instance !== undefined) {
    return ;
  } else {
    instances[String(textEditor.id)] = Instance$AgdaMode.make(textEditor);
    return ;
  }
}

var deleteEntry = (function (id) {delete instances[id]});

function remove(textEditor) {
  var id = String(textEditor.id);
  var instance = Js_dict.get(instances, id);
  if (instance !== undefined) {
    Instance$AgdaMode.destroy(instance);
    deleteEntry(id);
    return ;
  }
  
}

function destroyAll(param) {
  return Belt_Array.forEach(Js_dict.entries(instances), (function (param) {
                Instance$AgdaMode.destroy(param[1]);
                deleteEntry(param[0]);
                
              }));
}

function contains(textEditor) {
  return Js_dict.get(instances, String(textEditor.id)) !== undefined;
}

function size(param) {
  return Object.keys(instances).length;
}

var Instances = {
  textEditorID: textEditorID,
  get: get,
  add: add,
  deleteEntry: deleteEntry,
  remove: remove,
  destroyAll: destroyAll,
  contains: contains,
  size: size
};

function isAgdaFile(textEditor) {
  var filepath = Parser$AgdaMode.filepath(Belt_Option.getWithDefault(textEditor.getPath(), "untitled"));
  var onWindows = Os.type() === "Windows_NT";
  if (onWindows) {
    return /\.agda$|\.lagda$/i.test(filepath);
  } else {
    return /\.agda$|\.lagda$/.test(filepath);
  }
}

var subscriptions = new Atom.CompositeDisposable();

function onEditorActivationChange(param) {
  var previous = {
    contents: atom.workspace.getActiveTextEditor()
  };
  subscriptions.add(atom.workspace.onDidChangeActiveTextEditor((function (next) {
              Belt_Option.forEach(Belt_Option.flatMap(previous.contents, get), (function (instance) {
                      Instance$AgdaMode.deactivate(instance);
                      
                    }));
              if (next === undefined) {
                return ;
              }
              var nextEditor = Caml_option.valFromOption(next);
              Belt_Option.forEach(get(nextEditor), (function (instance) {
                      Instance$AgdaMode.activate(instance);
                      
                    }));
              previous.contents = Caml_option.some(nextEditor);
              
            })));
  
}

function eventTargetEditor($$event) {
  var targetSubElement = $$event.target;
  var targetedEditors = Belt_Array.keep(atom.workspace.getTextEditors(), (function (editor) {
          return atom.views.getView(editor).contains(targetSubElement);
        }));
  return Belt_Array.get(targetedEditors, 0);
}

function onTriggerCommand(param) {
  return Belt_Array.forEach(Command$AgdaMode.names, (function (command) {
                subscriptions.add(atom.commands.add("atom-text-editor", "agda-mode:" + command, (function ($$event) {
                            return Belt_Option.forEach(Belt_Option.flatMap(eventTargetEditor($$event), get), (function (instance) {
                                          TaskRunner$AgdaMode.dispatchCommand(Command$AgdaMode.parse(command), instance);
                                          
                                        }));
                          })));
                
              }));
}

function onUndo(param) {
  subscriptions.add(atom.commands.add("atom-text-editor", "core:undo", (function ($$event) {
              $$event.stopImmediatePropagation();
              var activated = atom.workspace.getActiveTextEditor();
              return Belt_Option.forEach(Belt_Option.flatMap(activated, get), Instance$AgdaMode.dispatchUndo);
            })));
  
}

function onOpenEditor(param) {
  subscriptions.add(atom.workspace.observeTextEditors((function (textEditor) {
              var textEditorSubscriptions = new Atom.CompositeDisposable();
              if (isAgdaFile(textEditor)) {
                add(textEditor);
              }
              textEditorSubscriptions.add(textEditor.onDidChangePath((function (param) {
                          if (!isAgdaFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          if (isAgdaFile(textEditor) && !contains(textEditor)) {
                            return add(textEditor);
                          }
                          
                        })));
              textEditorSubscriptions.add(textEditor.onDidDestroy((function (param) {
                          if (isAgdaFile(textEditor) && contains(textEditor)) {
                            remove(textEditor);
                          }
                          textEditorSubscriptions.dispose();
                          
                        })));
              
            })));
  
}

function setup(param) {
  onOpenEditor(undefined);
  onEditorActivationChange(undefined);
  onTriggerCommand(undefined);
  return onUndo(undefined);
}

function activate(param) {
  if (!activated.contents) {
    activated.contents = true;
    setup(undefined);
  }
  return Promise.resolve(undefined);
}

function deactivate(param) {
  if (activated.contents) {
    activated.contents = false;
    destroyAll(undefined);
    subscriptions.dispose();
    return ;
  }
  
}

var config = {
  agdaPath: {
    title: "Agda path",
    description: "Path to the executable of Agda, automatically inferred when possible. Overwrite to override.",
    type: "string",
    default: "",
    order: 0
  },
  agdaArgs: {
    title: "Agda command-line arguments",
    description: "For example: to use \"agda --cubical --safe\", put \"--cubical --safe\" in this field",
    type: "string",
    default: "",
    order: 1
  },
  agdaName: {
    title: "Agda name",
    description: "Default to \"agda\", this is the name we use to search for the path",
    type: "string",
    default: "agda",
    order: 2
  },
  enableJSONProtocol: {
    title: "Enable the JSON protocol (experimental)",
    description: "Demand Agda to output in JSON format when possible",
    type: "boolean",
    default: false,
    order: 3
  },
  libraryPath: {
    title: "Libraries",
    description: "Paths to include (such as agda-stdlib), seperate with comma. Useless after Agda 2.5.0",
    type: "array",
    default: [],
    items: {
      type: "string"
    },
    order: 10
  },
  backend: {
    title: "Backend",
    description: "The backend which is used to compile Agda programs.",
    type: "string",
    default: "GHCNoMain",
    enum: [
      "GHC",
      "GHCNoMain"
    ],
    order: 11
  },
  highlightingMethod: {
    title: "Highlighting information passing",
    description: "Receive parsed result from Agda, directly from stdio, or indirectly from temporary files (which requires frequent disk access)",
    type: "string",
    default: "Direct",
    enum: [
      "Indirect",
      "Direct"
    ],
    order: 20
  },
  maxBodyHeight: {
    title: "Max panel size",
    description: "The max height the panel could strech",
    type: "integer",
    default: 170,
    minimum: 40,
    maximum: 1010,
    order: 30
  },
  inputMethod: {
    title: "Input method",
    description: "Enable input method",
    type: "boolean",
    default: true,
    order: 40
  },
  inputMethodExtension: {
    title: "Input method extension",
    description: "For adding or prioritizing key mappings. Please edit this from \"Settings > Input Method > Keymap extensions\"",
    type: "string",
    default: "{\"^r\":[\"ʳ\"],\"^l\":[\"ˡ\"]}",
    order: 41
  },
  trimSpaces: {
    title: "Trim spaces",
    description: "Remove leading and trailing spaces of an expression in an hole, when giving it to Agda. (Default to be False in Emacs, but True in here)",
    type: "boolean",
    default: true,
    order: 50
  }
};

exports.activated = activated;
exports.instances = instances;
exports.Instances = Instances;
exports.isAgdaFile = isAgdaFile;
exports.subscriptions = subscriptions;
exports.onEditorActivationChange = onEditorActivationChange;
exports.eventTargetEditor = eventTargetEditor;
exports.onTriggerCommand = onTriggerCommand;
exports.onUndo = onUndo;
exports.onOpenEditor = onOpenEditor;
exports.setup = setup;
exports.activate = activate;
exports.deactivate = deactivate;
exports.config = config;
/* subscriptions Not a pure module */
