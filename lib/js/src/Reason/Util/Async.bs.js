// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");

function make(callback) {
  return new Promise((function (resolve, param) {
                var resolve$prime = function (x) {
                  return resolve(/* Ok */Block.variant("Ok", 0, [x]));
                };
                var reject = function (x) {
                  return resolve(/* Error */Block.variant("Error", 1, [x]));
                };
                return Curry._2(callback, resolve$prime, reject);
              }));
}

function resolve(x) {
  return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x]));
}

function reject(x) {
  return Promise.resolve(/* Error */Block.variant("Error", 1, [x]));
}

function fromPromise(promise) {
  return promise.then((function (x) {
                return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x]));
              }));
}

function map(f, g) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      var x = Curry._1(g, param[0]);
                      return Promise.resolve(/* Error */Block.variant("Error", 1, [x]));
                    } else {
                      var x$1 = Curry._1(f, param[0]);
                      return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x$1]));
                    }
                  }));
    });
}

function mapOk(f) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      return Promise.resolve(/* Error */Block.variant("Error", 1, [param[0]]));
                    } else {
                      var x = Curry._1(f, param[0]);
                      return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x]));
                    }
                  }));
    });
}

function thenOk(f) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      return Promise.resolve(/* Error */Block.variant("Error", 1, [param[0]]));
                    } else {
                      return Curry._1(f, param[0]);
                    }
                  }));
    });
}

function finalOk(f, p) {
  thenOk((function (x) {
            var x$1 = Curry._1(f, x);
            return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x$1]));
          }))(p);
  return /* () */0;
}

function mapError(f) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      var x = Curry._1(f, param[0]);
                      return Promise.resolve(/* Error */Block.variant("Error", 1, [x]));
                    } else {
                      return Promise.resolve(/* Ok */Block.variant("Ok", 0, [param[0]]));
                    }
                  }));
    });
}

function thenError(f) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      return Curry._1(f, param[0]);
                    } else {
                      return Promise.resolve(/* Ok */Block.variant("Ok", 0, [param[0]]));
                    }
                  }));
    });
}

function finalError(f, p) {
  thenError((function (e) {
            var x = Curry._1(f, e);
            return Promise.resolve(/* Ok */Block.variant("Ok", 0, [x]));
          }))(p);
  return /* () */0;
}

function flatten(merge) {
  return (function (param) {
      return param.then((function (param) {
                    if (param.tag) {
                      var x = Curry._1(merge, /* Error */Block.variant("Error", 1, [param[0]]));
                      return Promise.resolve(/* Error */Block.variant("Error", 1, [x]));
                    } else {
                      var match = param[0];
                      if (match.tag) {
                        var x$1 = Curry._1(merge, /* Ok */Block.variant("Ok", 0, [match[0]]));
                        return Promise.resolve(/* Error */Block.variant("Error", 1, [x$1]));
                      } else {
                        return Promise.resolve(/* Ok */Block.variant("Ok", 0, [match[0]]));
                      }
                    }
                  }));
    });
}

var P = 0;

exports.P = P;
exports.make = make;
exports.resolve = resolve;
exports.reject = reject;
exports.fromPromise = fromPromise;
exports.map = map;
exports.mapOk = mapOk;
exports.thenOk = thenOk;
exports.finalOk = finalOk;
exports.mapError = mapError;
exports.thenError = thenError;
exports.finalError = finalError;
exports.flatten = flatten;
/* No side effect */
