// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Rebase = require("@glennsl/rebase/lib/js/src/Rebase.bs.js");
var Translator$AgdaMode = require("./Translator.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");

function init(string) {
  return string.substring(0, Rebase.$$String.length(string) - 1 | 0);
}

function isEmpty(self) {
  if (self.symbol === undefined) {
    return Rebase.$$String.isEmpty(self.tail);
  } else {
    return false;
  }
}

function toSequence(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[1] + self.tail;
  } else {
    return self.tail;
  }
}

function toSurface(self) {
  var match = self.symbol;
  if (match !== undefined) {
    return match[0] + self.tail;
  } else {
    return self.tail;
  }
}

function toString(self) {
  return "\"" + (toSurface(self) + ("\"[" + (toSequence(self) + "]")));
}

function next(self, reality) {
  var surface = toSurface(self);
  var sequence = toSequence(self);
  if (reality === surface) {
    if (Translator$AgdaMode.translate(sequence).further && reality !== "\\") {
      return /* Noop */0;
    } else {
      return /* Complete */1;
    }
  }
  if (init(reality) !== surface) {
    if (reality === init(surface) || reality === init(sequence)) {
      if (Rebase.$$String.isEmpty(reality)) {
        if (Rebase.$$Option.isSome(self.symbol)) {
          return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 2, [{
                      symbol: undefined,
                      tail: init(sequence)
                    }]);
        } else {
          return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [2]);
        }
      } else {
        return /* Backspace */Caml_chrome_debugger.variant("Backspace", 1, [{
                    symbol: self.symbol,
                    tail: init(self.tail)
                  }]);
      }
    } else {
      return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [3]);
    }
  }
  var insertedChar = reality.substr(-1);
  var sequence$prime = sequence + insertedChar;
  var translation = Translator$AgdaMode.translate(sequence$prime);
  var symbol = translation.symbol;
  if (symbol !== undefined) {
    if (insertedChar === symbol && insertedChar === "\\") {
      return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [0]);
    } else {
      return /* Rewrite */Caml_chrome_debugger.variant("Rewrite", 2, [{
                  symbol: /* tuple */[
                    symbol,
                    sequence$prime
                  ],
                  tail: ""
                }]);
    }
  } else if (translation.further) {
    return /* Insert */Caml_chrome_debugger.variant("Insert", 0, [{
                symbol: self.symbol,
                tail: self.tail + insertedChar
              }]);
  } else {
    return /* Stuck */Caml_chrome_debugger.variant("Stuck", 3, [1]);
  }
}

var initial = {
  symbol: undefined,
  tail: ""
};

exports.init = init;
exports.initial = initial;
exports.isEmpty = isEmpty;
exports.toSequence = toSequence;
exports.toSurface = toSurface;
exports.toString = toString;
exports.next = next;
/* Translator-AgdaMode Not a pure module */
